I"Pn<h1 id="해시함수">해시함수</h1>
<ul>
  <li>해시함수
    <ul>
      <li>일방향 해시함수
        <ul>
          <li>일방향 해시함수의 개요
            <ul>
              <li>기본개념
                <ul>
                  <li>일방향 해시함수(one-way hash function) 에는 입력과 출력이 각각 1개씩 있음</li>
                  <li>입력은 메시지(message) - 임의의 길이, 출력은 해시값(hash value) - 고정된 길이</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>일방향 해시함수의 성질
            <ul>
              <li>임의 길이의 메시지로부터 고정 길이의 해시값을 계산</li>
              <li>해시값을 고속으로 계산</li>
              <li>일방향성을 가짐. (해시값으로부터 메시지를 역산할 수 없음)</li>
              <li>메시지가 다르면 해시값도 다름. (무결성 확인용)
                <ul>
                  <li>메시지가 1비트라도 변하면 해시값은 매우 높은 확률로 다른 값이 되야 함.</li>
                  <li>2개의 다른 메시지가 같은 해시값을 갖는 것을 충돌(collision) 이라고 함.</li>
                </ul>
              </li>
              <li>충돌이 발생하는 것이 어려운 성질 =&gt; 충돌 내성 (collision resistance)</li>
              <li>해시 함수 = 메시지 다이제스트 함수 = 메시지 요약함수</li>
              <li>무결성 = 완전성 = 보전성</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>메시지 무결성
        <ul>
          <li>무결성 점검
            <ul>
              <li>무결성 점검을 위해 암호학적 해시함수 사용</li>
              <li>생성된 메시지 다이제스트와 이전 메시지 다이제스트를 비교</li>
              <li>두 개가 동일하면 원래 메시지가 변경되지 않음</li>
            </ul>
          </li>
          <li>암호학적 해시함수 기준
            <ul>
              <li>개요 (암호학적 해시함수는 다음을 충족해야 함)
                <ul>
                  <li>프리이미지 저항성 (preimage resistance) : <strong>역상 저항성</strong>
                    <ul>
                      <li>해시함수 h 와 y=h(M) 에 대하여 Eve 가 이를 만족하는 M 값을 찾아내는게 힘들어야 함</li>
                      <li><strong>y = h(x) 를 만족하는 x 를 찾는 것이 불가능해야 함.</strong></li>
                    </ul>
                  </li>
                  <li>제2프리이미지 저항성 (second preimage resistance) : 두 번째 역상 저항성, <strong>약한 충돌 내성</strong>
                    <ul>
                      <li>메시지를 쉽게 위조할 수 없도록 하는 성질</li>
                      <li>Eve가 메시지와 다이제스트를 가로채고 또 다른 다이제스트를 생성</li>
                      <li><strong>입력값 x에 대해서 h(x) = h(x’), x != x’ 을 만족하는 x’ 을 찾는 것이 불가능해야 함.</strong></li>
                    </ul>
                  </li>
                  <li>충돌 저항성 (collision resistance) : <strong>강한 충돌 내성</strong>
                    <ul>
                      <li>약한 충돌 내성보다 확률이 높음</li>
                      <li>Eve 로 하여금 동일한 다이제스트를 가지는 2개의 메시지를 구하지 못하도록 하는 것</li>
                      <li><strong>h(x) = h(x’) 을 만족하는 입력값 x, x’ 을 찾는다는 것은 계산적으로 불가능해야 함.</strong></li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>일방향 해시함수의 응용
        <ul>
          <li>소프트웨어 변경 검출</li>
          <li>무결성 검증</li>
          <li>패스워드를 기초로 한 암호화
            <ul>
              <li>패스워드와 솔트(의사난수 랜덤 값)를 섞은 결과의 해시값을 구해 그것을 암호화키로 사용 =&gt; 사전 공격 차단</li>
            </ul>
          </li>
          <li>메시지 인증코드
            <ul>
              <li>송신자와 수신자만의 키와 메시지를 혼합하여 해시값을 계산 한 것</li>
              <li>SSL/TLS 에서도 사용</li>
            </ul>
          </li>
          <li>전자서명</li>
          <li>전자입찰 시스템</li>
        </ul>
      </li>
      <li>랜덤 오라클 모델과 해시함수에 대한 공격
        <ul>
          <li>랜덤 오라클 모델
            <ul>
              <li>개요
                <ul>
                  <li>해시함수에 대한 이상적인 수학적 모델</li>
                </ul>
              </li>
              <li>비둘기집 원리
                <ul>
                  <li>n+1 비들기가 n개의 집에 들어가 있을 때 한 비둘기 집에는 두마리가 있다는 원리 (충돌을 의미)</li>
                </ul>
              </li>
              <li>생일 문제 (생일 공격)
                <ul>
                  <li>같은 해시값을 생성하는 2개의 메시지를 구하는 것</li>
                  <li>강한 충돌 내성을 깨고자 하는 공격</li>
                  <li>생일 패러독스 (birthday paradox) -&gt; 일치할 확률이 상상 이상으로 높아지는 것</li>
                  <li>랜덤으로 선택한 N명의 그룹, N 명 중 적어도 2명의 생일이 일치할 확률이 1/2 이상이 되도록 하기 위한 N은 최저 몇 명? -&gt; 23명
                    <ul>
                      <li>N명 전원 생일이 일치하지 않을 확률을 1에서 빼면 됨.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>일방향 해시함수에 대한 공격
        <ul>
          <li>무차별 공격
            <ul>
              <li>약한 충돌 내성을 깨고자 하는 공격</li>
              <li>SHA-1 은 160 비트라서 2의 160승 회를 시행하면 됨</li>
            </ul>
          </li>
          <li>기타 해시함수 공격의 종류 및 특성
            <ul>
              <li>일치블록 연쇄공격 : 새로운 메시지 M’ 을 사전에 다양하게 만들어 놓았다가 공격하고자 하는 메시지의 해시함수값 h(M) 과 같은 해시함수값을 갖는 것을 골라 사용하는 공격</li>
              <li>중간자 연쇄공격 : 전체 해시 값이 아니라 해시 중간의 결과에 대한 충돌쌍을 찾는다.</li>
              <li>고정점 연쇄공격 : 메시지 블록과 연쇄변수 쌍을 얻게 되면 임의의 수의 동등한 블록들 xi 를 메시지의 중간에 삽입해도 전체 해시값이 변하지 않는다.</li>
              <li>차분 연쇄공격
                <ul>
                  <li>다중 라운드 블록암호의 공격 = 다중 라운드 블록암호를 사용하는 해시 함수에서 입력값과 그에 대응하는 출력값 차이의 통계적 특성을 조사하는 기법</li>
                  <li>해시함수의 공격 : 압축함수의 입출력 차이를 조사하여 0의 충돌쌍을 주로 찾아내는 방법을 사용</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>일방향 해시함수로 해결할 수 없는 문제
        <ul>
          <li>조작과 변경을 검출할 수 있지만 거짓행세를 검출하지는 못함</li>
          <li>무결성 외에 인증이라는 절차도 필요 (파일의 무결성 뿐만 아니라 파일의 송신처 검증도 필요)
            <ul>
              <li>인증을 하기 위한 기술 : 메시지 인증코드와 전자서명과 같은 기술</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>암호학적 해시함수의 예
    <ul>
      <li>개요
        <ul>
          <li>압축함수의 두 가지 유형
            <ul>
              <li>기본 개념
                <ul>
                  <li>해시 함수를 설계하는 데에는 크게 서로 다른 2가지 경향이 있음.</li>
                  <li>압축함수를 아무런 기초 없이 처음부터 새로 만드는 것, 목적에 맞추어 특별하게 설계.</li>
                  <li>압축함수 자리에 대칭키 블록 암호를 사용하는 것.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>새로 만드는 해시함수
            <ul>
              <li>메시지 다이제스트 (Message Digest) (MD2 -&gt; MD4 -&gt; MD5)
                <ul>
                  <li>MD 알고리즘에는 MD2, MD4, MD5 세 가지가 있음. RSA를 개발한 MIT의 Rivest 교수가 공개키 기반 구조를 만들기 위해 RSA 와 함께 개발</li>
                  <li>1989년에 만들어진 MD2는 8비트 컴퓨터에 최적화, MD4(90년 개발), MD5(91년 개발) 은 32비트 컴퓨터에 최적화</li>
                  <li>MD5 는 MD4의 확장판으로, MD4 보다 속도는 빠르지 않지만 데이터 보안성이 더 좋음.</li>
                  <li>최종 버전인 MD5 : 메시지를 512비트로 된 블록들로 나누고, 128비트 다이제스트를 출력. 충돌 공격 내성을 갖기에는 길이가 짧음.</li>
                </ul>
              </li>
              <li>SHA (Secure Hash Algorithm)
                <ul>
                  <li>안전 해시 알고리즘(SHA), 최근에 널리 사용</li>
                  <li>NIST가 개발, 1993년에 FIPS PUB 180 으로 출판. SHA의 약점이 발견되었을 때 1995년 FIPS PUB 180-1로 나옴, 이를 SHA-1 이라고 함.</li>
                  <li>SHA 는 MD4 해시함수에 기초, 설계도 MD4 를 모델로 함. MD5 보다 느리지만 안전함. SHA-1 해시값으로 160비트를 출력.</li>
                  <li>2002년 NIST는 새 표준인 FIPS-180-2를 내놓음. 해시 값이 각각 256, 384와 512비트인 3개의 새로운 SHA 버전을 정의함. SHA-256, SHA-384, SHA-512. 이들 알고리즘을 SHA-2 라고 함.</li>
                  <li>새로운 버전은 SHA-1과 하부구조가 동일. 동일한 유형의 모듈러 연산과 논리적 2진 연산을 이용. 2008년 FIP PUB 180-3 에는 224-비트 버전이 추가.</li>
                  <li>2005년에 SHA-1의 강한 충돌 내성이 깨졌다는 것을 접수하고 SHA-3을 제정하기로 함. SHA-3 은 AES와 같은 방식으로 표준화</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>SHA-512
        <ul>
          <li>개요
            <ul>
              <li>기본개념
                <ul>
                  <li>SHA-2에 포함 (SHA-224, SHA-256, SHA-384, SHA-512)</li>
                  <li>SHA-512는 다중-블록 메시지로부터 512비트 다이제스트를 생성함. 각 블록은 1024비트 길이를 가짐.</li>
                </ul>
              </li>
              <li>길이 필드와 패딩
                <ul>
                  <li>메시지 다이제스트를 생성하기 전에 메시지에 추가적으로 덧붙이는 128비트의 부호 없는 정수 길이 필드가 필요. (512의 경우)
                    <ul>
                      <li>
                        <table>
                          <tbody>
                            <tr>
                              <td>Original MSG Field (&lt;2^128)</td>
                              <td>Padding Field (가변길이)</td>
                              <td>Length Field (Original MSG 길이필드 - Hash 값 수정에 대한 방어체계)</td>
                            </tr>
                          </tbody>
                        </table>
                      </li>
                    </ul>
                  </li>
                  <li>메시지의 길이가 비트수로 표현된 값이 저장됨. 이 길이는 패딩을 하기 전의 원래 메시지 길이를 나타냄.</li>
                  <li>부호 없는 128비트 정수 필드로 정의할 수 있는 수는 0부터 2^128-1 이다. 이 길이가 바로 SHA-512에서 감당할 수 있는 최대 메시지 길이.
                    <ul>
                      <li>2^128 비트 이하의 길이를 갖는 메시지를 1024비트의 블록으로 쪼갬.</li>
                      <li>IV 512 bit 와 블록을 Compression 함수를 이용해 512 bit 생성</li>
                      <li>위의 512bit 데이터를 다음 블록과 Compression 함수를 이용해 512 bit 생성…</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>메시지 인증코드(MAC)
        <ul>
          <li>MAC의 개요
            <ul>
              <li>기본개념
                <ul>
                  <li>메시지 인증을 위해 필요 (MAC, Message Authentication Code)</li>
                  <li>해시함수 기반, 블록암호 = 전자서명보다 속도가 빠름</li>
                  <li>무결성을 확인하고, 메시지에 대한 인증을 하는 기술 (변경과 거짓행세 검출 가능)</li>
                  <li>임의 길이의 메시지와 송신자 및 수신자가 공유하는 키라는 2개의 입력값을 기초로 해서 고정 비트길이의 출력을 계산하는 함수, 이 출력을 MAC 값이라고 부름.
                    <ul>
                      <li>Msg 와 키(송신자,수신자 공유)를 MAC 함수에 입력하여 MAC 값(고정길이 비트)을 추출</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>메시지 인증
                <ul>
                  <li>암호를 사용하면 소극적 공격(도청)을, 인증을 사용하면 적극적 공격(데이터나 거래의 위조)를 방어할 수 있음.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>변경 감지 코드 (MDC, Modification Detection Code)
            <ul>
              <li>메시지의 무결성을 보장하는 메시지 다이제스트</li>
              <li>Bob은 수신한 메시지로부터 새로운 MDC 를 생성하여 Alice 에게 받은 MDC 와 비교, 값이 동일하다면 해당 메시지는 변경되지 않음.</li>
              <li>키가 없는 해시함수를 사용</li>
            </ul>
          </li>
          <li>메시지 인증 코드 (MAC)
            <ul>
              <li>메시지의 무결성은 물론 Alice 가 메시지의 원 전송자이며 다른 사람이 Alice 인 척 하는 것이 아니라는 것을 말해주는 데이터 출원지 인증을 보장하기 위해, 변경 감지 코드를 메시지 인증코드(MAC) 로 바꿀 필요가 있음.</li>
              <li>MDC와 MAC의 차이는 MAC 에는 Alice 와 Bob 사이의 비밀값이 포함. Eve 는 가지고 있지 않은 비밀키가 두 사람 사이의 비밀 값이 될 수 있다.
                <ul>
                  <li>Eve 가 변조를 하더라도, 메시지와 키 값의 Hash 값인 MAC 값을 생성할 수 없음.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>MAC 의 키 배송 문제
            <ul>
              <li>MAC에서는 송신자와 수신자가 키를 공유할 필요가 있다.</li>
              <li>대칭키 암호 때의 키 배송 문제와 같은 문제가 메시지 인증코드에서도 일어남.</li>
            </ul>
          </li>
          <li>MAC의 구현 사례
            <ul>
              <li>축소 MAC
                <ul>
                  <li>MAC의 안정성을 높이기 위해 축소 MAC(nested MAC) 이 설계됨. 두 단계의 해싱이 있음</li>
                  <li>첫 번째 단계 : 키는 메시지와 이어 붙이고 해시하여 중간 단계의 다이제스트를 생성함.</li>
                  <li>두 번째 단계 : 키는 중간단계 다이제스트에 이어 붙이고 최종적인 다이제스트를 생성</li>
                </ul>
              </li>
              <li>HMAC
                <ul>
                  <li>축소 MAC 보다 더 복잡. 패딩 같은 추가적인 조치가 더 들어 있음.</li>
                  <li>HMAC 은 일방향 해시함수를 이용하여 메시지 인증코드를 구성하는 방법.</li>
                  <li>HMAC 의 H 는 Hash
                    <ul>
                      <li>블록길이
                        <ul>
                          <li>SHA-1 : 512</li>
                          <li>SHA-2 (SHA-224 : 512, SHA-256 : 512, SHA-384 : 1024, SHA-512 : 1024)</li>
                        </ul>
                      </li>
                      <li>MD 길이
                        <ul>
                          <li>SHA-1 : 160</li>
                          <li>SHA-2 (SHA-224 : 224, SHA-256 : 256, SHA-384 : 384, SHA-512 : 512)</li>
                        </ul>
                      </li>
                      <li>HMAC 과정
                        <ul>
                          <li>
                            <table>
                              <tbody>
                                <tr>
                                  <td>키값 : 키</td>
                                  <td>Key Padding (000..) 으로 블록길이만큼 늘임</td>
                                </tr>
                              </tbody>
                            </table>
                          </li>
                          <li>XOR 연산</li>
                          <li>I Pad : 00110110 00110110 00110110 … 으로 블록길이만큼 늘임</li>
                          <li>결과값 Si 와 메시지블록 M1, M2, … , Mn 을 결합하여 해시함수(H) 적용 (결과값 h)</li>
                          <li>위 키값과 O Pad : 01011100 01011100 01011100 … 으로 블록길이만큼 늘린 값을 XOR 연산</li>
                          <li>
                            <table>
                              <tbody>
                                <tr>
                                  <td>결과값 So 와 h 를 결합 (So</td>
                                  <td>h) 하여 해시함수(H) 적용, 최종 MAC 값 추출</td>
                                </tr>
                              </tbody>
                            </table>
                          </li>
                          <li>H : SHA-1, MD5 등등…</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>CMAC (Cipher-based Message Authentication Code)
                <ul>
                  <li>NIST 는 데이터 인증 알고리즘 혹은 CMAC 또는 CBCMAC 이라 부르는 표준 FIPS 113을 정의</li>
                  <li>대칭키 암호시스템에 대한 암호 블록체인 (CBC) 모드와 유사한 방법
                    <ul>
                      <li>그러나 N개의 평문 블록으로부터 N개의 암호문 블록을 만드는 것은 아님. (1개의 암호문 블록 생성)</li>
                    </ul>
                  </li>
                  <li>CMAC 이 CBCMAC 보다 안전 (수학적 보완)</li>
                  <li>과정
                    <ul>
                      <li>메시지 블록 M1, M2, …, Mn</li>
                      <li>M1 과 k (키값) 을 E (Encrypt) 한 결과 R1</li>
                      <li>M2 와 R1 을 Xor 연산 하여 k (키값) 을 E (Encrypt) …</li>
                      <li>Mn 와 Rn-1 와 새로 생성한 k (키값) 을 E (Encrypt) =&gt; CMAC</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>MAC 의 이용 예
            <ul>
              <li>IPSec (HMAC)
                <ul>
                  <li>인터넷 기반 통신프로토콜 IP(Internet Protocol) 에 보안기능을 추가한 것</li>
                  <li>통신 내용의 인증과 무결성을 확인하기 위해 MAC 을 이용</li>
                </ul>
              </li>
              <li>SSL/TLS (HMAC)
                <ul>
                  <li>웹에서 온라인 쇼핑을 할 때 사용되는 통신 프로토콜</li>
                  <li>통신 내용의 인증과 무결성 확인을 위해 메시지 인증코드를 이용</li>
                </ul>
              </li>
              <li>SET 프로토콜 (HMAC)</li>
            </ul>
          </li>
          <li>MAC 에 대한 공격
            <ul>
              <li>재전송 공격
                <ul>
                  <li>개요
                    <ul>
                      <li>적극적 공격자 멜로리는 자신이 보존해 둔 MAC 값을 반복해서 송신하는 공격을 감행.</li>
                      <li>이를 재전송 공격(replay attack) 이라고 부름
                        <ul>
                          <li>A 에서 B로 전송되는 Msg + MAC 을 Mellory 가 확보</li>
                          <li>Msg + MAC 을 재전송</li>
                        </ul>
                      </li>
                      <li>재전송 공격을 막을 수 있는 방법에는 아래 4가지가 있음.</li>
                    </ul>
                  </li>
                  <li>순서 번호 (sequence number)
                    <ul>
                      <li>송신 메시지에 매회 1회씩 증가하는 번호를 붙이기로 약속.</li>
                      <li>MAC 값의 계산에 순서번호도 메시지에 포함시키도록 함.</li>
                      <li>마지막 순서 번호를 기록해야 함.</li>
                    </ul>
                  </li>
                  <li>타임스탬프 (timestamp)
                    <ul>
                      <li>송신 메시지에 현재 시각을 넣기로 약속해두고 그 이전의 메시지가 왔을 경우에는 MAC 값이 바르더라도 오류라고 판단.</li>
                      <li>시계 동기화 필요</li>
                    </ul>
                  </li>
                  <li>비표 (nonce)
                    <ul>
                      <li>메시지를 수신하기에 앞서 수신자는 송신자에게 일회용의 랜덤한 값 (비표) 를 줌.</li>
                      <li>송신자는 비표를 포함해서 MAC 값을 계산, 비표의 값은 통신 때마다 바뀜.</li>
                      <li>통신 데이터 양이 약간 증가</li>
                    </ul>
                  </li>
                  <li>시도/응답 (challenge/response)
                    <ul>
                      <li>비표와 유사 개념</li>
                      <li>상대방에게 난수값을 보내면 상대방은 난수값을 포함한 응답값을 보내야 함.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>MAC으로 해결할 수 없는 문제
            <ul>
              <li>제 3자에 대한 증명
                <ul>
                  <li>MAC 은 공유키를 사용하기에 MAC 값을 계산할 수 있는 것은 Alice 와 Bob 이다.</li>
                  <li>두 사람이 서로 통신하고 있는 동안 그 MAC 값을 계산한 것은 상대방이라고 말할 수 있다.</li>
                  <li>하지만 제3자 Victor 에게 이 MAC 값을 계산한 것은 자신이 아닌 상대방이라고 증명할 방법은 없다.
                    <ul>
                      <li>전자서명을 사용하면 제3자에 대한 증명이 가능해짐</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>부인 방지
                <ul>
                  <li>송신자 Alice 는 Bob 에게 그러한 메시지를 보내지 않았다고 Victor 에게 주장할 수 있고 이를 부인이라고 한다.</li>
                  <li>MAC 에서는 Alice 와 Bob 중 어느 쪽 주장이 맞는지를 판단할 수 없다.
                    <ul>
                      <li>전자서명을 사용하면 부인방지가 가능함</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>메시지 인증
        <ul>
          <li>개요
            <ul>
              <li>기본 개념
                <ul>
                  <li>수신자가 받은 메시지가 송신자가 보낸 메시지와 동일한 것인지 확인하는 것</li>
                  <li>메시지 내용 변경, 순서 변경, 삭제 및 훼손 등 불법 행위에 대하여 확인하는 기술</li>
                  <li>관용 암호화 방식, 공개키 암호화 방식, 해시 함수, MAC 을 이용하는 방식 등</li>
                </ul>
              </li>
              <li>메시지 인증 방법
                <ul>
                  <li>관용(대칭키) 암호방식을 이용한 메시지 인증 방식
                    <ul>
                      <li>평문을 사전에 분배해서 갖고 있던 비밀키로 암호화하여 암호문을 수신자에게 전송하면 수신자는 암호문을 비밀키로 복호화하여 확인</li>
                      <li>이 때, 평문이 문장으로 되어 있으면 복호화 후 전송 중의 메시지 변경 여부를 확인할 수 있음</li>
                    </ul>
                  </li>
                  <li>공개키 암호화 방식을 이용한 메시지 인증 방식
                    <ul>
                      <li>송신자는 자신의 개인키로 평문을 암호화하여 암호문을 수신자에게 전송, 수신자는 송신자의 공개키로 암호문을 복호화하여 인증을 확인</li>
                      <li>누구나 메시지 인증을 검증할 수 있음. 개인키를 알고 있는 송신자만 인증을 생성할 수 있기 때문에 제 3자가 송신자를 가장하여 메시지를 전송할 수 없음.</li>
                    </ul>
                  </li>
                  <li>해시 함수를 이용한 메시지 인증 방식
                    <ul>
                      <li>메시지로부터 해시 함수 결과 값을 계산한 후 수신한 해시 값과 비교하여 메시지의 무결성을 검증하는 방식</li>
                      <li>해시 함수가 공개되어 있기 때문에 제 3자가 인증자인 것처럼 가장하여 임의의 메시지를 정당한 메시지인 것처럼 인증하면 수신자는 제 3자의 위조 인증임을 알 수 없음</li>
                      <li>비밀정보를 해시 함수에 추가하여 계산하여 단점을 해결. 송수신자는 사전에 비밀정보를 가지고 있다가 인증하려는 메시지와 비밀정보를 연계하여 해시 함수에 인증하고 계산한 값을 메시지에 덧붙여 전송함.</li>
                      <li>수신자는 사용자로부터 수신한 메시지와 자신이 보관하고 있는 비밀 정보로 해시함수를 계산한 후 수신한 해시 함수 결과 값과 비교하여 메시지 인증을 수행. 제3자는 비밀정보를 모름.</li>
                    </ul>
                  </li>
                  <li>MAC 을 이용한 메시지 인증 방식
                    <ul>
                      <li>MAC (Message Authentication Code) 은 관용 암호방식을 이용하여 간단한 무결성 검증 코드를 만들어 메시지에 부가시키는 방법</li>
                      <li>MAC 을 이용해 메시지 인증 및 무결성 검사를 수행하는 절차로는 우선 송신자가 인증할 메시지를 비밀키로 암호화시킨 MAC 값을 계산한 후 메시지와 함께 수신자에게 전송.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
:ET