I"3<h1 id="네트워크와-프로토콜">네트워크와 프로토콜</h1>
<ul>
  <li><strong>프로토콜</strong>
    <ul>
      <li>메시지의 포맷, 언제 데이터를 보낼 것인지, 한번 전송하고 한번 응답할지 등.</li>
      <li>OSI7 계층, TCP/IP 4계층</li>
      <li>다른 약속을 한 송 수신자 간 통신 : 게이트웨이 장비 필요</li>
    </ul>
  </li>
  <li>데이터 전송방식 (OSI7 -&gt; 세션계층)
    <ul>
      <li>단방향 (Simplex) : 키보드, 모니터</li>
      <li>반이중 (Half Duplex) : 송수신을 동시에 하는 것이 불가능</li>
      <li>전이중(Full Duplex) : 동시에 양방향 송수신</li>
    </ul>
  </li>
</ul>

<h1 id="네트워크-토폴로지">네트워크 토폴로지</h1>
<ul>
  <li>계층형
    <ul>
      <li>Tree 구조 / 최상위 노드가 네트워크 제어</li>
      <li>통제 및 유지보수 용이</li>
      <li>중앙 컴퓨터 장애 시 전체 통신망 영향</li>
    </ul>
  </li>
  <li>버스형
    <ul>
      <li>중앙 통신 회선 하나에 여러 대의 노드 연결</li>
      <li>하나의 컴퓨터가 다운되어도 나머지에 지장 없음</li>
      <li>우선순위 제어가 어렵고 충돌이 자주 발생</li>
    </ul>
  </li>
  <li>스타형
    <ul>
      <li>중앙 컴퓨터를 중심으로 터미널이 연결된 중앙집중형</li>
      <li>유지보수 및 관리가 용이</li>
      <li>중앙 컴퓨터 고장 시 네트워크 전체 마비</li>
    </ul>
  </li>
  <li>링형
    <ul>
      <li>인접해 있는 노드들을 연결하는 단방향 전송 형태</li>
      <li>단말기 추가 및 삭제가 어려움</li>
    </ul>
  </li>
  <li>망형
    <ul>
      <li>모든 노드들이 상호 연결</li>
      <li>가장 많은 통신 선로가 필요</li>
    </ul>
  </li>
</ul>

<h1 id="osi-7계층"><strong>OSI 7계층</strong></h1>

<h2 id="1-osi-7계층-구조">1. OSI 7계층 구조</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">OSI 7계층</th>
      <th style="text-align: left">주요 내용</th>
      <th style="text-align: left">주요 프로토콜(매체)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">7. Application(Gateway)</td>
      <td style="text-align: left"><ul><li>사용자 소프트웨어를 네트워크에 접근 가능하도록 함</li><li>사용자에게 최종 서비스를 제공</li></ul></td>
      <td style="text-align: left">FTP, SNMP, HTTP, Mail, Telnet 등</td>
    </tr>
    <tr>
      <td style="text-align: left">6. Presentation</td>
      <td style="text-align: left"><ul><li>포맷기능, 압축, 암호화</li><li>텍스트 및 그래픽 정보를 컴퓨터가 이해할 수 있는 16진수 데이터로 변환</li></ul></td>
      <td style="text-align: left"><ul><li>압축, 암호, 코드 변환</li><li>GIF, ASCII, EBCDIC</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">5. Session</td>
      <td style="text-align: left"><ul><li>세션 연결 및 동기화 수행, 통신 방식 결정</li><li>가상 연결을 제공하여 Login/Logout 수행</li></ul></td>
      <td style="text-align: left">반이중, 전이중, 완전이중 결정</td>
    </tr>
    <tr>
      <td style="text-align: left">4. Transport</td>
      <td style="text-align: left"><ul><li>가상연결, 에러 제어, Data 흐름 제어, Segment 단위</li><li>두 개의 종단 간 End-to-End 데이터 흐름이 가능하도록 논리적 주소 연결</li><li>신뢰도, 품질보증, 오류탐지 및 교정 기능 제공</li><li>다중화(Multiplexing) 발생</li></ul></td>
      <td style="text-align: left">TCP, UDP</td>
    </tr>
    <tr>
      <td style="text-align: left">3. Network(Router)</td>
      <td style="text-align: left"><ul><li>경로선택, 라우팅 수행, 논리적 주소 연결(IP)</li><li>데이터 흐름 조절, 주소 지정 메커니즘 구현</li><li>네트워크에서 노드에 전송되는 패킷 흐름을 통제하고, 상태 메시지가 네트워크 상에서 어떻게 노드로 전송되는가를 정의, Datagram(Packet) 단위</li></ul></td>
      <td style="text-align: left"><ul><li>IP, ICMP, IGMP, ARP, RAPR</li><li>라우팅 프로토콜(RIP, OSPF, BGP)</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">2. Data Link(Switch, Bridge)</td>
      <td style="text-align: left"><ul><li>물리주소 결정, 에러 제어, 흐름 제어, 데이터 전송</li><li>Frame 단위, 전송 오류를 처리하는 최초의 계층</li></ul></td>
      <td style="text-align: left"><ul><li>흐름 제어, 오류 제어(ARQ)</li><li>브릿지, PPTP, L2TP, HDLC</li><li>Frame Relay</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">1. Physical(Repeater)</td>
      <td style="text-align: left"><ul><li>전기적, 기계적 연결 정의, 실제 Data Bit 전송</li><li>Bit 단위, 전기적 신호, 전압구성, 케이블, 인터페이스 등을 구성</li><li>Data Rates, line noise control, 동기화 기능 수행</li></ul></td>
      <td style="text-align: left">매체: 동축케이블, 광섬유, Twisted Pair Cable</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 다중화(Multiplexing) : 여러 개의 소캣으로부터 데이터를 수집하여 헤더를 붙여 전송
- End-to-End : 7~4 계층, 송수신자 간의 에러 Control
- Point-to-Point : 3~1 계층, 각 구간에 대해 에러 Control
</code></pre></div></div>

<h2 id="2-osi-계층별-하드웨어-장비">2. OSI 계층별 하드웨어 장비</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">계층</th>
      <th style="text-align: left">장비명</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Physical</td>
      <td style="text-align: left">Cable</td>
      <td style="text-align: left">Twisted Pair Cable, Coaxial, Fiber-Optic Cable</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left">Repeater</td>
      <td style="text-align: left"><ul><li>네트워크 구간 케이블의 전기적 신호를 재생하고 증폭하는 장치</li><li>디지털 신호를 제공, 아날로그 신호 증폭 시 잡음과 왜곡까지 증폭</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">Data Link</td>
      <td style="text-align: left">Bridge</td>
      <td style="text-align: left"><ul><li>서로 다른 LAN Segment를 연결, 관리자에게 MAC 주소 기반 필터링 제공하여 더 나은 대역폭(Bandwidth) 사용과 트래픽을 통제</li><li>리피터와 같이 데이터 신호를 증폭하지만, MAC 기반에서 동작</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left">Switch</td>
      <td style="text-align: left"><ul><li>목적지의 MAC 주소를 알고 있는 지정된 포트로 데이터를 전송</li><li>Repeater 와 Bridge의 기능을 결합</li><li>네트워크의 속도 및 효율적 운영, Data Link 계층에서도 작동</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">Network</td>
      <td style="text-align: left">Router</td>
      <td style="text-align: left"><ul><li>패킷을 받아 경로를 설정하고 패킷을 전달</li><li>Bridge는 MAC 주소를 참조하지만, Router는 네트워크 주소까지 참조하여 경로를 설정</li><li>패킷 헤더 정보에서 IP 주소를 확인하여 목적지 네트워크로만 전달하며 Broadcasting을 차단</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">Application</td>
      <td style="text-align: left">Gateway</td>
      <td style="text-align: left"><ul><li>서로 다른 네트워크망과의 연결(PSTN, Internet, Wireless Network 등)</li><li>패킷 헤더의 주소 및 포트 외 거의 모든 정보를 참조</li></ul></td>
    </tr>
  </tbody>
</table>

<h1 id="tcpip-4계층">TCP/IP 4계층</h1>

<h2 id="1-tcpip-구조">1. <strong>TCP/IP 구조</strong></h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">OSI 7계층</th>
      <th style="text-align: left">TCP/IP 4계층</th>
      <th style="text-align: left">주요 기능</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><ul><li>Application</li><li>Presentaion</li><li>Session</li></ul></td>
      <td style="text-align: left">Application</td>
      <td style="text-align: left"><ul><li>네트워크를 실제로 사용하는 응용 프로그램으로 구성</li><li>FTP, TELNET, SMTP 등이 있음</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">Transport</td>
      <td style="text-align: left">Transport</td>
      <td style="text-align: left"><ul><li>도착하고자 하는 시스템까지 데이터를 전송</li><li>Port를 가지고 있으며, 프로세스를 연결 또는 비연결해서 통신함</li><li>TCP,UDP</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">Network</td>
      <td style="text-align: left">Internet</td>
      <td style="text-align: left"><ul><li>Datagram을 정의하고 Routing하는 일을 담당</li><li>IP, ARP, RARP, ICMP, IGMP</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left"><ul><li>Data Link</li><li>Physical</li></ul></td>
      <td style="text-align: left">Network Access</td>
      <td style="text-align: left">케이블, 송수신기, 링크 프로토콜, LAN 접속과 같은 물리적 연결 구성을 정의</td>
    </tr>
  </tbody>
</table>

<h2 id="2-tcpip-프로토콜의-구성--tcp-udp-ip-icmp-arp-rarp">2. TCP/IP 프로토콜의 구성 : TCP, UDP, IP, ICMP, ARP, RARP</h2>

<p><img src="/assets/images/posts/tcp_ip_protocols.png" alt="TCP IP Protocols" /></p>

<p><a href="http://www.tcpipguide.com/free/t_TCPIPProtocols.htm">이미지 출처</a></p>

<ul>
  <li>TCP : Connection Oriented Protocol (연결지향)로 사용자에게 신뢰성 있는 서비스를 지원. 신뢰성 있는 서비스를 지원하기 위해서 Error Control 기법을 포함하고 있으며, 송신자가 보낸 메시지를 수신자가 전송받았는지 확인하기 위해서 수신자를 ACK 를 송신자에게 전송. 만약 ACK가 오지 않거나 동일한 ACK 번호가 오면 다시 전송</li>
  <li>UDP : Connectionless Protocol(비연결)로 데이터 전송을 보장하지 않는 비신뢰성 서비스를 제공하지만, TCP에 비해서 전송 속도가 빠른 특징을 가진다.</li>
  <li>ARP : IP Address 를 LAN 카드의 물리적 주소인 MAC 주소로 변환한다.</li>
  <li>RARP : MAC 주소를 IP Address 로 변환하는 역할을 수행한다.</li>
  <li>ICMP : 네트워크 오류와 상태를 점검하기 위해서 사용된다.</li>
  <li>IP : 네트워크 주소와 호스트 주소 정의에 의한 네트워크의 논리적 관리를 담당하는 것으로 송신자와 수신자의 주소를 지정한다.</li>
</ul>

<h1 id="네트워크-활용tcpip-구조">네트워크 활용(TCP/IP 구조)</h1>

<h2 id="1-애플리케이션-계층">1. 애플리케이션 계층</h2>
<ul>
  <li>
    <p>일반 사용자들이 사용하는 프로그램이 있는 계층</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">서비스</th>
          <th style="text-align: left">내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">FTP</td>
          <td style="text-align: left"><ul><li>File Transfer Protocol</li><li>사용자 파일의 업로드 혹은 다운로드를 수행하는 프로그램</li><li>파일 전송을 위한 인터넷 표준으로 제어 접속과 데이터 접속을 위한 분리된 포트를 사용함</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">DNS</td>
          <td style="text-align: left"><ul><li>Domain Name Service</li><li>DNS Query를 사용해서 DNS Server에 URL을 전송하고 해당 URL에 매핑되는 IP 주소를 제공하는 서비스</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">HTTP</td>
          <td style="text-align: left"><ul><li>Hyper Text Transfer Protocol</li><li>웹브라우저와 웹 서버 사이에 웹 페이지의 Request 와 Response 를 수행하는 프로토콜</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">Telnet</td>
          <td style="text-align: left"><ul><li>특정 지역의 사용자가 지역적으로 다른 곳에 위치한 컴퓨터를 온라인으로 연결하여 사용하는 서비스</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">SMTP</td>
          <td style="text-align: left"><ul><li>Simple Mail Transfer Protocol</li><li>RFC 821에 명시된 인터넷 전자우편을 위한 프로토콜로 메시지 전달을 위해서 Store and Forward 방식을 사용</li><li>암호화 및 인증 기능 없이 사용자의 e-Mail을 전송하는 프로토콜</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">SNMP</td>
          <td style="text-align: left"><ul><li>Simple Network Management Protocol</li><li>네트워크에 대한 트래픽, 세션 등의 네트워크 상태를 모니터링하고 정보를 전달할 때 사용되는 프로토콜</li></ul></td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="1-httphyper-text-transfer-protocol">1. HTTP(Hyper Text Transfer Protocol)</h3>
<ul>
  <li>HTTP 프로토콜 개요
    <ul>
      <li>WWW(World Wide Web)로 시작되는 인터넷에서 웹 서버와 사용자의 인터넷 브라우저 사이에 문서를 전송하기 위해 사용되는 통신 프로토콜</li>
      <li>TCP 기반 프로토콜의 80번 Port 를 사용하고 Request 및 Response 구조를 가짐</li>
      <li>State-less 로 프로토콜을 구성함 (요청 / 응답 후 연결종료)</li>
    </ul>
  </li>
  <li>HTTP Version 1.0
    <ul>
      <li>연결을 수행할 때마다 3-Way handshaking 기법을 사용</li>
      <li>HTML 페이지를 수신 받고 완전히 연결을 종료시킴</li>
      <li>필요 시 다시 연결하고 페이지를 수신받음</li>
    </ul>
  </li>
  <li>HTTP Version 1.1
    <ul>
      <li>연결을 종료하지 않고 유지되는 Keep Alive Connection 을 지원</li>
      <li>연속된 연결 요청이 있을 경우 HTML 페이지를 수신받고 연결을 종료하지 않은 상태에서 이미지 등을 요청하는 형태의 서비스</li>
    </ul>
  </li>
  <li>HTTP Version 2.0
    <ul>
      <li>멀티플랙싱(Multiplexing), 헤더압축(Header Compression), 서버 푸시(Server Push) 등의 기술이 추가됨
        <ul>
          <li>멀티플랙싱 : 순차적 연결이 아니라 동시 다발적인 양방향 통신 지원</li>
          <li>헤더압축 : 헤더정보를 1/3 수준으로 압축, 보다 빠르게 메시지 처리</li>
          <li>서버푸시 : 웹 서버가 웹브라우저에게 필요한 데이터를 알아서 미리 전송할 수 있는 기술로 요청횟수와 전송해야 하는 데이터의 양을 줄임</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>HTTP 세션 연결 과정 (3-Way handshaking)</li>
</ul>

<p><img src="/assets/images/posts/tls_handshake.gif" alt="TLS Handshaking" /></p>

<p><a href="https://www.ibm.com/support/knowledgecenter/SSFKSJ_9.0.0/com.ibm.mq.sec.doc/q009930_.htm">이미지 출처</a></p>

<ul>
  <li>HTTP Request 시 Header 구조
    <ul>
      <li>HTTP Header 와 Body 의 구분은 <code class="language-plaintext highlighter-rouge">\r\n\r\n</code></li>
    </ul>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구조</th>
          <th style="text-align: left">설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">Request Method</td>
          <td style="text-align: left">호출되는 메소드로 GET 혹은 POST, OPTIONS, PUT, DELETE, TRACE, CONNECT 인지를 나타냄</td>
        </tr>
        <tr>
          <td style="text-align: left">Accept</td>
          <td style="text-align: left">웹 브라우저에서 사용 가능한 미디어 타입을 의미, text/*, text/html 등</td>
        </tr>
        <tr>
          <td style="text-align: left">Accept-Language</td>
          <td style="text-align: left">웹브라우저가 인식할 수 있는 언어를 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">User-Agent</td>
          <td style="text-align: left">웹브라우저 정보를 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Accept-Encoding</td>
          <td style="text-align: left">웹브라우저에서 제공되는 인코딩 방식을 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Host</td>
          <td style="text-align: left">웹 서버의 기본 URL을 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Connection</td>
          <td style="text-align: left">연결 지속 및 연결 끊기를 나타내며 Keep Alive 혹은 close</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>HTTP 요청 방식</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">요청 방식</th>
          <th style="text-align: left">내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">GET 방식</td>
          <td style="text-align: left"><ul><li>서버에 전달할 때 데이터를 URL에 포함시켜서 요청</li><li>전송할 수 있는 데이터 양이 제한됨(2Kbyte 또는 4Kbyte)</li><li>예) aa.php?userid=a&password=a</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">POST 방식</td>
          <td style="text-align: left"><ul><li>서버에 전달할 때 데이터를 Request Body에 포함시킴</li><li>데이터 전송량의 제한이 없음</li><li>예)aa.php<br/>userid=a;password=a</li></ul></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>HTTP Response 시 Header 구조</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구조</th>
          <th style="text-align: left">설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">Status Code</td>
          <td style="text-align: left">HTTP 응답 코드를 의미하고 200은 성공적으로 처리한 것을 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Server</td>
          <td style="text-align: left">서버 프로그램 이름과 버전 전송을 의미 예)<code class="language-plaintext highlighter-rouge">Apache/2.2.22 (Debian)\r\n</code></td>
        </tr>
        <tr>
          <td style="text-align: left">Expires</td>
          <td style="text-align: left">자원의 만기 일자를 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Cache Control</td>
          <td style="text-align: left">캐시 사용 여부를 나타내며 no-cache는 캐시를 사용하지 않음</td>
        </tr>
        <tr>
          <td style="text-align: left">Pragma</td>
          <td style="text-align: left">캐시 사용 여부를 나타냄. HTTP/1.0 에서 쓰이며 HTTP/1.1에서는 Cache-Control 이 쓰임</td>
        </tr>
        <tr>
          <td style="text-align: left">Content-Encoding</td>
          <td style="text-align: left">응답되는 메시지의 인코딩 방식을 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Content-Length</td>
          <td style="text-align: left">바이트 단위로 응답되는 리소스의 크기</td>
        </tr>
        <tr>
          <td style="text-align: left">Keep-Alive</td>
          <td style="text-align: left">연결 유지 시간을 의미하며 위의 예는 timeout 5초, 최대 100초로 설정되어 있음</td>
        </tr>
        <tr>
          <td style="text-align: left">Connection</td>
          <td style="text-align: left">Keep-Alive 사용 여부를 의미</td>
        </tr>
        <tr>
          <td style="text-align: left">Content-Type</td>
          <td style="text-align: left">응답되는 미디어 타입</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>Cookie 와 Session</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">방식</th>
          <th style="text-align: left">Cookie</th>
          <th style="text-align: left">Session</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">저장 위치</td>
          <td style="text-align: left">클라이언트</td>
          <td style="text-align: left">서버</td>
        </tr>
        <tr>
          <td style="text-align: left">저장 형태</td>
          <td style="text-align: left">Text 형식</td>
          <td style="text-align: left">Object 형식</td>
        </tr>
        <tr>
          <td style="text-align: left">종료 시점</td>
          <td style="text-align: left">쿠키 저장 시에 종료 시점을 설정하며, <br />설정하지 않으면 브라우저 종료 시점이 됨</td>
          <td style="text-align: left">정확한 시점을 알 수 없음</td>
        </tr>
        <tr>
          <td style="text-align: left">자원</td>
          <td style="text-align: left">클라이원트 자원</td>
          <td style="text-align: left">서버 자원</td>
        </tr>
        <tr>
          <td style="text-align: left">용량</td>
          <td style="text-align: left">한 도메인당 20개, 쿠키 하나에 4Kb, 총 300개</td>
          <td style="text-align: left">용량 제한 없음</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="2-smtp-simple-mail-transfer-protocol">2. SMTP (Simple Mail Transfer Protocol)</h3>

<p><img src="/assets/images/posts/how-does-email-work-mta-mua-msa-mda-smtp.svg" alt="SMTP" /></p>

<p><a href="https://afreshcloud.com/sysadmin/mail-terminology-mta-mua-msa-mda-smtp-dkim-spf-dmarc">이미지 출처</a></p>

<ul>
  <li>SMTP 개요
    <ul>
      <li>RFC 821에 명시되어 있는 인터넷 전자우편 표준 프로토콜</li>
      <li>Store-and-Forward 방식으로 메시지를 전달</li>
      <li>송신자 메일 -&gt; Store -&gt; Mbox -&gt; Forward -&gt; 수신자 메일</li>
      <li>TCP 25</li>
    </ul>
  </li>
  <li>SMTP 기본 동작 방식
    <ul>
      <li>송신자가 보낸 전자우편은 전자우편을 관리하는 메일서버에 전달됨</li>
      <li>메일 서버는 수신자의 전자우편 주소를 분석, 최단 경로를 찾아 근접한 메일 서버에게 편지를 전달</li>
      <li>최종 수신자 측 메일 서버에 도착하기까지 연속적으로 전달하는 중계 작업을 수행</li>
    </ul>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구성요소</th>
          <th style="text-align: left">내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">MTA(Mail Transfer Agent)</td>
          <td style="text-align: left">메일을 전송하는 서버</td>
        </tr>
        <tr>
          <td style="text-align: left">MDA(Mail Delivery Agent)</td>
          <td style="text-align: left">수신측에 고용된 우체부의 역할, MTA에게 받은 메일을 사용자에게 전달</td>
        </tr>
        <tr>
          <td style="text-align: left">MUA(Mail User Agent)</td>
          <td style="text-align: left">사용자들이 사용하는 클라이언트 애플리케이션</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>POP3와 IMAP 및 IMAP3</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">POP3</th>
          <th style="text-align: left">IMAP 및 IMAP3</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left"><ul><li>TCP 110번으로 메일서버에 접속하여 저장된 메일을 내려받는 MDA 프로그램</li><li>메시지를 읽은 후 메일 서버에서 해당 메일을 삭제함</li></ul></td>
          <td style="text-align: left"><ul><li>POP과 달리 메일을 내려받아도 메일 서버에 원본을 계속 저장</li><li>IMAP 143 Port</li></ul></td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="3-ftp-file-transfer-protocol">3. FTP (File Transfer Protocol)</h3>
<ul>
  <li>FTP 개요
    <ul>
      <li>인터넷 표준으로 파일 전송을 위한 프로토콜</li>
      <li>해당 컴퓨터에 등록된 사용자만 전송 가능, 그 외에는 익명(Anonymous)으로 사용</li>
      <li>ftpusers 에 등록된 사용자는 FTP 접근이 허용되지 않음</li>
      <li>제어 접속과 데이터 접속 포트가 분리되어 있음</li>
    </ul>
  </li>
  <li>FTP 전송모드
    <ul>
      <li>
        <p>Active Mode
  <img src="/assets/images/posts/ftp_active.png" alt="FTP Active" /></p>

        <p><a href="https://infosys.beckhoff.com/english.php?content=../content/1033/cx8190_hw/27021604587584011.html&amp;id=">이미지 출처</a></p>

        <ul>
          <li>서버 TCP/21번 포트로 접속 시도</li>
          <li>서버 TCP/20번 포트로 데이터를 송수신</li>
        </ul>
      </li>
      <li>
        <p>Passive Mode
  <img src="/assets/images/posts/ftp_passive.png" alt="FTP Passive" /></p>

        <p><a href="https://infosys.beckhoff.com/english.php?content=../content/1033/cx8190_hw/27021604587584011.html&amp;id=">이미지 출처</a></p>

        <ul>
          <li>서버 TCP/21번 포트로 접속한 후 두 번쨰 포트를 질의</li>
          <li>서버는 클라이언트에게 데이터 연결을 위한 두 번째 포트(TCP/1024이상)을 알려줌</li>
          <li>클라이언트는 서버가 알려준 두 번째 포트로 접속</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="4-snmp--와-nms">4. SNMP  와 NMS</h3>
<ul>
  <li>NMS (Network Management System) : 운영되는 네트워크의 안정성, 효율성을 높이기 위해서 구성,장애,통계,상태정보를 실시간 수집 및 분석하는 네트워크 관리시스템</li>
  <li>SNMP (Simple Network Management Protocol) : 이 떄 사용되는 프로토콜</li>
</ul>

<h2 id="2-전송-계층transport-layer">2. 전송 계층(Transport Layer)</h2>
<ul>
  <li>수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 연결 지향 서비스(Connection Oriented Service)의 역할을 하는 종단 간(End-to-End) 서비스 계층</li>
  <li>신뢰성 있는 전송을 하는 TCP / 비신뢰성 전송을 하는 UDP 프로토콜이 존재</li>
  <li>애플리케이션 계층의 메시지에 TCP 혹은 UDP의 Header 를 붙인 것을 Segment 라 함.</li>
</ul>

<h3 id="1-tcp-transmission-control-protocol">1. <strong>TCP</strong> (Transmission Control Protocol)</h3>
<ul>
  <li>전송 계층의 프로토콜</li>
  <li>연결지향(Connection Oriented)
    <ul>
      <li>가상 연결을 수행
        <ul>
          <li>실제 물리적으로 연결된 것이 아니어서 주기적으로 메시지(ICMP 프로토콜)를 송수신하여 송수신 가능 여부를 확인함.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3-Way Handshaking
    <ul>
      <li>SYN -&gt; SYN+ACK -&gt; ACK</li>
    </ul>
  </li>
  <li>신뢰성 있는 데이터 전송
    <ul>
      <li>송신자가 메시지를 전송하면 수신자는 ACK를 되돌려서 수신 여부를 확인해줌</li>
      <li>동일한 ACK 번호를 반복적으로 전송한다면 어떤 이유로든 데이터를 받지 못하는 것이고, 반복적인 ACK가 되돌아오면 TCP는 에러 제어기법을 통해 재전송을 수행함</li>
    </ul>
  </li>
  <li>순서 제어(Sequence Control)
    <ul>
      <li>Sequence 번호를 가지고 메시지의 순서를 파악
        <ul>
          <li>비동기 방식으로 데이터 전송 시 다른 경로로 보내질 수 있기 때문에 송신자의 메시지가 꼭 순서에 따라 도착하지 않음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>완전 이중(Full Duplex)
    <ul>
      <li>송신과 수신을 동시에 함</li>
    </ul>
  </li>
  <li>에러 제어
    <ul>
      <li>FEC(Forward Error Correction)
        <ul>
          <li>송신 측이 특정한 정보 비트를 함께 전송하여 수신측에서 이 정보 비트로 에러 발생 시 수정하는 방식 (수신측이 에러 처리)</li>
          <li>재전송 요구가 없음</li>
          <li>오류 검출 및 수정을 위한 잉여 비트 추가 -&gt; 전송 효율 감소</li>
          <li>해밍 코드, 상승 코드 등</li>
        </ul>
      </li>
      <li>BEC(Backward Error Correction)
        <ul>
          <li>수신 측이 에러 검출 후 송신측에게 에러가 발생한 데이터 블록을 다시 전송 요청</li>
          <li>패리티 검사, CRC 등 Checksum 을 이용해 오류 검출 후 오류 제어는 ARQ(Auto Repeat Request) 가 처리
            <ul>
              <li>Checksum 은 TCP, UDP 모두에 존재, 송신중에 메시지의 변조를 파악하기 위한 송/수신자 간 에러 체크 방법</li>
            </ul>
          </li>
          <li>BEC 기법 특징</li>
        </ul>

        <table>
          <thead>
            <tr>
              <th style="text-align: left">기법</th>
              <th style="text-align: left">Stop-and-Wait</th>
              <th style="text-align: left">Go-Back-N(TCP)</th>
              <th style="text-align: left">Selective Repeat</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">재전송 요청 방법</td>
              <td style="text-align: left">에러발생 즉시 재전송</td>
              <td style="text-align: left">오류 발생 또는 잃어버린 프레임 이후의 모든 프레임을 재요청하거나 타임아웃으로 자동 재송신 됨</td>
              <td style="text-align: left">오류 발생 또는 잃어버린 프레임에 대해서만 재요청 또는 타임아웃으로 인한 자동 재송신</td>
            </tr>
            <tr>
              <td style="text-align: left">수신 방법</td>
              <td style="text-align: left">순차적으로 수신</td>
              <td style="text-align: left">프레임의 송신 순서와 수신 순서가 동일해야 수신</td>
              <td style="text-align: left">순서와 상관없이 윈도우 크기만큼의 범위 내에서 자유롭게 수신</td>
            </tr>
            <tr>
              <td style="text-align: left">장단점</td>
              <td style="text-align: left"><ul><li>가장 단순한 구현</li><li>신뢰성 있는 전송</li><li>대기시간 존재로 전송 효율 저하</li></ul></td>
              <td style="text-align: left"><ul><li>간단한 구현</li><li>적은 수신측 버퍼 사용량</li></ul></td>
              <td style="text-align: left"><ul><li>구현이 복잡</li><li>버퍼 사용량이 많음</li><li>보다 적은 재전송</li><li>대역폭</li></ul></td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>흐름 제어 (Flow Control)
    <ul>
      <li>송수신측 사이의 전송 패킷의 양, 속도를 조절하여 네트워크를 효율적으로 사용</li>
      <li>수신자가 메시지를 제대로 받지 못하면 송신자가 전송 속도를 낮춤</li>
      <li>수신자의 Buffer Overflow 를 방지</li>
      <li>슬라이딩 윈도우(Sliding Window) (TCP)
        <ul>
          <li>TCP 호스트 간 효율적 데이터전송을 위해 송수신 할 수 있는 Size 정보를 제공, Size를 맞춤 / Ack 를 묶어서 처리</li>
          <li>Stop-and-Wait의 단점을 보완한 방식으로 수신측의 확인 신호를 받지 않더라도 미리 정해진 프레임의 수만큼 연속적으로 전송</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>혼잡제어 (Congestion Control)
    <ul>
      <li>Router 가 처리할 수 있는 packet 양보다 더 많은 packet 전송 시 비효율</li>
      <li>TCP Slow Start
        <ul>
          <li>TCP가 시작될 때 전송속도를 초기값부터 지속적으로 올리는 방법</li>
          <li>Receive Windows : 수신자의 윈도우 크기 (메모리 버퍼). 수신자의 버퍼 상태를 보고 전송속도를 조절</li>
          <li>Sender 에서 packet을 전송하는 비율과 Receiver 에서 수신된 ACK를 통해 congestion window(cwnd) 를 지수의 크기로 증가시키는 방법</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>TCP 상태전이
  <img src="/assets/images/posts/tcp_status_diagram.gif" alt="TCP Status Diagram" /></p>

    <p><a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.halu101/constatus.htm">이미지 출처</a></p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">netstat</code> 명령어로 TCP 상태 확인
        <ul>
          <li><code class="language-plaintext highlighter-rouge">netstat -b</code> : 어떤 프로세스가 네트워크를 사용하는지 확인</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>TCP 헤더 구조</p>

    <p><img src="/assets/images/posts/Ntwk_tcp_header.jpg" alt="TCP Header" /></p>

    <p><a href="https://commons.wikimedia.org/wiki/File:Ntwk_tcp_header.jpg">이미지 출처</a></p>
  </li>
</ul>

<h3 id="2-udp-user-datagram-protocol">2. UDP (User Datagram Protocol)</h3>
<ul>
  <li>비연결성, 비신뢰성의 특성으로 Packet을 빠르게 전달</li>
  <li>
    <p>송수신의 여부에 대한 책임을 Application이 가진다.</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">특징</th>
          <th style="text-align: left">내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">비신뢰성(Unreliable)</td>
          <td style="text-align: left">Packet을 목적지에 성공적으로 전송한다는 것을 보장하지 않음</td>
        </tr>
        <tr>
          <td style="text-align: left">비접속형(Connectionless)</td>
          <td style="text-align: left">전달되는 Packet에 대한 상태 정보를 유지하지 않음</td>
        </tr>
        <tr>
          <td style="text-align: left">간단한 Header 구조</td>
          <td style="text-align: left">TCP에 비해 헤더 구조가 간단하여 처리가 단순함 (TCP 세그먼트의 헤더 20byte, UDP 세그먼트의 헤더 8byte)</td>
        </tr>
        <tr>
          <td style="text-align: left">빠른 전송</td>
          <td style="text-align: left">TCP에 비해 전송속도가 빠름</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>UDP 프로토콜의 Header 구조</p>

    <p><img src="/assets/images/posts/UDP_header.png" alt="UDP Header" /></p>

    <p><a href="https://commons.wikimedia.org/wiki/File:UDP_header.png">이미지 출처</a></p>
    <ul>
      <li>가상 선로(Virtual Circuit)의 개념이 없는 비연결성</li>
      <li>블록 단위로 데이터 전송</li>
      <li>블록 재전송 및 흐름 제어 등이 없음 (데이터 신뢰성이 없음)</li>
      <li>슬라이딩 윈도우 등의 복잡한 기술을 사용하지 않음</li>
      <li>UDP의 각 사용자는 16bit의 포트 번호를 할당 받음</li>
    </ul>
  </li>
  <li>UDP 를 사용하는 VoIP(Voice Over IP)
    <ul>
      <li>빠르게 데이터를 전송해야 하는 서비스</li>
      <li>내부적으로 2개의 프로토콜을 사용
        <ul>
          <li>RTP(Real Time Protocol) - 음성을 전송</li>
          <li>RTCP(Real Time Control Protocol) - 에러처리</li>
        </ul>
      </li>
      <li>스니핑 노출로 인한 사생활 침해 취약점</li>
      <li>DDoS 보안 취약점</li>
    </ul>
  </li>
</ul>

<h2 id="3-인터넷-계층internet-layer">3. 인터넷 계층(Internet Layer)</h2>
<ul>
  <li>송신자의 IP 주소와 수신자의 IP 주소를 읽어 경로 결정, 전송하는 역할</li>
  <li>다중 네트워크 링크를 통해 패킷의 발신지 대 목적지 전달에 대한 책임을 가짐 (DataLink 층은 노드간 전달 책임) (Point to Point)</li>
  <li>인터넷 계층은 IP, ICMP 의 TCP/IP 프로토콜 군이 존재하고 멀티캐스팅을 위한 IGMP(Internet Group Management Protocol), 라우팅을 위한 BGP, OSPF, RIP 등이 존재</li>
  <li>
    <p>경로결정(Routing) 은 수신자의 IP 주소를 읽어서 어떻게 목적지까지 가는 것이 최적의 경로인지를 판단하는 것이며, 이러한 작업을 하는 것은 라우터(Router)라는 네트워크 장비이다.</p>
  </li>
  <li>기능
    <ul>
      <li>경로설정(Routing) : 경로를 결정</li>
      <li>Point to Point packet 전달</li>
      <li>논리 주소 지정 (Logical Addressing) : IP 주소로 변환해서 사용</li>
      <li>주소 변환 (Adress Transformation)</li>
      <li>데이터그램(Datagram) : 기존 패킷(Packet)에 IP Header 를 붙이는 것을 의미</li>
    </ul>
  </li>
</ul>

<h3 id="1-라우팅">1. 라우팅</h3>

<h4 id="1-개념">1. 개념</h4>
<ul>
  <li>정적 경로 (Static Routing)
    <ul>
      <li>관리자가 최적의 경로로 설정</li>
      <li>라우터의 직접적인 처리 부하 감소</li>
      <li>환경변화가 적은 형태의 네트워크에 적합</li>
      <li>Floating static routing</li>
    </ul>
  </li>
  <li>동적 경로 (Dynamic Routing)
    <ul>
      <li>네트워크 환경변화에 능동적인 대처가 가능</li>
      <li>라우터 간에 자동으로 정보를 교환, 경로 설정</li>
      <li>수시로 환경이 변화되는 형태의 네트워크에 적합</li>
      <li>Distance Vector routing, Linked state routing</li>
    </ul>
  </li>
  <li>라우팅 범위에 따른 라우팅 프로토콜 종류
    <ul>
      <li>IGP(Internal Gateway routing protocol) : 동일 그룹(기업 또는 ISP) 내에서 라우팅 정보를 교환</li>
      <li>EGP(Exterior Gateway routing protocol) : 다른 그룹과의 라우팅 정보를 교환</li>
    </ul>
  </li>
  <li>
    <p>라우팅 프로토콜 분류</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구분</th>
          <th style="text-align: left">Distance Vector</th>
          <th style="text-align: left">Link State</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">알고리즘</td>
          <td style="text-align: left">최단경로(Shorter Path)를 구하는 벨만 포드(Bellman-Ford) 알고리즘 기반</td>
          <td style="text-align: left">최소 신장 트리(Shortest Path Tree)를 구하는 다익스트라(Dijkstra) 알고리즘 기반</td>
        </tr>
        <tr>
          <td style="text-align: left">동작 원리</td>
          <td style="text-align: left">네트워크 변화 발생 시 해당 정보를 인접한 라우터에 정기적으로 전달 하고, 인접 라우터에서는 라우팅 테이블에 정보 갱신</td>
          <td style="text-align: left"><ul><li>라우터와 라우터를 연결하는 Link 상태에 따라 최적의 경로 설정</li><li>라우터가 Network 변화 감지 시 링크 상태변경 정보를 인접한 라우터에게 즉각 전달하고 이를 저장함</li></ul></td>
        </tr>
        <tr>
          <td style="text-align: left">라우팅 정보</td>
          <td style="text-align: left">모든 라우터까지의 거리 정보 보관</td>
          <td style="text-align: left">인접 라우터까지의 Link Cost 계산</td>
        </tr>
        <tr>
          <td style="text-align: left">정보전송 시점</td>
          <td style="text-align: left">일정주기(30초, 이웃 라우터와 공유)</td>
          <td style="text-align: left">변화 발생 시에만</td>
        </tr>
        <tr>
          <td style="text-align: left">대표 프로토콜</td>
          <td style="text-align: left">RIP, IGRP, EIGRP(내부 라우팅), BGP</td>
          <td style="text-align: left">OSPF(가장 많이 사용됨), IS-IS(소규모 N/W에서 사용)</td>
        </tr>
        <tr>
          <td style="text-align: left">단점</td>
          <td style="text-align: left"><ul><li>변화되는 라우팅 정보를 모든 라우터에 주기적으로 갱신하므로 망 자체의 트래픽을 유발</li><li>라우팅 정보를 변경하는 문제 발생 시 Routing Loop가 발생할 가능성이 있음</li></ul></td>
          <td style="text-align: left"><ul><li>네트워크 전체 정보 유지를 위한 많은 메모리 소요</li><li>라우터의 CPU 사용량이 많아짐</li><li>라우터간 회선의 대역차이로 동기화 실패할 가능성이 있음</li></ul></td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>Distance Vector
        <ul>
          <li>통과해야 하는 라우터의 수가 적은 쪽으로 경로를 결정</li>
          <li>홉 카운터(Hop count) / TTL (Time to Live)</li>
          <li>RIP, IGRP</li>
        </ul>
      </li>
      <li>Link State
        <ul>
          <li>네트워크 대역폭, 지연 정보 등을 종합적으로 고려해 Cost 산정</li>
          <li>주기적으로 지연과 같은 정보를 라우터 간에 공유해야 하고 라우터 브로드캐스트를 통해서 공유함</li>
          <li>OSPF, EIGRP(애매함)</li>
        </ul>
      </li>
      <li>Path Vector
        <ul>
          <li>Distance Vector 와 Link State 의 Hybrid 형태</li>
          <li>Hop count 및 Bandwidth, Delay 등의 다양한 정보로 경로를 설정</li>
          <li>정책기반으로 라우팅 정보 업데이트</li>
          <li>BGP</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>스패닝 트리(Spanning Tree)
    <ul>
      <li>스위치나 브리지에서 발생하는 루핑을 막는 프로토콜</li>
      <li>출발지부터 목적지까지의 경로가 두 개 이상 있는 경우 한 개의 경로만 남겨두고 나머지 경로는 끊어서 루핑을 방지</li>
    </ul>
  </li>
</ul>

<h4 id="2-rip-routing-information-protocol">2. RIP (Routing Information Protocol)</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: left">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">개념</td>
      <td style="text-align: left">RFC 1058에 정의되어 있고 대표적인 거리 벡터 라우팅 프로토콜</td>
    </tr>
    <tr>
      <td style="text-align: left">동작 원리</td>
      <td style="text-align: left"><ul><li>라우터 간 거리 계산을 위한 척도로 홉수(Hop count) 사용</li><li>16Hop 이상이면 패킷을 폐기</li><li>180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주</li><li>수신된 목적지의 거리 값과 현재 거리 값을 비교하여 작을 것을 기준으로 라우팅 테이블을 변경</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">라우팅 정보</td>
      <td style="text-align: left">라우팅 정보 변경 시 모든 망에 적용하므로 큰 규모의 망에는 적합하지 않음</td>
    </tr>
  </tbody>
</table>

<h4 id="3-ospf-open-shortest-path-first">3. OSPF (Open Shortest Path First)</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: left">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">개념 및 특징</td>
      <td style="text-align: left"><ul><li>RFC 1247에 정의되어 있는 IP 라우팅 프로토콜</li><li>대규모 IP 망에서 사용되며 Link State Routing Protocol</li><li>링크에서의 전송 시간을 링크 비용으로 사용하여 각 목적지별 최단경로를 구함</li><li>네트워크에 변화가 발생했을 때 상대적으로 짧고 간단한 링크 상태 정보를 교환</li></ul></td>
    </tr>
    <tr>
      <td style="text-align: left">동작 원리</td>
      <td style="text-align: left"><ul><li>Link의 delay, throughput, reliability 를 이용하여 기본적은 throughput 만 이용하고, Hop 수에 대한 제약이 없음</li><li>네트워크를 Area로 구분하여 많은 라우팅 정보의 교환으로 인한 라우터의 성능저하를 예방. 대역폭을 절약함</li><li>Link 변화 감지 시 해당 Link에 대한 정보만을 즉시 모든 라우터에 전달하여 Convergence가 매우 빠름</li><li>Supernetting 된 형태로 Routing Information 을 전달할 수 있어 라우터 메모리 절약, 상능 향상 및 대역폭 절약 가능</li></ul></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>OSPF의 동작 원리 구성도의 예
  <img src="/assets/images/posts/ospf.gif" alt="OSPF" /></p>

    <p><a href="https://wiki.mikrotik.com/wiki/Testwiki/IP_routing">이미지 출처</a></p>
    <ul>
      <li>ABR (Area Border Router, 영역 경계 라우터) : Area에 백본망을 연결해주는 라우터</li>
      <li>ASBR (Autonomous System Boundary Router, 자율 시스템 경계 라우터) : 다른 AS(Autonomous System)에 속한 라우터와 경로정보 교환</li>
      <li>IR (Internal Router, 내부 라우터) : Area에 접속한 라우터</li>
      <li>BR (Backbone Router, 백본 라우터) : 백본망에 접속한 모든 라우터</li>
    </ul>
  </li>
</ul>

<h4 id="4-bgp-border-gateway-protocol">4. BGP (Border Gateway Protocol)</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: left">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">개념</td>
      <td style="text-align: left">AS(Autonomous System) 상호 간의 routing 에 적용되는 routing protocol 로 ISP(Internet Service Provider) 사업자들 상호 간에 주로 사용되는 routing protocol</td>
    </tr>
    <tr>
      <td style="text-align: left">특징</td>
      <td style="text-align: left"><ul><li>EGP라고 하는 Inter-domain routing protocol</li><li>인터넷을 AS 상호 간 연결 Path로 이뤄진 방향성 그래프의 집단으로 인식 : 경로 벡터 라우팅(path vector routing) 방법을 적용하며, 경로 벡터 라우팅 테이블을 유지</li><li>Looping free routing</li><li>TCP 기반 routing : BGP 라우팅 정보는 router 간에 179번 포트를 통하여 TCP에 의해 신뢰성 있게 전달</li><li>Routing 정보의 점진적 갱신 : BGP 는 주기적으로 라우팅 정보를 갱신하지 않고, 변화가 있을 때 neighbor router에게 갱신 정보를 advertising 함</li><li>다양한 routing metric 사용 : 최상위 경로 선택을 위해 우선순위가 있는 각 metric을 참조</li><li>Class 없는 주소체계 지원 : CIDR(Classless Inter-Domain Routing) 지원</li><li>IBGP(Internal BGP) : 동일한 AS에 속한 BGP 라우터 간의 동작</li><li>EBGP(External BGP) : 서로 다른 AS에서 동작하는 BGP 프로토콜</li></ul></td>
    </tr>
  </tbody>
</table>

<h3 id="2-ipinternet-protocol">2. <strong>IP(Internet Protocol)</strong></h3>

<h4 id="1개념">1.개념</h4>
<ul>
  <li>TCP/IP 의 네트워크 계층(IP계층) 은 주소화, 데이터그램 포맷, 패킷 핸들링 등을 정의해놓은 인터넷 규약이다.</li>
  <li>IPv4 : 32비트 주소체계를 사용하고 있고 이러한 주소체계는 네트워크 ID와 호스트 ID로 구분된다.</li>
  <li>IPv6 : IP 주소의 부족 문제를 해결하기 위해서 주소 비트 수를 128비트로 늘린 것</li>
  <li>
    <p>네트워크 계층 구조
  <img src="/assets/images/posts/IPv4_Packet_-en.svg.png" alt="IPv4 Packet" /></p>

    <p><a href="https://en.wikipedia.org/wiki/IPv4">이미지 출처</a></p>
  </li>
  <li>IP Header 구조
    <ul>
      <li>Version : IPv4 버전</li>
      <li>Header Length : Header의 전체 길이</li>
      <li>Type of Service : 서비스 유형</li>
      <li>Total Length : IP Datagram의 byte 수</li>
      <li>Identification : Host에서 보낸 Datagram 식별</li>
      <li>Flags &amp; Offset : IP Datagram 단편화 정보
        <ul>
          <li>MTU(Maximum Transmission Unit) : 네트워크 상 한 번에 통과할 수 있는 패킷의 최대 크기</li>
          <li>패킷의 크기가 너무 크면  (MTU 보다 크면) 분할되고, 패킷이 분할된 경우 패킷 수신자가 다시 조립을 해야 하는데 이와 관계된 정보</li>
        </ul>
      </li>
      <li>Time to Live : Datagram이 통과할 수 있는 라우터 수
        <ul>
          <li>0이 되면 자동 폐기</li>
        </ul>
      </li>
      <li>Protocol : ICMP, TCP, UDP
        <ul>
          <li>IP Header 위의 상위 프로토콜의 종류</li>
        </ul>
      </li>
      <li>Header Checksum : IP Header Checksum 계산
        <ul>
          <li>Header 의 무결성을 검사하기 위함</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>IP 주소의 구조
    <ul>
      <li>클래스(Class)
        <ul>
          <li>클래스의구조 / 네트워크ID / 호스트ID</li>
          <li>네트워크 ID : 네트워크에 부여될 수 있는 것</li>
          <li>호스트 ID : 하나의 네트워크에 부여될 수 있는 호스트 IP 주소 자릿수</li>
        </ul>
      </li>
      <li>
        <p>클래스(Class) 구조</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: left">Class</th>
              <th style="text-align: left">Message</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">Class A</td>
              <td style="text-align: left"><ul><li>첫 바이트 7Bit가 네트워크 식별자</li><li>한 네트워크에 가장 많은 호스트를 가짐</li></ul></td>
            </tr>
            <tr>
              <td style="text-align: left">Class B</td>
              <td style="text-align: left"><ul><li>14Bit의 네트워크 식별자</li><li>한 네트워크에 약 2^16대의 호스트 수용</li></ul></td>
            </tr>
            <tr>
              <td style="text-align: left">Class C</td>
              <td style="text-align: left"><ul><li>세 번째 바이트까지 네트워크 식별자</li><li>한 네트워크에 254대까지 수용</li></ul></td>
            </tr>
            <tr>
              <td style="text-align: left">Class D</td>
              <td style="text-align: left">멀티캐스트 주소로 사용</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>서브넷팅(Subnetting)
        <ul>
          <li>주어진 네트워크 주소를 작게 나누어 여러 개의 서브넷(논리적)으로 구성</li>
          <li>네트워크 식별자 부분을 구분하기 위한 mask를 서브넷 마스크(Subnet Mask)라고 함</li>
          <li>예) 1.0.0.1 / 24 : 서브넷마스크를 2진수 표현 시 1의 개수(CIDR 표기법)</li>
          <li>
            <p>예) 255.255.255.192/26 : 4개의 네트워크, 네트워크당 IP 64개</p>

            <table>
              <thead>
                <tr>
                  <th style="text-align: center">클래스 종류</th>
                  <th style="text-align: center">네트워크 ID</th>
                  <th style="text-align: center"> </th>
                  <th style="text-align: center"> </th>
                  <th style="text-align: center">호스트 ID</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="text-align: center">일반적인 Class C</td>
                  <td style="text-align: center">11111111</td>
                  <td style="text-align: center">11111111</td>
                  <td style="text-align: center">11111111</td>
                  <td style="text-align: center">00000000</td>
                </tr>
                <tr>
                  <td style="text-align: center">subnet mask</td>
                  <td style="text-align: center">255</td>
                  <td style="text-align: center">255</td>
                  <td style="text-align: center">255</td>
                  <td style="text-align: center">0</td>
                </tr>
                <tr>
                  <td style="text-align: center">2비트를 사용하여 서브넷팅</td>
                  <td style="text-align: center">11111111</td>
                  <td style="text-align: center">11111111</td>
                  <td style="text-align: center">11111111</td>
                  <td style="text-align: center">11000000</td>
                </tr>
                <tr>
                  <td style="text-align: center">subnet mask</td>
                  <td style="text-align: center">255</td>
                  <td style="text-align: center">255</td>
                  <td style="text-align: center">255</td>
                  <td style="text-align: center">192</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li>수퍼넷팅(Supernetting) : ISP 사업자가 많은 네트워크 망을 관리하기 위해 묶은 것</li>
      <li>VLSM(Variable Length Subnet Mask) :서로 다른 크기의 Subnet을 지원, 필요한 호스트의 수가 많은 Subnet을 먼저 계산</li>
      <li>CIDR : IP 주소와 서브넷 마스크를 이진 표기법으로 표현하여 기존의 고정크기 네트워크를 다양하고 세부적으로 분할. 기존 클래스 A,B,C 네트워크 주소의 개념을 무시 (IPv4 주소 공간의 효율적 할당)</li>
    </ul>
  </li>
</ul>

<h4 id="2-icmp-internet-control-message-protocol">2. <strong>ICMP (Internet Control Message Protocol)</strong></h4>
<ul>
  <li>TCP/IP 에서 오류 제어 프로토콜</li>
  <li>호스트 및 라우터는 다른 호스트나 라우터가 현재 도달 가능한지 여부를 결정함</li>
  <li>라우터는 특정 목적지 네트워크로 후속 IP 데이터그램을 보냈는데, 사용할 수 있는 더 좋은 경로가 있을 때 근원지 호스트에게 통지함.</li>
  <li>호스트나 라우터는 그들이 처리하기에 너무 빠른 IP 데이터그램이 도착하면 다른 시스템에게 통보함.</li>
  <li>ICMP 주요 기능
    <ul>
      <li>오류 보고 메시지 : IP 패킷 처리 도중 발견된 문제를 보고</li>
      <li>질의 메시지 : 다른 호스트로부터 특정 정보를 획득하기 위해 사용</li>
    </ul>
  </li>
  <li>ICMP 메시지 구조
    <ul>
      <li>Type : ICMP 메시지 유형 표시</li>
      <li>Code : Type과 같이 사용되며 세부적인 유형을 표현</li>
      <li>Checksum : IP Datagram Checksum</li>
    </ul>
  </li>
  <li>
    <p>ICMP 메시지</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">Type</th>
          <th style="text-align: left">Message</th>
          <th style="text-align: left">설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">3</td>
          <td style="text-align: left">Destination unreachable</td>
          <td style="text-align: left">Router가 목적지를 찾지 못할 경우 보내는 메시지</td>
        </tr>
        <tr>
          <td style="text-align: center">4</td>
          <td style="text-align: left">Source quench</td>
          <td style="text-align: left">패킷을 너무 빨리 보내 Network에 무리를 주는 호스트를 제지할 떄 사용</td>
        </tr>
        <tr>
          <td style="text-align: center">5</td>
          <td style="text-align: left">Redirection</td>
          <td style="text-align: left">패킷 Routing 경로를 수정, Smurf 공격에서 사용</td>
        </tr>
        <tr>
          <td style="text-align: center">8 or 0</td>
          <td style="text-align: left">Echo request or reply</td>
          <td style="text-align: left">Host의 존재를 확인</td>
        </tr>
        <tr>
          <td style="text-align: center">11</td>
          <td style="text-align: left">Time exceeded</td>
          <td style="text-align: left">패킷을 보냈으나 시간이 경과하여 Packet이 삭제되었을 때 보내는 메시지</td>
        </tr>
        <tr>
          <td style="text-align: center">12</td>
          <td style="text-align: left">Parameter problem</td>
          <td style="text-align: left">IP Header field에 잘못된 정보가 있다는 것을 알림</td>
        </tr>
        <tr>
          <td style="text-align: center">13 or 14</td>
          <td style="text-align: left">Timestamp request and reply</td>
          <td style="text-align: left">Echo와 비슷하나 시간에 대한 정보 추가</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ping 명령어 실행
    <ul>
      <li>윈도우 기본 TTL : 128</li>
      <li>리눅스 기본 TTL : 64</li>
    </ul>
  </li>
</ul>

<h4 id="3-데이터-전송-방식과-멀티캐스트">3. 데이터 전송 방식과 멀티캐스트</h4>

<ul>
  <li>
    <p>데이터 전송방식</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">전송방식</th>
          <th style="text-align: left">내용</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">Unicast</td>
          <td style="text-align: left">1:1 전송 방식</td>
        </tr>
        <tr>
          <td style="text-align: left">Broadcast (IPv4)</td>
          <td style="text-align: left">1:N 전송방식 (동일한 서브넷 상의 모든 수신자에게 전송)</td>
        </tr>
        <tr>
          <td style="text-align: left">Multicast</td>
          <td style="text-align: left">M:N 전송방식 (하나 이상의 송신자들이 특정 그룹의 수신자에게 전송)</td>
        </tr>
        <tr>
          <td style="text-align: left">Anycast (IPv6)</td>
          <td style="text-align: left">그룹에 등록된 노드 중에서 최단 경로 노드 한개에만 전송</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="4-멀티캐스트와-igmp-internet-group-management-protocol">4. 멀티캐스트와 IGMP (Internet Group Management Protocol)</h4>
<ul>
  <li>멀티캐스트는 그룹에 등록된 사용자에게만 데이터를 전송하는 것</li>
  <li>IGMP 는 그룹에 등록된 사용자를 관리하는 프로토콜</li>
  <li>
    <p>IGMP 메시지 구조</p>

    <table>
      <tr><td>14bytes</td><td>20bytes</td><td colspan="4">8bytes</td></tr>
      <tr><td>이더넷 헤더</td><td>IP 헤더</td><td colspan="4">IGMP 메시지</td></tr>
      <tr><td colspan="2"></td><td>Version(=0)</td><td>Type(=1-2)</td><td>(unused)</td><td>Checksum</td></tr>
      <tr><td colspan="2"></td><td colspan="4">32bit 클래스 D 주소</td></tr>
  </table>

    <ul>
      <li>8Byte 구성</li>
      <li>Version : IGMP 프로토콜의 버전 표시, 현재 IGMP Version 2</li>
      <li>Type : 메시지 유형, 1 = 보고, 2 = 질의메시지</li>
      <li>Group id
        <ul>
          <li>보고 메시지 : 호스트에서 신규 가입하고자 하는 멀티캐스트 서비스 group id / 계속 받아보기를 원하는 멀티캐스트 서비스의 group id</li>
          <li>질의 메시지 : 0</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="5-arp-address-resolution-protocol">5. ARP (Address Resolution Protocol)</h4>
<ul>
  <li>IP 주소를 물리적 하드웨어 주소인 MAC 주소로 변경하는 프로토콜</li>
  <li>ARP Request를 보내고 인접에 있는 컴퓨터가 ARP Reply 로 응답한 것을 통해서 ARP Cache Table을 유지한 후 인접 컴퓨터의 IP 주소와 MAC 주소를 가지고 있게 됨</li>
  <li>ARP Cache Table : MAC 주소와 IP 주소 매핑 테이블</li>
  <li>ARP Operation Code (1-9)
    <ul>
      <li>1 : ARP Request</li>
      <li>2 : ARP Reply</li>
      <li>3 : RARP Request</li>
      <li>4 : RARP Reply</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">arp</code> : 리눅스에서 ARP Cache Table 확인</li>
  <li><code class="language-plaintext highlighter-rouge">arp -a</code> : 윈도우에서 ARP Cache Table 확인</li>
</ul>

<h4 id="6-rarp-reverse-address-resolution-protocol">6. RARP (Reverse Address Resolution Protocol)</h4>
<ul>
  <li>물리적인 주소 MAC을 기반으로 논리적인 주소 IP를 알아오는 프로토콜</li>
  <li>하나의 호스트를 RARP 서버로 지정</li>
  <li>디스크 없는 워크스테이션은 RARP Request 패킷을 전송 (브로드캐스트)</li>
  <li>RARP 서버는 인터넷 주소를 RARP Response 패킷으로 응답 (유니캐스트)</li>
</ul>

<h2 id="3-네트워크-접근network-access-계층">3. 네트워크 접근(Network Access) 계층</h2>

<h3 id="1-네트워크-접근network-access-계층">1. 네트워크 접근(Network Access) 계층</h3>
<ul>
  <li>논리적 주소인 IP 주소를 물리적 MAC 주소로 변환</li>
  <li>Physical Layer 가 이해할 수 있는 헤더를 붙여주는 Layer</li>
  <li>Frame 단위, Mac Adress를 사용하는 계층</li>
  <li>통신기기 사이의 연결, 데이터 전송 기능</li>
  <li>에러제어, 흐름 제어</li>
  <li>OSI 7 계층의 데이터 링크 및 물리 계층에 해당</li>
</ul>

<h3 id="2-네트워크-접근-주요-기능">2. 네트워크 접근 주요 기능</h3>
<ul>
  <li>Point-to-Point 간 신뢰성 있는 전송으로 흐름 제어(Flow Control) 담당</li>
  <li>에러 제어(Error Control) : Error Detection(에러검출), Error Correction(에러정정)</li>
  <li>MAC(Media Access Control) : Lan 카드의 물리적 주소</li>
  <li>Frame 으로 변환</li>
</ul>

<h3 id="3-csmacd-carrier-sense-multiple-accesscollision-detection">3. CSMA/CD (Carrier Sense Multiple Access/Collision Detection)</h3>
<ul>
  <li>유선 LAN(Local Area Network) 에서 메시지를 송수신하기 위한 접근 방법</li>
  <li>충돌이 발생하지 않는 경우
    <ul>
      <li>전송을 원하는 호스트는 네트워크에 캐리어를 감지해 전송이 가능한지 검사 (데이터 프레임 전송)</li>
      <li>발생한 프레임은 네트워크 내에서 Broadcast 됨</li>
      <li>다른 호스트는 목적지 IP 주소가 자기가 아니라는 것을 알면 프레임을 바로 폐기</li>
      <li>목적지 호스트는 전송 호스트에게 Unicast 로 응답 (Shared Device Hub 네트워크에서는 유니캐스트와 브로드캐스트의 차이가 없음)</li>
    </ul>
  </li>
  <li>충돌이 발생한 경우
    <ul>
      <li>각각의 호스트에서 발생한 프레임이 공유 매체에서 Collision을 발생시킴</li>
      <li>Collision 이 발생되면 Jam Signal을 모든 호스트로 전송</li>
      <li>JamSignal을 받은 호스트들은 일정 시간 후에 다시 전송을 시작 (Back off 알고리즘을 이용하여 재전송)</li>
      <li>리피터와 허브를 이용하면 Collision이 발생하지만, Switch 는 Collision을 막을 수 있음.</li>
      <li>Switch는 브로드캐스트를 막을 수 없고, Router 가 브로드캐스트를 막을 수 있음.</li>
    </ul>
  </li>
</ul>

<h3 id="4-csmaca-carrier-sense-multiple-accesscollision-avoidance">4. CSMA/CA (Carrier Sense Multiple Access/Collision Avoidance)</h3>
<ul>
  <li>무선 LAN(Local Area Network) 에서 메시지를 송수신하기 위한 접근 방법</li>
  <li>프레임 전송 이전에 제어 메시지를 이용하여 수신자로부터 간단한 전송을 유발</li>
  <li>제어 신호에 대한 응답이 도착하면 프레임을 전송</li>
</ul>

<h3 id="5-lan-switch">5. LAN Switch</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">LAN Swtich 방식</th>
      <th style="text-align: left">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Cut through</td>
      <td style="text-align: left">목적지의 MAC Address만 확인 후 해당 포트로 전송</td>
    </tr>
    <tr>
      <td style="text-align: left">Store and Forward</td>
      <td style="text-align: left">전채 Frame을 모두 저장하여 Error Check를 수행 후 전송</td>
    </tr>
    <tr>
      <td style="text-align: left">Fragment Free</td>
      <td style="text-align: left"><ul><li>Modify Cut Through</li><li>Frame의 64 Bit를 검사, Header의 Error를 검사 후 전송</li><li>512Bit가 수신 될 때까지 대기 후 에러가 존재하지 않으면 전송하는 방식</li></ul></td>
    </tr>
  </tbody>
</table>
:ET