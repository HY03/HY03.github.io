---
title: 01.시스템보안 - 01.운영체제 이해 및 관리
date: '2020-10-23 13:00:00'
tags:
- 정보보안기사
- 시스템 보안
- 운영체제
related: true
categories:
- IS_Certification
toc: true
---

# 운영체제 개요
* 운영체제의 정의 : 컴퓨터 시스템의 자원을 효율적으로 관리, 사용자가 컴퓨터를 효과적으로 사용할수 있도록 환경을 제공하는 여러 프로그램의 모임

* 운영체제의 목적
    - 처리 능력의 향상 : 시간당 작업 처리량(Throughput), 평균 처리시간 개선
    - 신뢰성 향상 : 실패 없이 주어진 기능을 수행할 수 있는 능력
    - 응답시간의 단축 : 사용자가 시스템에 의뢰한 작업의 반응 시간 단축
    - 자원 활용률 향상 : 자원의 공유, 상호배제를 통해 자원 효율적 활용
    - 가용성 향상 : 고장과 오류가 발생해도 운영 영향 최소화

# 운영체제 종류

## 1. 종류
- **Batch** : 순차적, 한꺼번에 처리
- **Multi Programming** : N개 프로그램 기동, CPU 가동률 극대화, 유휴 시간 최소화, 스케줄링 필요
- **Time Sharing** : 시간을 분할하여 CPU 사용
- **Multi Process** : 다중 CPU
- **Real Time System** : 실시간 처리
- **Multi-Mode** : 다중 운영체제 (일괄처리, 시분할, 다중처리, 실시간 처리)
- **Distributed System** : 네트워크로 분산된 운영체제

## 2. 프로세스와 스레드
* 프로세스(Process)
    - 레지스터, 스택, 포인터, 실행중인 프로그램, 데이터 등의 집합체이다.
    - 실행중인 프로세스(가장 보편적인 정의)이다.
    - 프로세서에 의해 수행되는 프로그램 단위로 현재 실행 중이거나 곧 실행 가능한 PCB(Process Control Block)를 가진 프로그램이다.

* **스레드(Thread)**
    - 제어의 흐름을 의미하는 것으로 프로세스에서 실행의 개념만을 분리한 개념이다.
    - 프로세스의 구성을 크게 제어의 흐름 부분(실행 단위)과 실행 환경 부분으로 나눌 때, 스레드는 프로세스의 실행 부분을 담당함으로써 실행의 기본 단위가 된다.
* **Thread 와 Process 비교**

    |구분|Thread|Process|
    |:---:|:---|:---|
    |상호통신|⦁ Library Call<br/>⦁ 요청 Thread만 Blocking<br/>|⦁ System Call<br/>⦁ Call 종료 시까지 전체 자원 Blocking|
    |처리방식|CPU를 이용하는 기본 작업단위로 구분|자원 할당을 위한 기본 구분 단위
    |부하|프로세스보다 상대적으로 부하 발생이 적음|⦁ Context Switching으로 인한 부하 발생<br/>⦁ 프로세스 자원 할당 시 부하 발생|

# CPU 스케줄링 (CPU 점유)

## 1. 프로세스 상태전이

- **운영체제-프로세스 실행 제어, 프로세스에 대한 정보 유지**를 담당
- **프로세스 실행 결정 및 필요한 시스템 자원을 할당하는 과정**
- **프로세스의 상태 변환을 위해 OS 는 작업 스케줄러(Job Scheduler), 프로세스 스케줄러(Process Scheduler) 두 종류의 CPU 스케줄러를 사용**

## 2. 프로세스 상태전이도(Process State Transition Diagram)


![Process State Transition](/assets/images/posts/process_state.png)

[이미지 출처](https://www.usna.edu/Users/cs/crabbe/SI411/current/processes/processes.html)

- 과정
    + 프로세스가 실행되면 모든 프로세스는 준비상태의 준비 큐(FIFO)로 들어간다.
    + 준비 큐의 프로세스는 CPU 스케줄링 알고리즘에 의해서 CPU를 점유하게 되고 프로세스를 실행한다.
    + CPU에서 실행중인 프로세스가 Time out이 되면 다시 준비 큐의 뒤로 들어가고 CPU를 점유할 때까지 대기한다.
    + 만약 실행중인 프로세스가 디스크 입출력과 같은 작업이 발생하면 대기 상태가 되고 입출력을 수행한다.
    + 입출력이 완료되면 다시 프로세스는 준비상태로 들어가 대기하게 된다.

- Active 모드에서의 프로세스 상태 변환

    |상태||상태 변환 내용|
    |:---:|:---|:---|
    |Admit|생성->준비|준비 큐가 비어있을 떄(작업 스케줄러가 담당)|
    |**Dispatch**|준비->실행|⦁ 준비 큐에 있는 하나의 프로세스를 선택하여 CPU를 할당<br/>⦁ 프로세스 스케줄러(Process Scheduler)가 담당|
    |**Timer Run out**|실행->준비|⦁ CPU를 할당받은 프로세스가 CPU의 제한된 사용시간을 모두 쓴 경우에 발생<br/>⦁ CPU 스케줄링 정책에 따라 우선순위가 높은 프로세스에게 CPU를 양보할 때, 운영 체제 자체의 CPU 서비스 요청 시 전이됨(선점)|
    |**Blocked**|실행->슬립<br/>(대기)|CPU를 할당 받은 프로세스가 I/O 요구, 다른 자원요구 등 CPU 이외의 서비스 작업을 원할 때 발생|
    |**Wake up**|슬립->준비<br/>(대기)|대기 중이던 사건(조건)의 처리가 끝났을 때 발생 (예:I/O 작업 완료)|
    |Release|실행->종료|프로세스의 정상/비정상 종료 시 발생|

- 문맥 교환(Context Switching)
    + CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정
    + 프로세스가 준비->실행, 실행->준비, 실행->대기 등으로 상태 변경될 때 발생
        + **PCB (Process Control Block)**
            * 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳
            * 프로세스의 상태 정보를 저장하는 구조체
            * 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요
            * PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지됨
        + PCB에서 유지되는 정보
            * PID(Process ID) : 프로세스 고유의 번호 (식별자)
            * PC(Program Counter) : 프로세스에서 다음에 실행될 명령의 주소를 가리키는 포인터
            * Process State : 준비, 대기, 실행 등의 상태
            * CPU Registers : 실행 정보를 저장하는 여러 레지스터 정보
            * Priority : 스케줄링 및 프로세스 우선순위
            * Accounting Information : CPU 사용시간, 실제 사용된 시간
            * Memory Pointers : 메모리 관리 정보
            * 입출력 상태 정보
            * 할당된 자원 정보

## 3. CPU 스케줄링 기법

|구분|선점(Preemptive)|비선점(Non-preemptive)|
|:---:|:---|:---|
|개념|프로세스가 CPU 점유 중에도 다른 프로세스가 CPU 점유 가능|프로세스가 CPU를 해제할 때까지 다른 프로세스는 대기|
|장점|⦁ 빠른 응답, 모바일, RTOS<br/>⦁ 대화식 시분할 적합|⦁ 응답 시간 예상 용이<br/>⦁ Batch Process 적합<br/>⦁ 프로세스에 대한 요구를 공정하게 처리|
|단점|Overhead 발생(Context-Switching)|짧은 작업에도 장기간 대기하는 경우가 발생|
|스케줄링 기법|**Round-robin**<br/>⦁ FCFS에 의해 프로세스들이 내보내지며 각 프로세스는 같은 크기의 CPU 시간을 할당한다.<br/>⦁ CPU 시간이 만료될 때까지 처리를 완료하지 못하면 CPU는 대기중인 다음 프로세스로 넘어가며 실행 중이던 프로세스는 준비 완료 리스트의 가장 뒤로 보내진다.<br/> **SRT(Shortest Remaining time)**<br/>⦁ SJF와 마찬가지로 새로 도착한 프로세스를 포함하여 처리가 완료되는 데까지 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행한다.<br/>⦁ 실행 중인 프로세스라도 남은 처리 시간이 더 짧다고 판단되는 프로세스가 생기면 언제라도 실행중인 프로세스가 선점된다.<br/>**Multi Level Queue**<br/>⦁ 여러 종류의 그룹 (시스템 작업, 대화형 작업, 편집 작업, 일괄처리형 작업...) 으로 나누어 여러 개의 큐를 이용하는 스케줄링 기법이다.<br/>⦁ 각각의 준비 큐에 넣어두고 각 큐의 독자적인 스케줄링 알고리즘에 따라서 CPU를 할당받는 방법이다.<br/>**Multi Level Feedback Queue**<br/>⦁ 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 서로 다른 타임 슬라이스를 부여한다.<br/>⦁ 새로운 프로그램이 들어오면 높은 우선순위를 할당해 주어 단계 1에서 즉시 수행하고, 점차 낮은 우선순위를 부여하며 단계 n에서는 라운드로빈으로 순환한다.<br/>⦁ **우선순위 Queue**와 **Round Robin**을 모두 사용하는 Hybrid 스케줄링 기법|**FCFS(First Come First Service)**<br/>⦁ 대기 큐에 도착한 순서에 따라 CPU를 할당한다.<br/>⦁ 긴 작업이 짧은 작업을 오랫동안 기다리게 할 수 있으며, 중요하지 않은 작업이 중요한 작업을 기다리게 할 가능성이 존재한다(대화식 Real Time 시스템에는 부적합).<br/>**SJF(Shortest Job First)**<br/>⦁ 기다리고 있는 작업 중에서 수행 시간이 가장 짧다고 판단된 것을 먼저 수행한다.<br/>⦁ 큰 작업에 대해서는 FCFS에 비해 대기시간 예측이 어렵다.|

# 교착상태 (Deadlock) - 자원 경합
## 1. 상호배제 기법의 정의
- 다수의 프로세스가 **동일 자원에 접근** 시 **무결성을 보장**하기 위한 기법
- 두 개 이상의 프로세스가 **공유 자원에 동시에 읽기/쓰기를 못하게 하는 상호배제** 매커니즘
- **임계영역의 개념을 이용**하여 두 프로세스가 하나의 고유 자원을 상호 배타적으로 사용

## 2. 임계영역
- 정의
    + 공유 자원의 독점을 보장하는 코드 영역. 지정된 시간이 지난 후 종료됨
    + 임계구역에 들어가거나 나올 때는 세마포어 같은 동기화 메커니즘이 사용됨.
- **전형적인 병행프로세스의 구조**

    ```
    do {
        wait(mutex); // 진입구역
        // 임계구역
        signal(mutex); // 출구구역
        // 나머지구역
    } while()
    ```

    + 진입 구역 (entry section) : 임계 구역에 진입하기 위해 허용을 요구한 코드 영역
    + 출구 구역 (exit section) : 임계 구역 다음에 나오는 영역으로 임계 구역을 벗어나기 위한 코드 영역
    + 나머지 구역 (remainder section) : 프로그램의 나머지 코드 영역

## 3. 발생 조건 

|조건|세부 내용|
|:---|:---|
|**상호배제**<br/>(Mutual Exclusion)|⦁ 프로세서들이 자원을 배타적 점유<br/>⦁ 다른 프로세서들이 자원 사용 불가<br/>⦁ 한 번에 한 프로세스만이 자원 사용가능|
|**점유와 대기**<br/>(Hold and Wait)|부분 할당, 다른 종류의 자원을 부가적으로 요구하면서, 이미 어떤 자원을 점유하고 있음|
|**비선점**<br/>(Non-preemption)|⦁ 자원들은 그들을 점유하고 있는 프로세스로부터 도중에 해제되지 않음<br/>⦁ 프로세스들 자신이 점유한 자원을 해제할 수 있음
|**환형대기**<br/>(Circular Wait)|프로세스와 자원들이 원형을 이루며, 각 프로세스는 자신에게 할당된 자원을 가지면서, 상대방 프로세스의 자원을 상호 요청하는 경우|

## 4. 대응 기법
- **예방** : 교착상태의 필요조건을 부정

    |조건|세부 내용|
    |:---|:---|
    |점유와 대기 조건의 부정|각 프로세스는 필요한 자원들을 모두 한꺼번에 요청|
    |비선점 조건의 부정|⦁ 이미 자원을 가지고 있는 프로세스 -> 자원 할당 요구 있을 시 받아들여지지 않으면 -> 보유 자원 반납<br/>⦁ 반납 후 필요 자원에 대한 요구 다시 시도<br/>⦁ 무기한 연기 가능성 존재|
    |환형대기 조건의 부정|⦁ 모든 프로세스에게 각 자원의 유형별로 할당순서를 부여<br/>⦁ 실행 중 우선순위의 변동이나 새로운 자원 추가 시 구성이 어려움|
    |상호 배제 조건 부정|⦁ 상호 배제 조건은 비 공유를 전제<br/>⦁ 공유 가능한 자원들은 배타적인 접근을 요구하지 않으므로 교착상태가 될 수 없음|

- **회피** : 교착상태 가능성을 배제하지 않고, 적절하게 피해 나가는 방법 (은행원 알고리즘)
    + 안전 상태(Safe State) : 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태로 안전순서열이 존재하는 상태
    + 불안전 상태(Unsafe State) : 안전순서열이 존재하지 않는 상태. 교착상태는 불안전 상태에서만 발생함.
    + 안전 상태 개념을 이용하여 교착상태 회피 알고리즘 구성. 현재 가용자원을 프로세스 요청 시 바로 할당해 줄 것인지 기다리게 할 것인지를 결정하는 문제
- **탐지** : 교착상태 발생을 허용하고, 발생 시 원인을 규명하여 해결 (자원 할당 그래프)
    
    |기법|세부 내용|
    |:---|:---|
    |교착상태 발견 알고리즘|⦁ 교착상태 발생 여부를 파악하기 위하여 시스템의 상태를 검사하기 위한 알고리즘<br/>⦁ 교착상태의 발생 빈도 수<br/>⦁ 교착상태가 발생하였을 때 영향을 받는 프로세스의 수|
    |자원 할당 그래프|⦁ 방향 그래프를 이용하여 자원의 할당사항과 요구사항을 나타내는 기법<br/>⦁ 자원 할당 그래프의 소거법을 이용하여 교착상태 감지<br/>⦁ 실행을 완료할 수 있는 프로세스와 교착상태에 빠진 프로세스를 결정|

- **복구** : 교착상태 발견 후 환형대기를 배제시키거나 자원을 중단하는 메모리 할당 기법

    |기법|상세내용|
    |:---|:---|
    |프로세스 중지|⦁ 교착상태 프로세스들을 모두 중지하는 방법<br/>⦁ 교착상태가 해결될 때까지 한 프로세스씩 중지<br/>⦁ 희생자 선택의 원칙:최소 비용으로 중지시키는 방법을 찾아야 함|
    |자원 선점|⦁ 프로세스로부터 자원들을 선점하여, 이들 자원을 교착상태가 해결될 때까지 다른 프로세스들에게 할당<br/>⦁ 희생자 선정, 복귀(rollback) 문제, 기아 상태 문제 등을 고려|

# 디스크 스케줄링

## 1. 디스크 개념
- Arm : head 가 고정되어 있는 장치
- Head : 디스크로부터 정보를 읽어들임
- Sector : 디스크에 정보가 저장되는 최소 단위
- Track : 연속된 sector의 공간
- Cylinder : 수직으로 연속되는 track의 집합
- Platter : 데이터가 저장되는 자기 디스크
- 디스크의 주소를 찾는 과정 : 디스크 번호 -> Platter 번호 -> Track 번호 -> Sector 번호 -> 지정된 주소

## 2. 디스크 접근 시간
- 탐색시간(Seek time) : 현 위치에서 특정 실린더(트랙)로 디스크 헤드가 이동하는 데 소요되는 시간
- 회전 지연시간(Rotation delay time) : 가고자 하는 섹터가 디스크 헤드까지 도달하는 데 걸리는 시간
- 전송시간(Transfer time) : 데이터를 전송하는 데 걸리는 시간

## 3. Disk Scheduling 의 종류

+ 그림 삽입
+ **FCFS(First-Come First Served)**
    * 가장 먼저 도착한 요청을 우선적으로 처리
    * 장점 : 개발이 용이, 공평성 유지
    * 단점 : 이동 경로가 길어짐
+ **SSTF(Shortest-Seek Time First)**
    * 탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스함
    * 현재 Head 위치에 가까운 요청을 우선적으로 처리
    * 장점 : 전반적인 Seek time 감소
    * 단점 : Starvation 현상 발생 가능
+ **SCAN(엘리베이터 알고리즘)**
    * SSTF가 갖는 탐색시간의 편차를 해소하기 위한 기법
    * Head가 이동하는 방향의 모든 요청을 서비스하고, 끝까지 이동한 후 역방향의 요청을 서비스함
+ **C-SCAN(Circular-SCAN)**
    * 바깥쪽에서 안쪽으로 이동
    * 안쪽 방향으로 끝까지 이동을 반복
    * 끝에 도달하면 바깥쪽으로 이동하여 요청을 다시 처리
+ **C-LOOK(Circular-Look)**
    * C-SCAN의 보완, 대기시간을 좀 더 균형 있게 함
    * 헤드 이동 방향의 마지막 입출력 요청을 처리한 후 디스크 헤드를 처음 위치로 이동하여 다음 입출력 요청을 처리

# 디스크 RAID

- **RAID(Redundant Array of Independent Disk)의 개념**
    + 저용량, 저성능, 저가용성인 디스크를 배열(Array) 구조로 중복 구성함으로써 고용량, 고성능, 고가용성 디스크를 대체하고자 함.
    + 데이터 분산 저장에 의한 동시 엑세스 가능, 병렬 데이터 채널에 의한 데이터 전송 시간의 단축
- **RAID 0(Stripe, Concatenate)**
    + 최소 디스크 2개
    + 작은 디스크를 모아 큰 디스크로 만드는 기술
    + 데이터를 나누어 저장하지만 중복 저장하지는 않기 때문에 장애시 복구 불가
- **RAID 1(Mirroring)**
    + 데이터를 완전 이중화 하여 저장(고비용)
    + 디스크 장애시 복구 가능
    + 디스크 Read 와 Write 가 병렬적으로 실행되어 속도가 빠름
- **RAID 2(Hamming Code ECC)**
    + ECC(Error Correction Code)기능이 없는 디스크의 오류 복구를 위해 개발됨.
    + Hamming Code 를 이용하여 오류를 복구
    + 별도의 디스크에 복구를 위한 ECC를 저장
- **RAID 3(Parity ECC)**
    + Parity 정보를 별도 Disk에 저장(Byte 단위 I/O)
    + 1개의 디스크 장애 시 Parity 를 통해 복구 가능
    + RAID 0(Stripping)으로 구성된 데이터 디스크의 입출력 성능은 향상되나, Parity 계산 및 별도 디스크 저장으로 Write 성능이 저하됨.
- **RAID 4(Parity ECC, Block 단위 I/O)**
    + Parity 정보를 별도 Disk에 저장(Block 단위 I/O)
    + RAID 3와 동일
- **RAID 5(Parity ECC, Parity 분산 저장)**
    + 분산 Parity를 구현하여 안정성이 향상됨.
    + 최소 3개의 디스크가 요구됨.
- **RAID 6(Parity ECC, Parity 분산 복수 저장)**
    + RAID 5의 안전성 향상을 위해 Parity를 다중화하여 저장
    + 장애 디스크 복구 이전에 추가 장애 발생 시 복구가 불가한 문제를 해결
    + 장애가 발생된 상황에서 추가 디스크 장애가 발생해도 정상 동작함
