---
title: 01.시스템보안 - 01.운영체제 이해 및 관리
date: '2020-10-23 13:00:00'
tags:
- 정보보안기사
- 시스템 보안
- 운영체제
related: true
categories:
- IS_Certification
toc: true
---

# 운영체제 개요
* 운영체제의 정의 : 컴퓨터 시스템의 자원을 효율적으로 관리, 사용자가 컴퓨터를 효과적으로 사용할수 있도록 환경을 제공하는 여러 프로그램의 모임

# **운영체제 종류**

## 1. 종류
- Batch : 순차적, 한꺼번에 처리
- Multi Programming : N개 프로그램 기동, CPU 가동률 극대화, 유휴 시간 최소화, 스케줄링 필요
- Time Sharing : 시간을 분할하여 CPU 사용
- Multi Process : 다중 CPU
- Real Time System : 실시간 처리
- Multi-Mode : 다중 운영체제 (일괄처리, 시분할, 다중처리, 실시간 처리)
- Distributed System : 네트워크로 분산된 운영체제

## 2. 프로세스와 스레드
* 프로세스(Process)
    - 레지스터, 스택, 포인터, 실행중인 프로그램, 데이터 등의 집합체이다.
    - 실행중인 프로세스(가장 보편적인 정의)이다.
    - 프로세서에 의해 수행되는 프로그램 단위로 현재 실행 중이거나 곧 실행 가능한 PCB(Process Control Block)를 가진 프로그램이다.
        + PCB (Process Control Block)
            * 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳
            * 프로세스의 상태 정보를 저장하는 구조체
            * 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요
            * PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지됨
* 스레드(Thread)
    - 제어의 흐름을 의미하는 것으로 프로세스에서 실행의 개념만을 분리한 개념이다.
    - 프로세스의 구성을 크게 제어의 흐름 부분(실행 단위)과 실행 환경 부분으로 나눌 때, 스레드는 프로세스의 실행 부분을 담당함으로써 실행의 기본 단위가 된다.
* Thread 와 Process 비교

    |구분|Thread|Process|
    |:---:|:---|:---|
    |상호통신|{::nomarkdown}<ul><li>Library Call</li><li>요청 Thread만 Blocking</li></ul>{:/}|{::nomarkdown}<ul><li>System Call</li><li>Call 종료 시까지 전체 자원 Blocking</li></ul>{:/}|
    |처리방식|{::nomarkdown}<ul><li>CPU를 이용하는 기본 작업</li><li>단위로 구분</li></ul>{:/}|자원 할당을 위한 기본 구분 단위
    |부하|프로세스보다 상대적으로 부하 발생이 적음|{::nomarkdown}<ul><li>Context Switching으로 인한 부하 발생</li><li>프로세스 자원 할당 시 부하 발생</li></ul>{:/}|

# CPU 스케줄링 (CPU 점유)

## 1. **프로세스 상태전이**
- Dispatch : 준비에서 실행상태
- Time Run Out : 실행에서 준비상태
- Blocking : 실행에서 입출력 처리
- Wake up : 입출력 처리에서 준비상태

## 2. **CPU 스케줄링 기법**

|구분|선점(Preemptive)|비선점(Non-preemptive)|
|:---:|:---|:---|
|개념|프로세스가 CPU 점유 중에도 다른 프로세스가 CPU 점유 가능|프로세스가 CPU를 해제할 때까지 다른 프로세스는 대기|
|장점|{::nomarkdown}<ul><li>빠른 응답, 모바일, RTOS</li><li>대화식 시분할 적합</li></ul>{:/}|{::nomarkdown}<ul><li>응답 시간 예상 용이</li><li>Batch Process 적합</li><li>프로세스에 대한 요구를 공정하게 처리</li></ul>{:/}|
|단점|Overhead 발생(Context-Switching)|짧은 작업에도 장기간 대기하는 경우가 발생|
|스케줄링 기법|Round-robin{::nomarkdown}<ul><li>FCFS에 의해 프로세스들이 내보내지며 각 프로세스는 같은 크기의 CPU 시간을 할당한다.</li><li>CPU 시간이 만료될 때까지 처리를 완료하지 못하면 CPU는 대기중인 다음 프로세스로 넘어가며 실행 중이던 프로세스는 준비 완료 리스트의 가장 뒤로 보내진다.</li></ul>{:/} SRT(Shortest Remaining time){::nomarkdown}<ul><li>SJF와 마찬가지로 새로 도착한 프로세스를 포함하여 처리가 완료되는 데까지 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행한다.</li><li>실행 중인 프로세스라도 남은 처리 시간이 더 짧다고 판단되는 프로세스가 생기면 언제라도 실행중인 프로세스가 선점된다.</li></ul>{:/}Multi Level Queue{::nomarkdown}<ul><li>여러 종류의 그룹 (시스템 작업, 대화형 작업, 편집 작업, 일괄처리형 작업...) 으로 나누어 여러 개의 큐를 이용하는 스케줄링 기법이다.</li><li>각각의 준비 큐에 넣어두고 각 큐의 독자적인 스케줄링 알고리즘에 따라서 CPU를 할당받는 방법이다.</li></ul>{:/}Multi Level Feedback Queue{::nomarkdown}<ul><li>입출력 위주와 CPU 위주인 프로세스의 특성에 따라 서로 다른 타임 슬라이스를 부여한다.</li><li>새로운 프로그램이 들어오면 높은 우선순위를 할당해 주어 단계 1에서 즉시 수행하고, 점차 낮은 우선순위를 부여하며 단계 n에서는 라운드로빈으로 순환한다.</li><li>우선순위 Queue와 Round Robin을 모두 사용하는 Hybrid 스케줄링 기법</li></ul>{:/}|FCFS(First Come First Service){::nomarkdown}<ul><li>대기 큐에 도착한 순서에 따라 CPU를 할당한다.</li><li>긴 작업이 짧은 작업을 오랫동안 기다리게 할 수 있으며, 중요하지 않은 작업이 중요한 작업을 기다리게 할 가능성이 존재한다(대화식 Real Time 시스템에는 부적합).</li></ul>{:/}SJF(Shortest Job First){::nomarkdown}<ul><li>기다리고 있는 작업 중에서 수행 시간이 가장 짧다고 판단된 것을 먼저 수행한다.</li><li>큰 작업에 대해서는 FCFS에 비해 대기시간 예측이 어렵다.</li></ul>{:/}|

# 교착상태 (Deadlock) - 자원 경합
## 1. 상호배제 기법의 정의
- 다수의 프로세스가 동일 자원에 접근 시 무결성을 보장하기 위한 기법
- 임계영역의 개념을 이용하여 두 프로세스가 하나의 고유 자원을 상호 배타적으로 사용

## 2. 임계영역
- 공유 자원의 독점을 보장하는 코드 영역. 지정된 시간이 지난 후 종료됨
- 임계구역에 들어가거나 나올 때는 세마포어 같은 동기화 메커니즘이 사용됨.

## 3. 발생 조건 
    
|조건|세부 내용|
|:---|:---|
|상호배제(Mutual Exclusion)|{::nomarkdown}<ul><li>프로세서들이 자원을 배타적 점유</li><li>다른 프로세서들이 자원 사용 불가</li><li>한 번에 한 프로세스만이 자원 사용가능</li></ul>{:/}|
|점유와 대기(Hold and Wait)|부분 할당, 다른 종류의 자원을 부가적으로 요구하면서, 이미 어떤 자원을 점유하고 있음|
|비선점(Non-preemption)|{::nomarkdown}<ul><li>자원들은 그들을 점유하고 있는 프로세스로부터 도중에 해제되지 않음</li><li>프로세스들 자신이 점유한 자원을 해제할 수 있음</li></ul>{:/}
|환형대기(Circular Wait)|프로세스와 자원들이 원형을 이루며, 각 프로세스는 자신에게 할당된 자원을 가지면서, 상대방 프로세스의 자원을 상호 요청하는 경우|

## 4. 대응 기법
- 예방 : 발생 조건 부정

    |조건|세부 내용|
    |:---|:---|
    |점유와 대기 조건의 부정|각 프로세스는 필요한 자원들을 모두 한꺼번에 요청|
    |비선점 조건의 부정|{::nomarkdown}<ul><li>이미 자원을 가지고 있는 프로세스 -> 자원 할당 요구 있을 시 받아들여지지 않으면 -> 보유 자원 반납</li><li>반납 후 필요 자원에 대한 요구 다시 시도</li><li>무기한 연기 가능성 존재</li></ul>{:/}|
    |환형대기 조건의 부정|{::nomarkdown}<ul><li>모든 프로세스에게 각 자원의 유형별로 할당순서를 부여</li><li>실행 중 우선순위의 변동이나 새로운 자원 추가 시 구성이 어려움</li></ul>{:/}|
    |상호 배제 조건 부정|{::nomarkdown}<ul><li>상호 배제 조건은 비 공유를 전제</li><li>공유 가능한 자원들은 배타적인 접근을 요구하지 않으므로 교착상태가 될 수 없음</li></ul>{:/}|

- 회피 : 은행원 알고리즘
    + 안전 상태(Safe State) : 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태로 안전순서열이 존재하는 상태
    + 불안전 상태(Unsafe State) : 안전순서열이 존재하지 않는 상태. 교착상태는 불안전 상태에서만 발생함.
    + 안전 상태 개념을 이용하여 교착상태 회피 알고리즘 구성. 현재 가용자원을 프로세스 요청 시 바로 할당해 줄 것인지 기다리게 할 것인지를 결정하는 문제
- 발견 : 자원할당 그래프
    
    |기법|세부 내용|
    |:---|:---|
    |교착상태 발견 알고리즘|{::nomarkdown}<ul><li>교착상태 발생 여부를 파악하기 위하여 시스템의 상태를 검사하기 위한 알고리즘</li><li>교착상태의 발생 빈도 수</li><li>교착상태가 발생하였을 때 영향을 받는 프로세스의 수</li></ul>{:/}|
    |자원 할당 그래프|{::nomarkdown}<ul><li>방향 그래프를 이용하여 자원의 할당사항과 요구사항을 나타내는 기법</li><li>자원 할당 그래프의 소거법을 이용하여 교착상태 감지</li><li>실행을 완료할 수 있는 프로세스와 교착상태에 빠진 프로세스를 결정</li></ul>{:/}|

- 회복 : 희생자 선택

    |기법|상세내용|
    |:---|:---|
    |프로세스 중지|{::nomarkdown}<ul><li>교착상태 프로세스들을 모두 중지하는 방법</li><li>교착상태가 해결될 때까지 한 프로세스씩 중지</li><li>희생자 선택의 원칙:최소 비용으로 중지시키는 방법을 찾아야 함</li></ul>{:/}|
    |자원 선점|{::nomarkdown}<ul><li>프로세스로부터 자원들을 선점하여, 이들 자원을 교착상태가 해결될 때까지 다른 프로세스들에게 할당</li><li>희생자 선정, 복귀(rollback) 문제, 기아 상태 문제 등을 고려</li></ul>{:/}|

# 디스크 스케줄링

## 1. 디스크 개념
- Arm : head 가 고정되어 있는 장치
- Head : 디스크로부터 정보를 읽어들임
- Sector : 디스크에 정보가 저장되는 최소 단위
- Track : 연속된 sector의 공간
- Cylinder : 수직으로 연속되는 track의 집합
- Platter : 데이터가 저장되는 자기 디스크
- 디스크의 주소를 찾는 과정 : 디스크 번호 -> Platter 번호 -> Track 번호 -> Sector 번호 -> 지정된 주소

## 2. 디스크 접근 시간
- 탐색시간(Seek time) : 현 위치에서 특정 실린더(트랙)로 디스크 헤드가 이동하는 데 소요되는 시간
- 회전 지연시간(Rotation delay time) : 가고자 하는 섹터가 디스크 헤드까지 도달하는 데 걸리는 시간
- 전송시간(Transfer time) : 데이터를 전송하는 데 걸리는 시간

## 3. Disk Scheduling 의 종류
+ FCFS(First-Come First Served)
    * 가장 먼저 도착한 요청을 우선적으로 처리
    * 장점 : 개발이 용이, 공평성 유지
    * 단점 : 이동 경로가 길어짐
+ SSTF(Shortest-Seek Time First)
    * 탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스함
    * 현재 Head 위치에 가까운 요청을 우선적으로 처리
    * 장점 : 전반적인 Seek time 감소
    * 단점 : Starvation 현상 발생 가능
+ SCAN(엘리베이터 알고리즘)
    * SSTF가 갖는 탐색시간의 편차를 해소하기 위한 기법
    * Head가 이동하는 방향의 모든 요청을 서비스하고, 끝까지 이동한 후 역방향의 요청을 서비스함
+ C-SCAN(Circular-SCAN)
    * 바깥쪽에서 안쪽으로 이동
    * 안쪽 방향으로 끝까지 이동을 반복
    * 끝에 도달하면 바깥쪽으로 이동하여 요청을 다시 처리
+ C-LOOK(Circular-Look)
    * C-SCAN의 보완, 대기시간을 좀 더 균형 있게 함
    * 헤드 이동 방향의 마지막 입출력 요청을 처리한 후 디스크 헤드를 처음 위치로 이동하여 다음 입출력 요청을 처리

# 디스크 RAID

- RAID(Redundant Array of Independent Disk)의 개념
    + 저용량, 저성능, 저가용성인 디스크를 배열(Array) 구조로 중복 구성함으로써 고용량, 고성능, 고가용성 디스크를 대체하고자 함.
    + 데이터 분산 저장에 의한 동시 엑세스 가능, 병렬 데이터 채널에 의한 데이터 전송 시간의 단축
- RAID 0(Stripe, Concatenate)
    + 최소 디스크 2개
    + 작은 디스크를 모아 큰 디스크로 만드는 기술
    + 데이터를 나누어 저장하지만 중복 저장하지는 않기 때문에 장애시 복구 불가
- RAID 1(Mirroring)
    + 데이터를 완전 이중화 하여 저장(고비용)
    + 디스크 장애시 복구 가능
    + 디스크 Read 와 Write 가 병렬적으로 실행되어 속도가 빠름
- RAID 2(Hamming Code ECC)
    + ECC(Error Correction Code)기능이 없는 디스크의 오류 복구를 위해 개발됨.
    + Hamming Code 를 이용하여 오류를 복구
    + 별도의 디스크에 복구를 위한 ECC를 저장
- RAID 3(Parity ECC)
    + Parity 정보를 별도 Disk에 저장(Byte 단위 I/O)
    + 1개의 디스크 장애 시 Parity 를 통해 복구 가능
    + RAID 0(Stripping)으로 구성된 데이터 디스크의 입출력 성능은 향상되나, Parity 계산 및 별도 디스크 저장으로 Write 성능이 저하됨.
- RAID 4(Parity ECC, Block 단위 I/O)
    + Parity 정보를 별도 Disk에 저장(Block 단위 I/O)
    + RAID 3와 동일
- RAID 5(Parity ECC, Parity 분산 저장)
    + 분산 Parity를 구현하여 안정성이 향상됨.
    + 최소 3개의 디스크가 요구됨.
- RAID 6(Parity ECC, Parity 분산 복수 저장)
    + RAID 5의 안전성 향상을 위해 Parity를 다중화하여 저장
    + 장애 디스크 복구 이전에 추가 장애 발생 시 복구가 불가한 문제를 해결
    + 장애가 발생된 상황에서 추가 디스크 장애가 발생해도 정상 동작함
